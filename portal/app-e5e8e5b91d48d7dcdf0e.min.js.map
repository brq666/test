{"version":3,"sources":["webpack:///app-e5e8e5b91d48d7dcdf0e.min.js","webpack:///./app/app.js","webpack:///../~/angular-animate/index.js","webpack:///../~/angular-animate/angular-animate.js","webpack:///../~/angular-sanitize/index.js","webpack:///../~/angular-sanitize/angular-sanitize.js","webpack:///./common/project-router/project.js","webpack:///../~/ui-router-extras/release/ct-ui-router-extras.js","webpack:///../~/oclazyload/dist/ocLazyLoad.js","webpack:///./app/router.js","webpack:///./app/insert/insert.html","webpack:///../~/ccms-sdk/interceptors/token-refresh-interceptor.js","webpack:///../~/ccms-sdk/credentials/index.js","webpack:///../~/js-cookie/src/js.cookie.js","webpack:///../~/ccms-sdk/interceptors/metadata.js","webpack:///./components/index.js","webpack:///./components/menu/index.js","webpack:///./components/menu/directive.js","webpack:///./components/menu/menu.html","webpack:///./components/menu/controller.js","webpack:///./components/menu/service.js","webpack:///./components/menu/template/collectPerInfo.html","webpack:///./components/menu/template/collectPerCtrl.js","webpack:///./components/menu/template/password.html","webpack:///./components/menu/template/passwordCtrl.js","webpack:///./components/menu/template/message.html","webpack:///./components/menu/template/messageCtrl.js","webpack:///./common/utils.js","webpack:///./app/insert/index.js","webpack:///./app/insert/insertCtrl.js","webpack:///../~/angular-es-utils/index.js","webpack:///../~/angular-es-utils/decorators/index.js","webpack:///../~/angular-es-utils/decorators/Inject.js","webpack:///../~/angular-es-utils/decorators/Bind.js","webpack:///../~/angular-es-utils/decorators/Throttle.js","webpack:///../~/angular-es-utils/decorators/Debounce.js","webpack:///../~/angular-es-utils/decorators/Delay.js","webpack:///../~/angular-es-utils/factory-creator/index.js","webpack:///../~/angular-es-utils/module-helper/index.js","webpack:///../~/angular-es-utils/deferred/index.js","webpack:///../~/angular-es-utils/animation/index.js","webpack:///../~/angular-es-utils/event-bus/index.js","webpack:///../~/angular-es-utils/type-auth/index.js","webpack:///../~/ccms-sdk/interceptors/token-refresh-interceptor-jq.js"],"names":["webpackJsonp","module","exports","__webpack_require__","_interopRequireDefault","obj","__esModule","default","_angular","_angular2","_angularResource","_angularResource2","_angularAnimate","_angularAnimate2","_angularSanitize","_angularSanitize2","_ccmsComponents","_ccmsComponents2","_project","_project2","_router","_router2","_components","_components2","_insert","_insert2","_config","_config2","_tokenRefreshInterceptor","_tokenRefreshInterceptorJq","_tokenRefreshInterceptorJq2","setRefreshTokenUrl","passport","setAuthFailedBehavior","location","replace","window","$","ajaxSetup","webApp","config","run","$rootScope","$on","event","viewConfig","tmlLoaded","e","toState","toParams","fromState","fromParams","options","isTrigger","sessionStorage","removeItem","angular","assertArg","arg","name","reason","ngMinErr","mergeClasses","a","b","isArray","join","packageStyles","styles","to","from","pendClasses","classes","fix","isPrefix","className","isString","length","split","forEach","klass","i","removeFromArray","arr","val","index","indexOf","splice","stripCommentsFromElement","element","jqLite","nodeType","ELEMENT_NODE","extractElementNode","elm","$$addClass","$$jqLite","addClass","$$removeClass","removeClass","applyAnimationClassesFactory","prepareAnimationOptions","$$prepared","domOperation","noop","$$domOperationFired","applyAnimationStyles","applyAnimationFromStyles","applyAnimationToStyles","css","mergeAnimationDetails","oldAnimation","newAnimation","target","newOptions","toAdd","toRemove","resolveElementClasses","attr","preparationClasses","concatWithSpace","realDomOperation","extend","existing","splitClassesToLookup","ADD_CLASS","REMOVE_CLASS","flags","value","key","prop","allow","REMOVE_CLASS_SUFFIX","ADD_CLASS_SUFFIX","getDomNode","applyGeneratedPreparationClasses","EVENT_CLASS_PREFIX","clearGeneratedClasses","activeClasses","blockTransitions","node","duration","applyInlineStyle","TRANSITION_DELAY_PROP","blockKeyframeAnimations","applyBlock","ANIMATION_PROP","ANIMATION_PLAYSTATE_KEY","styleTuple","style","getCssKeyframeDurationStyle","ANIMATION_DURATION_PROP","getCssDelayStyle","delay","isKeyframeAnimation","ANIMATION_DELAY_PROP","computeCssStyles","$window","properties","Object","create","detectedStyles","getComputedStyle","formalStyleName","actualStyleName","c","charAt","parseMaxTime","str","maxValue","values","substring","parseFloat","Math","max","truthyTimingValue","getCssTransitionDurationStyle","applyOnlyDuration","TRANSITION_PROP","DURATION_KEY","createLocalCacheLookup","cache","flush","count","entry","total","get","put","registerRestorableStyles","backup","isDefined","getPropertyValue","TRANSITIONEND_EVENT","ANIMATIONEND_EVENT","ACTIVE_CLASS_SUFFIX","PREPARE_CLASS_SUFFIX","NG_ANIMATE_CLASSNAME","NG_ANIMATE_CHILDREN_DATA","CSS_PREFIX","ontransitionend","onwebkittransitionend","onanimationend","onwebkitanimationend","copy","isElement","isFunction","isObject","isUndefined","PROPERTY_KEY","DELAY_KEY","TIMING_KEY","ANIMATION_ITERATION_COUNT_KEY","SAFE_FAST_FORWARD_DURATION_VALUE","TRANSITION_DURATION_PROP","$$minErr","$$rAFSchedulerFactory","$$rAF","scheduler","tasks","queue","concat","nextTick","items","shift","cancelFn","waitUntilQuiet","fn","$$AnimateChildrenDirective","$interpolate","link","scope","attrs","setData","data","ngAnimateChildren","$observe","ANIMATE_TIMER_KEY","ONE_SECOND","ELAPSED_TIME_MAX_DECIMAL_PLACES","CLOSING_TIME_BUFFER","DETECT_CSS_PROPERTIES","transitionDuration","transitionDelay","transitionProperty","animationDuration","animationDelay","animationIterationCount","DETECT_STAGGER_CSS_PROPERTIES","$AnimateCssProvider","$animateProvider","gcsLookup","gcsStaggerLookup","this","$get","$$AnimateRunner","$timeout","$$forceReflow","$sniffer","$$rAFScheduler","$$animateQueue","gcsHashFn","extraClasses","KEY","parentNode","parentID","parentCounter","getAttribute","computeCachedCssStyles","cacheKey","timings","computeCachedCssStaggerStyles","stagger","staggerClassName","callback","rafWaitQueue","push","pageWidth","computeTimings","aD","tD","maxDelay","maxDuration","applyAnimationClasses","initialOptions","endFn","close","rejected","animationClosed","animationCompleted","animationPaused","$$skipPreparationClasses","temporaryStyles","keys","restoreStyles","setProperty","removeProperty","onDone","events","off","onAnimationProgress","animationTimerData","cancel","timer","removeData","runner","complete","applyBlocking","blockTransition","blockKeyframeAnimation","closeAndReturnNoopAnimator","end","$$willAnimate","start","stopPropagation","ev","originalEvent","timeStamp","$manualTimeStamp","Date","now","elapsedTime","toFixed","startTime","maxDelayTime","triggerAnimationStart","recalculateTimingStyles","fullClassName","relativeDelay","hasTransitions","hasAnimations","applyAnimationDelay","delayStyle","maxDurationTime","easing","easeProp","easeVal","timerTime","endTime","animationsData","setupFallbackTimer","currentTimerData","expectedEndTime","onAnimationExpired","on","cleanupStyles","playPause","playAnimation","maxStagger","itemIndex","floor","runnerHost","resume","pause","enabled","animations","transitions","method","isStructural","structural","structuralClassName","addRemoveClassName","applyClassesEarly","trim","hasToStyles","containsKeyframeAnimation","keyframeStyle","staggerVal","transitionStyle","durationStyle","staggerIndex","isFirst","skipBlocking","hasTransitionAll","applyTransitionDuration","applyAnimationDuration","applyTransitionDelay","$$AnimateCssDriverProvider","$$animationProvider","isDocumentFragment","drivers","NG_ANIMATE_SHIM_CLASS_NAME","NG_ANIMATE_ANCHOR_CLASS_NAME","NG_OUT_ANCHOR_CLASS_NAME","NG_IN_ANCHOR_CLASS_NAME","$animateCss","$rootElement","$document","filterCssClasses","getUniqueValues","filter","prepareAnchoredAnimation","outAnchor","inAnchor","calculateAnchorStyles","anchor","coords","getBoundingClientRect","bodyNode","scrollTop","scrollLeft","prepareOutAnimation","animator","clone","getClassVal","prepareInAnimation","endingClasses","startingClasses","remove","cloneNode","rootBodyElement","append","animatorIn","animatorOut","startingAnimator","currentAnimation","done","prepareFromToAnchorAnimation","anchors","fromAnimation","prepareRegularAnimation","toAnimation","anchorAnimations","outElement","inElement","animationRunners","animation","all","status","animationDetails","body","rootNode","contains","$$AnimateJsProvider","$injector","lookupAnimations","matches","flagMap","animationFactory","$$registeredAnimations","applyOptions","executeAnimationFn","args","classesToAdd","classesToRemove","apply","groupEventedAnimations","fnName","operations","ani","endProgressCb","resolved","onAnimationComplete","result","cancelled","packageAnimations","runners","animateFn","reject","arguments","before","after","afterFn","beforeFn","toUpperCase","substr","onComplete","success","endAnimations","closeActiveAnimations","chain","setHost","$$AnimateJsDriverProvider","$$animateJs","prepareAnimation","endFnFactory","NG_ANIMATE_ATTR_NAME","NG_ANIMATE_PIN_DATA","$$AnimateQueueProvider","makeTruthyCssClassMap","classString","ONE_SPACE","map","hasMatchingClasses","newClassString","currentClassString","currentClassMap","some","isAllowed","ruleType","previousAnimation","rules","hasAnimationClasses","and","PRE_DIGEST_STATE","RUNNING_STATE","skip","state","nA","nR","cA","cR","$$HashMap","$$animation","$templateRequest","postDigestTaskFactory","postDigestCalled","$$postDigest","normalizeAnimationDetails","findCallbacks","parent","targetNode","targetParentNode","entries","callbackRegistry","call","filterFromRegistry","list","matchContainer","matchCallback","containerNode","isMatch","cleanupEventListeners","phase","$animate","queueAnimation","notifyProgress","runInNextPostDigestOrNow","callbacks","progress","isAnimatableClassName","documentHidden","hidden","skipAnimations","animationsEnabled","disabledElementsLookup","existingAnimation","activeAnimationsLookup","hasExistingAnimation","areAnimationsAllowed","closeChildAnimations","skipAnimationFlag","cancelAnimationFlag","joinAnimationFlag","isValidAnimation","clearElementAnimationState","counter","markElementAnimationState","animationCancelled","parentElement","realRunner","children","querySelectorAll","child","parseInt","removeAttribute","isMatchingElement","nodeOrElmA","nodeOrElmB","animateChildren","bodyElement","bodyElementDetected","nodeName","rootElementDetected","parentAnimationDetected","elementDisabled","parentHost","details","parentElementDisabled","allowAnimation","setAttribute","oldValue","newValue","deregisterWatch","$watch","totalPendingRequests","isEmpty","classNameFilter","test","Node","prototype","compareDocumentPosition","container","eventType","pin","bool","argCount","hasElement","$$AnimationProvider","setRunner","RUNNER_STORAGE_KEY","removeRunner","getRunner","NG_ANIMATE_REF_ATTR","sortAnimations","processNode","processed","elementNode","domNode","lookup","parentEntry","tree","flatten","remainingLevelEntries","nextLevelEntries","row","childEntry","animationQueue","getAnchorNodes","SELECTOR","hasAttribute","groupAnimations","preparedAnimations","refLookup","enterOrMove","anchorNodes","direction","animationID","usedIndicesLookup","anchorGroups","indexKey","toString","lookupKey","group","beforeStart","cssClassesIntersection","out","in","aa","j","invokeFirstDriver","driverName","factory","driver","tempClasses","prepareClassName","updateAnimationRunners","newRunner","update","handleDestroyedElement","groupedAnimations","toBeSortedAnimations","animationEntry","startAnimationFn","closeFn","targetElement","operation","animationRunner","ngAnimateSwapDirective","restrict","transclude","terminal","priority","$element","ctrl","$transclude","previousElement","previousScope","$watchCollection","ngAnimateSwap","leave","$destroy","$new","enter","directive","provider","$SanitizeProvider","toMap","lowercaseKeys","lowercase","htmlParserImpl","html","handler","undefined","inertBodyElement","innerHTML","mXSSAttempts","$sanitizeMinErr","document","documentMode","stripCustomNsAttrs","firstChild","toLowerCase","attrToMap","attributes","chars","textContent","nextNode","nextSibling","removeChild","ii","encodeEntities","SURROGATE_PAIR_REGEXP","hi","charCodeAt","low","NON_ALPHANUMERIC_REGEXP","htmlSanitizeWriterImpl","buf","uriValidator","ignoreCurrentElement","bind","tag","blockedElements","validElements","lkey","isImage","validAttrs","uriAttrs","voidElements","l","attrNode","attrName","lastIndexOf","removeAttributeNode","svgEnabled","$$sanitizeUri","svgElements","htmlParser","htmlSanitizeWriter","uri","enableSvg","optionalEndTagBlockElements","optionalEndTagInlineElements","optionalEndTagElements","blockElements","inlineElements","htmlAttrs","svgAttrs","doc","implementation","createHTMLDocument","docElement","documentElement","getDocumentElement","bodyElements","getElementsByTagName","createElement","appendChild","sanitizeText","writer","$sanitize","LINKY_URL_REGEXP","MAILTO_REGEXP","linkyMinErr","text","addText","addLink","url","linkAttributes","attributesFn","match","raw","$ProjectProvider","$futureStateProvider","getProjectInfo","SCRIPT_TAG_REGEX","SCRIPT_SRC_REGEX","SCRIPT_SEQ_REGEX","scripts","template","matchedScriptSeq","matchedScriptSrc","seq","script","stateFactory","$q","$http","$ocLazyLoad","$log","futureState","loadScripts","errorHandle","err","error","promise","load","nextGroup","then","catch","deferred","defer","templateUrl","response","projectInfo","resolve","console","_this","$inject","definition","type","defineProperty","_angularUiRouter","_angularUiRouter2","_oclazyload","_oclazyload2","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","root","ancestors","first","second","path","n","objectKeys","object","protoKeys","ignoreKeys","arraySearch","array","Array","Number","len","ceil","inheritParams","currentParams","newParams","$current","$to","parentParams","parents","inherited","inheritList","params","inherit","extra","onStateRegistered","stateRegisteredCallbacks","resetIgnoreDsr","ignoreDsr","$StickyStateProvider","$stateProvider","uirextras_coreProvider","core","inactiveStates","stickyStates","DEBUG","registerStickyState","enableDebug","debugMode","$state","$stateParams","mapInactives","mappedStates","stickyAncestors","getStickyStateStack","mapInactivesByImmediateParent","inactivesByAllParents","ancestor","stack","sticky","reverse","getEnterTransition","stateParams","reloadStateTree","ancestorReloaded","inactiveState","self","paramsMatch","paramsEqualForState","ownParams","locals","globals","getInactivatedState","stateParams2","$$equals","equalForKeys","k","calcTreeChanges","transition","fromPath","toPath","keep","retained","slice","exiting","entering","sortByStateDepth","stickySupport","getInactiveStates","identity","sort","getInactiveStatesByParent","processTransition","notIn","elem","flattenReduce","memo","typeIs","isChildOf","other","notSticky","futureInactives","exitingTypes","enteringTypes","treeChanges","currentInactives","notEntering","shouldInactivate","stateRentering","reloaded","reload","orphanedRoots","reduce","currentInactivesByParent","allOrphans","exitOrOrphaned","exit","inactives","reactivatingStates","orphans","stateInactivated","onInactivate","invoke","stateReactivated","onReactivate","stateExiting","exitQueue","onExit","exitingNames","inactiveExiting","includes","debug","localval","inactivePseudoState","stateEntering","onEnter","updateParams","inactivatedState","savedLocals","reset","resetOne","$broadcast","SurrogateState","views","versionHeuristics","hasParamSet","surrogateType","mod_core","internalStates","decorator","parentFn","$$state","collection","item","filterObj","$provide","$state_transitionTo","transitionTo","service","computeDeepStateStatus","deepStateRedirectsByName","hasOwnProperty","recordDeepStateRedirectStatus","getConfig","declaration","deepStateRedirect","dsr","dsrCfg","$dsr$","redirect","stateName","cfg","REDIRECT","lastSubstate","parentStatus","ANCESTOR_REDIRECT","getMatchParams","dsrParams","matchParams","getParamsString","safeString","input","paramsToString","toJson","preventDefault","redirectParams","go","deepStateStatus","dsrState","getRedirect","stateOrName","Error","$deepStateRedirect","mod_sticky","_StickyState","pendingRestore","pendingTransitions","reactivatingLocals","$stickyState","$stickyStateProvider","$urlMatcherFactoryProvider","debugTransition","currentTransition","stickyTransition","message","inactiveLogVar","enterLogVar","exitLogVar","transitionMessage","s","debugViewsAfterSuccess","currentState","statesOnly","local","viewsForState","viewLocals","localsFor","uiViewName","filledByState","viewsByState","table","ParamSet","stateReactivatedSurrogatePhase1","surrogate","stateReactivatedSurrogatePhase2","oldOnEnter","restore","addRestoreFunction","stateInactivatedSurrogate","oldOnExit","stateEnteredSurrogate","stateUpdateParamsSurrogate","stateExitedSurrogate","exited","idx","savedToStatePath","savedFromStatePath","stickyTransitions","terminalReactivatedState","rel","relative","toStateSelf","reactivated","restoreFunctions","restoreFunction","$$uirouterextrasreload","random","tempParam","Param","surrogateToPath","surrogateFromPath","saveViewsToLocals","targetObj","view","viewname","enteringState","pathMessage","transitionPromise","_futureStateProvider","$urlRouterProvider","$urlMatcherFactory","findState","findFutureState","statename","futureStates","nameComponents","current","pop","future","matcher","urlMatcher","exec","parentFutureState","lazyLoadState","deregisterFutureState","errorHandler","failedLoadPolicy","lazyloadInProgress","parentPromises","when","parentFuture","stateFactories","$options","failedLazyLoadPolicy","factoryPromise","fullState","futureState_otherwise","$location","resyncing","lazyLoadMissingState","$urlRouter","resync","sync","initDone","initPromise","states","otherwiseFunc","nextFn","resolveFunctions","addResolve","promiseFn","futureStateType","urlPrefix","parentMatcher","parentName","realParent","navigable","compile","futureParent","pattern","source","otherwise","rule","serviceObject","getResolvePromise","init","unfoundState","log","promises","retryInitialState","app","statesAddedQueue","itsNowRuntimeOhWhatAHappyDay","realStateFn","$futureState","previous","lastPrevious","memos","evt","$transition$","commit","revert","$previousState","memoName","set","previousState","previousParams","defaultStateName","defaultStateParams","forget","decorateInjector","tData","oldinvoke","oldinstantiate","instantiate","popStack","restoreFnStack","tDataStack","transitionDepth","transitionSuccess","tSuccess","transitionFailure","tFail","tPromise","depth","restoreFn","stateVisDirective","$interval","width","height","_scope","_elem","_attrs","addStates","stateMap","px","py","nodes","d","links","active","activeNode","y","nodeEnter","insert","o","x","diagonal","t","svg","transLength","selectAll","circleColors","entered","inactive","d3","layout","size","separation","select","find","updateInterval","setInterval","newval","oldval","oldstates","regModules","regInvokes","regConfigs","modulesToLoad","realModules","recordDeclarations","broadcast","runBlocks","justLoaded","ocLazyLoad","$controllerProvider","$compileProvider","$filterProvider","_register","providers","registerModules","moduleName","moduleFn","tempRunBlocks","getModuleName","modules","newModule","ngModuleFct","requires","_runBlocks","rerun","_invokeQueue","reconfig","_configBlocks","instanceInjector","getInstanceInjector","_registerInvokeList","checkHashes","potentialNew","invokes","newHash","isNew","signature","hashCode","stringify","invokeList","newInvoke","onInvoke","invokeName","callInvoke","fct","invoked","jlen","moduleExists","moduleCache","modulePromises","moduleConfig","_init","elements","names","NG_APP_CLASS_REGEXP","getElementById","jasmine","mocha","mock","addReg","mainModule","JSON","chr","hash","$cacheFactory","filesCache","injector","eventName","info","_broadcast","_$log","_getFilesCache","toggleWatch","watch","getModuleConfig","setModuleConfig","getModules","isLoaded","modulesNames","moduleLoaded","_getModuleName","_getModule","_loadDependencies","localParams","loadedModule","diff","promisesList","getRequires","requireEntry","files","warn","filesLoader","inject","real","_addToLoadList","res","loadNext","requireModule","_unregister","bootstrapFct","bootstrap","force","configFn","$compile","$parse","content","$scope","$attr","model","contents","$delegate","uaCssChecked","useCssLoadPatch","buildElement","el","loaded","cacheBuster","dc","getTime","href","src","onload","onerror","async","serie","insertBeforeElem","lastChild","insertBefore","jQuery","querySelector","ua","navigator","userAgent","platform","v","appVersion","iOSVersion","androidVersion","versionMatch","tries","interval","sheet","cssRules","cssFiles","templatesFiles","jsFiles","cachePromise","pushFile","m","file_type","jsLoader","cssDeferred","cssLoader","templatesDeferred","templatesLoader","jsDeferred","originalModule","errText","originalParams","deferredList","paths","ocLazyLoadLoader","$templateCache","id","searchElement","fromIndex","TypeError","O","abs","Infinity","appRouter","$projectProvider","$httpProvider","defaults","withCredentials","interceptors","_tokenRefreshInterceptor2","responseError","freeze","p","_defineProperty","enumerable","configurable","writable","execAuthFailure","rejection","_credentials","removeRequestCredential","ex","abort","statusText","refreshTokenUrl","_metadata","REQUEST_WHITE_LIST","needToRefreshToken","request","credential","getRequestCredential","headers","REQUEST_TOKEN_HEADER","refreshToken","expireTime","parse","USER_SESSION_AVAILABLE_TIME","_response","pendingRequests","setRequestCredential","top","_jsCookie2","REQUEST_TOKEN_STORAGE_KEY","localStorage","getItem","setItem","_jsCookie","__WEBPACK_AMD_DEFINE_FACTORY__","registeredInModuleLoader","OldCookies","Cookies","api","noConflict","converter","expires","setMilliseconds","getMilliseconds","write","encodeURIComponent","String","decodeURIComponent","escape","cookie","toUTCString","domain","secure","cookies","rdecode","parts","read","json","getJSON","withConverter","_menu","_menu2","_directive","_directive2","execValue","hostname","hostName","tenantId","useXDomain","common","component","_controller","_controller2","controller","controllerAs","_classCallCheck","instance","Constructor","_service","_service2","_collectPerInfo","_collectPerInfo2","_collectPerCtrl","_collectPerCtrl2","_password","_password2","_passwordCtrl","_passwordCtrl2","_message","_message2","_messageCtrl","_messageCtrl2","_utils","_utils2","MenuCtrl","$ccModal","$ccValidator","$ccTips","checkLogin","expired","loginUrl","userName","username","useID","userId","campUserName","user","fetchMenu","getContactAjaxMethod","getAccountLink","navAry","appSeeionMenu","fromJson","getSessionMenu","checkVisit","nav","stringData","menuData","setTimeout","setNavFunction","shuyunLoginUrl","shopInfoDefer","noticeCount","getAti","getShopInfo","ccmsVersion","version_code","overdue","isExpire","getNumber","unionMarketingNumberShow","unionMarketingNumber","clearStorage","logout","modalInstance","confirm","open","logOut","changePassword","modal","title","min-height","min-width","bindings","shuyunContact","exists","addPerInfoFlag","contactLiFlag","contactName","contact","fullName","contactQQ","qq","contactPhone","mobile","contactWW","wangwang","contactEmail","email","contactWeibo","weibo","webDashboard","Stringres","getContactInfo","cancelAddInfo","viewAddPerPop","getHelpLink","helplink","SSOlinkyes","get5xLink","shuYunSSOlink","SSOlink","resoponse","accountlink","accountLink","resertTemplateClickFlag","disponseTitleALink","appOrigin","protocol","host","appRoot","insertCompileLocation","newUrl","showMoreMessageDialog","hasFooter","max-height","interProm","getMessageStatus","param","getStatus","newsTrue","_rsGenerator","_rsGenerator2","VisitResource","webPortal","save","CheckResource","LoginResource","delete","ShopResource","EbmResource","webNode","getNoticesList","pageNo","timestamp","pageSize","NoticesResource","StatusResource","postNotice","setId","noticeId","optName","NoticeResource","deleteNotices","ids","ati","cookiesAry","that","ok","perInfoSave","ccValidators","phone","msg","modelValue","viewValue","validate","collerinfo","contactPerInfo","post","code","sessionData","savePassword","checkpasswd","regex","equalTo","password","tips","saveFn","PasswordInfo","newPassword","oldPassword","webSystem","description","changepassword","$sce","hideContentDialog","noticeObj","hideMessContent","deleIdList","isShowMessContent","setSelectAll","checked","popMesses","deleteButton","selectNoticeId","checkedList","getNoticeCb","pages","isRead","isLastPage","page","isFirstPage","getNoticeEB","onPageChange","pageNum","getNotices","readClick","notice","trustAsHtml","contitle","condate","created","deleteNotice","cb","eb","clearNotice","navElement","moreElement","moreLiElement","listnum","navwidth","offsetWidth","showlistnum","hidelistnum","showLength","display","addEventListener","onresize","_insertCtrl","_insertCtrl2","_dec","_class","_angularEsUtils","IframeCtrl","Inject","context","seesionItem","dataUrl","contextUrl","trustAsResourceUrl","pathname","removeEventListener","EventBus","genResource","dynamicExport","getInjector","Animation","Deferred","ModuleHelper","FactoryCreator","_decorators","_factoryCreator","_factoryCreator2","_moduleHelper","_moduleHelper2","_deferred","_deferred2","_animation","_animation2","_injector","_eventBus","_eventBus2","_dynamicExport","_dynamicExport2","Delay","Debounce","Throttle","Bind","_Inject","_Inject2","_Bind","_Bind2","_Throttle","_Throttle2","_Debounce","_Debounce2","_Delay","_Delay2","stupidSafariProps","propBlacklist","_len","dependencies","_key","descriptor","OriginalConstructor","_len2","_key2","dependency","assign","Function","propertyIsEnumerable","getOwnPropertyNames","recent","_injector2","invokeApply","pendingDebounce","FUNCTION_PRIVATE_PROPS","getPrototypeOf","deps","_createClass","defineProperties","props","protoProps","staticProps","Promise","_resolve","_reject","EVENTS","doneHook","autoRemove","classList","add","_typeAuth","topics","topic","listener","topicListeners","once","onceListener","listenerIndex","dispatch","listeners","getListeners","isClass","func","msie","isNumber","isRegExp","_typeof","isPromiseLike","Symbol","iterator","constructor","beforeSend","xhr","setRequestHeader","ajax","fail"],"mappings":"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","file":"app-e5e8e5b91d48d7dcdf0e.min.js","sourcesContent":["webpackJsonp([0],[\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _angular = __webpack_require__(1);\n\t\n\tvar _angular2 = _interopRequireDefault(_angular);\n\t\n\tvar _angularResource = __webpack_require__(3);\n\t\n\tvar _angularResource2 = _interopRequireDefault(_angularResource);\n\t\n\tvar _angularAnimate = __webpack_require__(5);\n\t\n\tvar _angularAnimate2 = _interopRequireDefault(_angularAnimate);\n\t\n\tvar _angularSanitize = __webpack_require__(7);\n\t\n\tvar _angularSanitize2 = _interopRequireDefault(_angularSanitize);\n\t\n\tvar _ccmsComponents = __webpack_require__(9);\n\t\n\tvar _ccmsComponents2 = _interopRequireDefault(_ccmsComponents);\n\t\n\tvar _project = __webpack_require__(12);\n\t\n\tvar _project2 = _interopRequireDefault(_project);\n\t\n\tvar _router = __webpack_require__(16);\n\t\n\tvar _router2 = _interopRequireDefault(_router);\n\t\n\tvar _components = __webpack_require__(25);\n\t\n\tvar _components2 = _interopRequireDefault(_components);\n\t\n\tvar _insert = __webpack_require__(42);\n\t\n\tvar _insert2 = _interopRequireDefault(_insert);\n\t\n\tvar _config = __webpack_require__(18);\n\t\n\tvar _config2 = _interopRequireDefault(_config);\n\t\n\tvar _tokenRefreshInterceptor = __webpack_require__(19);\n\t\n\tvar _tokenRefreshInterceptorJq = __webpack_require__(58);\n\t\n\tvar _tokenRefreshInterceptorJq2 = _interopRequireDefault(_tokenRefreshInterceptorJq);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t(0, _tokenRefreshInterceptor.setRefreshTokenUrl)(_config2.default.passport + '/credentials/refresh');\n\t(0, _tokenRefreshInterceptor.setAuthFailedBehavior)(function () {\n\t  if (true) {\n\t    location.replace('/portal/timeout.html');\n\t  } else {\n\t    location.replace('/portal/login.html');\n\t  }\n\t});\n\t\n\twindow.$.ajaxSetup(_tokenRefreshInterceptorJq2.default);\n\t\n\tvar webApp = _angular2.default.module('ccmsApp', [_project2.default, _angularAnimate2.default, _angularSanitize2.default, _angularResource2.default, _ccmsComponents2.default, _components2.default, _insert2.default]);\n\twebApp.config(_router2.default);\n\t\n\twebApp.run(['$rootScope', function ($rootScope) {\n\t  $rootScope.$on('$viewContentLoading', function (event, viewConfig) {\n\t    $rootScope.tmlLoaded = false;\n\t  });\n\t  $rootScope.$on('$viewContentLoaded', function (event, viewConfig) {\n\t    $rootScope.tmlLoaded = true;\n\t  });\n\t  $rootScope.$on('$stateChangeStart', function (e, toState, toParams, fromState, fromParams, options) {\n\t    if (!options.isTrigger) {\n\t      sessionStorage.removeItem('marketingParams');\n\t    }\n\t  });\n\t}]);\n\n/***/ },\n/* 1 */,\n/* 2 */,\n/* 3 */,\n/* 4 */,\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(6);\n\tmodule.exports = 'ngAnimate';\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n\t/**\n\t * @license AngularJS v1.5.8\n\t * (c) 2010-2016 Google, Inc. http://angularjs.org\n\t * License: MIT\n\t */\n\t(function(window, angular) {'use strict';\n\t\n\tvar ELEMENT_NODE = 1;\n\tvar COMMENT_NODE = 8;\n\t\n\tvar ADD_CLASS_SUFFIX = '-add';\n\tvar REMOVE_CLASS_SUFFIX = '-remove';\n\tvar EVENT_CLASS_PREFIX = 'ng-';\n\tvar ACTIVE_CLASS_SUFFIX = '-active';\n\tvar PREPARE_CLASS_SUFFIX = '-prepare';\n\t\n\tvar NG_ANIMATE_CLASSNAME = 'ng-animate';\n\tvar NG_ANIMATE_CHILDREN_DATA = '$$ngAnimateChildren';\n\t\n\t// Detect proper transitionend/animationend event names.\n\tvar CSS_PREFIX = '', TRANSITION_PROP, TRANSITIONEND_EVENT, ANIMATION_PROP, ANIMATIONEND_EVENT;\n\t\n\t// If unprefixed events are not supported but webkit-prefixed are, use the latter.\n\t// Otherwise, just use W3C names, browsers not supporting them at all will just ignore them.\n\t// Note: Chrome implements `window.onwebkitanimationend` and doesn't implement `window.onanimationend`\n\t// but at the same time dispatches the `animationend` event and not `webkitAnimationEnd`.\n\t// Register both events in case `window.onanimationend` is not supported because of that,\n\t// do the same for `transitionend` as Safari is likely to exhibit similar behavior.\n\t// Also, the only modern browser that uses vendor prefixes for transitions/keyframes is webkit\n\t// therefore there is no reason to test anymore for other vendor prefixes:\n\t// http://caniuse.com/#search=transition\n\tif ((window.ontransitionend === void 0) && (window.onwebkittransitionend !== void 0)) {\n\t  CSS_PREFIX = '-webkit-';\n\t  TRANSITION_PROP = 'WebkitTransition';\n\t  TRANSITIONEND_EVENT = 'webkitTransitionEnd transitionend';\n\t} else {\n\t  TRANSITION_PROP = 'transition';\n\t  TRANSITIONEND_EVENT = 'transitionend';\n\t}\n\t\n\tif ((window.onanimationend === void 0) && (window.onwebkitanimationend !== void 0)) {\n\t  CSS_PREFIX = '-webkit-';\n\t  ANIMATION_PROP = 'WebkitAnimation';\n\t  ANIMATIONEND_EVENT = 'webkitAnimationEnd animationend';\n\t} else {\n\t  ANIMATION_PROP = 'animation';\n\t  ANIMATIONEND_EVENT = 'animationend';\n\t}\n\t\n\tvar DURATION_KEY = 'Duration';\n\tvar PROPERTY_KEY = 'Property';\n\tvar DELAY_KEY = 'Delay';\n\tvar TIMING_KEY = 'TimingFunction';\n\tvar ANIMATION_ITERATION_COUNT_KEY = 'IterationCount';\n\tvar ANIMATION_PLAYSTATE_KEY = 'PlayState';\n\tvar SAFE_FAST_FORWARD_DURATION_VALUE = 9999;\n\t\n\tvar ANIMATION_DELAY_PROP = ANIMATION_PROP + DELAY_KEY;\n\tvar ANIMATION_DURATION_PROP = ANIMATION_PROP + DURATION_KEY;\n\tvar TRANSITION_DELAY_PROP = TRANSITION_PROP + DELAY_KEY;\n\tvar TRANSITION_DURATION_PROP = TRANSITION_PROP + DURATION_KEY;\n\t\n\tvar ngMinErr = angular.$$minErr('ng');\n\tfunction assertArg(arg, name, reason) {\n\t  if (!arg) {\n\t    throw ngMinErr('areq', \"Argument '{0}' is {1}\", (name || '?'), (reason || \"required\"));\n\t  }\n\t  return arg;\n\t}\n\t\n\tfunction mergeClasses(a,b) {\n\t  if (!a && !b) return '';\n\t  if (!a) return b;\n\t  if (!b) return a;\n\t  if (isArray(a)) a = a.join(' ');\n\t  if (isArray(b)) b = b.join(' ');\n\t  return a + ' ' + b;\n\t}\n\t\n\tfunction packageStyles(options) {\n\t  var styles = {};\n\t  if (options && (options.to || options.from)) {\n\t    styles.to = options.to;\n\t    styles.from = options.from;\n\t  }\n\t  return styles;\n\t}\n\t\n\tfunction pendClasses(classes, fix, isPrefix) {\n\t  var className = '';\n\t  classes = isArray(classes)\n\t      ? classes\n\t      : classes && isString(classes) && classes.length\n\t          ? classes.split(/\\s+/)\n\t          : [];\n\t  forEach(classes, function(klass, i) {\n\t    if (klass && klass.length > 0) {\n\t      className += (i > 0) ? ' ' : '';\n\t      className += isPrefix ? fix + klass\n\t                            : klass + fix;\n\t    }\n\t  });\n\t  return className;\n\t}\n\t\n\tfunction removeFromArray(arr, val) {\n\t  var index = arr.indexOf(val);\n\t  if (val >= 0) {\n\t    arr.splice(index, 1);\n\t  }\n\t}\n\t\n\tfunction stripCommentsFromElement(element) {\n\t  if (element instanceof jqLite) {\n\t    switch (element.length) {\n\t      case 0:\n\t        return element;\n\t\n\t      case 1:\n\t        // there is no point of stripping anything if the element\n\t        // is the only element within the jqLite wrapper.\n\t        // (it's important that we retain the element instance.)\n\t        if (element[0].nodeType === ELEMENT_NODE) {\n\t          return element;\n\t        }\n\t        break;\n\t\n\t      default:\n\t        return jqLite(extractElementNode(element));\n\t    }\n\t  }\n\t\n\t  if (element.nodeType === ELEMENT_NODE) {\n\t    return jqLite(element);\n\t  }\n\t}\n\t\n\tfunction extractElementNode(element) {\n\t  if (!element[0]) return element;\n\t  for (var i = 0; i < element.length; i++) {\n\t    var elm = element[i];\n\t    if (elm.nodeType == ELEMENT_NODE) {\n\t      return elm;\n\t    }\n\t  }\n\t}\n\t\n\tfunction $$addClass($$jqLite, element, className) {\n\t  forEach(element, function(elm) {\n\t    $$jqLite.addClass(elm, className);\n\t  });\n\t}\n\t\n\tfunction $$removeClass($$jqLite, element, className) {\n\t  forEach(element, function(elm) {\n\t    $$jqLite.removeClass(elm, className);\n\t  });\n\t}\n\t\n\tfunction applyAnimationClassesFactory($$jqLite) {\n\t  return function(element, options) {\n\t    if (options.addClass) {\n\t      $$addClass($$jqLite, element, options.addClass);\n\t      options.addClass = null;\n\t    }\n\t    if (options.removeClass) {\n\t      $$removeClass($$jqLite, element, options.removeClass);\n\t      options.removeClass = null;\n\t    }\n\t  };\n\t}\n\t\n\tfunction prepareAnimationOptions(options) {\n\t  options = options || {};\n\t  if (!options.$$prepared) {\n\t    var domOperation = options.domOperation || noop;\n\t    options.domOperation = function() {\n\t      options.$$domOperationFired = true;\n\t      domOperation();\n\t      domOperation = noop;\n\t    };\n\t    options.$$prepared = true;\n\t  }\n\t  return options;\n\t}\n\t\n\tfunction applyAnimationStyles(element, options) {\n\t  applyAnimationFromStyles(element, options);\n\t  applyAnimationToStyles(element, options);\n\t}\n\t\n\tfunction applyAnimationFromStyles(element, options) {\n\t  if (options.from) {\n\t    element.css(options.from);\n\t    options.from = null;\n\t  }\n\t}\n\t\n\tfunction applyAnimationToStyles(element, options) {\n\t  if (options.to) {\n\t    element.css(options.to);\n\t    options.to = null;\n\t  }\n\t}\n\t\n\tfunction mergeAnimationDetails(element, oldAnimation, newAnimation) {\n\t  var target = oldAnimation.options || {};\n\t  var newOptions = newAnimation.options || {};\n\t\n\t  var toAdd = (target.addClass || '') + ' ' + (newOptions.addClass || '');\n\t  var toRemove = (target.removeClass || '') + ' ' + (newOptions.removeClass || '');\n\t  var classes = resolveElementClasses(element.attr('class'), toAdd, toRemove);\n\t\n\t  if (newOptions.preparationClasses) {\n\t    target.preparationClasses = concatWithSpace(newOptions.preparationClasses, target.preparationClasses);\n\t    delete newOptions.preparationClasses;\n\t  }\n\t\n\t  // noop is basically when there is no callback; otherwise something has been set\n\t  var realDomOperation = target.domOperation !== noop ? target.domOperation : null;\n\t\n\t  extend(target, newOptions);\n\t\n\t  // TODO(matsko or sreeramu): proper fix is to maintain all animation callback in array and call at last,but now only leave has the callback so no issue with this.\n\t  if (realDomOperation) {\n\t    target.domOperation = realDomOperation;\n\t  }\n\t\n\t  if (classes.addClass) {\n\t    target.addClass = classes.addClass;\n\t  } else {\n\t    target.addClass = null;\n\t  }\n\t\n\t  if (classes.removeClass) {\n\t    target.removeClass = classes.removeClass;\n\t  } else {\n\t    target.removeClass = null;\n\t  }\n\t\n\t  oldAnimation.addClass = target.addClass;\n\t  oldAnimation.removeClass = target.removeClass;\n\t\n\t  return target;\n\t}\n\t\n\tfunction resolveElementClasses(existing, toAdd, toRemove) {\n\t  var ADD_CLASS = 1;\n\t  var REMOVE_CLASS = -1;\n\t\n\t  var flags = {};\n\t  existing = splitClassesToLookup(existing);\n\t\n\t  toAdd = splitClassesToLookup(toAdd);\n\t  forEach(toAdd, function(value, key) {\n\t    flags[key] = ADD_CLASS;\n\t  });\n\t\n\t  toRemove = splitClassesToLookup(toRemove);\n\t  forEach(toRemove, function(value, key) {\n\t    flags[key] = flags[key] === ADD_CLASS ? null : REMOVE_CLASS;\n\t  });\n\t\n\t  var classes = {\n\t    addClass: '',\n\t    removeClass: ''\n\t  };\n\t\n\t  forEach(flags, function(val, klass) {\n\t    var prop, allow;\n\t    if (val === ADD_CLASS) {\n\t      prop = 'addClass';\n\t      allow = !existing[klass] || existing[klass + REMOVE_CLASS_SUFFIX];\n\t    } else if (val === REMOVE_CLASS) {\n\t      prop = 'removeClass';\n\t      allow = existing[klass] || existing[klass + ADD_CLASS_SUFFIX];\n\t    }\n\t    if (allow) {\n\t      if (classes[prop].length) {\n\t        classes[prop] += ' ';\n\t      }\n\t      classes[prop] += klass;\n\t    }\n\t  });\n\t\n\t  function splitClassesToLookup(classes) {\n\t    if (isString(classes)) {\n\t      classes = classes.split(' ');\n\t    }\n\t\n\t    var obj = {};\n\t    forEach(classes, function(klass) {\n\t      // sometimes the split leaves empty string values\n\t      // incase extra spaces were applied to the options\n\t      if (klass.length) {\n\t        obj[klass] = true;\n\t      }\n\t    });\n\t    return obj;\n\t  }\n\t\n\t  return classes;\n\t}\n\t\n\tfunction getDomNode(element) {\n\t  return (element instanceof jqLite) ? element[0] : element;\n\t}\n\t\n\tfunction applyGeneratedPreparationClasses(element, event, options) {\n\t  var classes = '';\n\t  if (event) {\n\t    classes = pendClasses(event, EVENT_CLASS_PREFIX, true);\n\t  }\n\t  if (options.addClass) {\n\t    classes = concatWithSpace(classes, pendClasses(options.addClass, ADD_CLASS_SUFFIX));\n\t  }\n\t  if (options.removeClass) {\n\t    classes = concatWithSpace(classes, pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX));\n\t  }\n\t  if (classes.length) {\n\t    options.preparationClasses = classes;\n\t    element.addClass(classes);\n\t  }\n\t}\n\t\n\tfunction clearGeneratedClasses(element, options) {\n\t  if (options.preparationClasses) {\n\t    element.removeClass(options.preparationClasses);\n\t    options.preparationClasses = null;\n\t  }\n\t  if (options.activeClasses) {\n\t    element.removeClass(options.activeClasses);\n\t    options.activeClasses = null;\n\t  }\n\t}\n\t\n\tfunction blockTransitions(node, duration) {\n\t  // we use a negative delay value since it performs blocking\n\t  // yet it doesn't kill any existing transitions running on the\n\t  // same element which makes this safe for class-based animations\n\t  var value = duration ? '-' + duration + 's' : '';\n\t  applyInlineStyle(node, [TRANSITION_DELAY_PROP, value]);\n\t  return [TRANSITION_DELAY_PROP, value];\n\t}\n\t\n\tfunction blockKeyframeAnimations(node, applyBlock) {\n\t  var value = applyBlock ? 'paused' : '';\n\t  var key = ANIMATION_PROP + ANIMATION_PLAYSTATE_KEY;\n\t  applyInlineStyle(node, [key, value]);\n\t  return [key, value];\n\t}\n\t\n\tfunction applyInlineStyle(node, styleTuple) {\n\t  var prop = styleTuple[0];\n\t  var value = styleTuple[1];\n\t  node.style[prop] = value;\n\t}\n\t\n\tfunction concatWithSpace(a,b) {\n\t  if (!a) return b;\n\t  if (!b) return a;\n\t  return a + ' ' + b;\n\t}\n\t\n\tvar $$rAFSchedulerFactory = ['$$rAF', function($$rAF) {\n\t  var queue, cancelFn;\n\t\n\t  function scheduler(tasks) {\n\t    // we make a copy since RAFScheduler mutates the state\n\t    // of the passed in array variable and this would be difficult\n\t    // to track down on the outside code\n\t    queue = queue.concat(tasks);\n\t    nextTick();\n\t  }\n\t\n\t  queue = scheduler.queue = [];\n\t\n\t  /* waitUntilQuiet does two things:\n\t   * 1. It will run the FINAL `fn` value only when an uncanceled RAF has passed through\n\t   * 2. It will delay the next wave of tasks from running until the quiet `fn` has run.\n\t   *\n\t   * The motivation here is that animation code can request more time from the scheduler\n\t   * before the next wave runs. This allows for certain DOM properties such as classes to\n\t   * be resolved in time for the next animation to run.\n\t   */\n\t  scheduler.waitUntilQuiet = function(fn) {\n\t    if (cancelFn) cancelFn();\n\t\n\t    cancelFn = $$rAF(function() {\n\t      cancelFn = null;\n\t      fn();\n\t      nextTick();\n\t    });\n\t  };\n\t\n\t  return scheduler;\n\t\n\t  function nextTick() {\n\t    if (!queue.length) return;\n\t\n\t    var items = queue.shift();\n\t    for (var i = 0; i < items.length; i++) {\n\t      items[i]();\n\t    }\n\t\n\t    if (!cancelFn) {\n\t      $$rAF(function() {\n\t        if (!cancelFn) nextTick();\n\t      });\n\t    }\n\t  }\n\t}];\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name ngAnimateChildren\n\t * @restrict AE\n\t * @element ANY\n\t *\n\t * @description\n\t *\n\t * ngAnimateChildren allows you to specify that children of this element should animate even if any\n\t * of the children's parents are currently animating. By default, when an element has an active `enter`, `leave`, or `move`\n\t * (structural) animation, child elements that also have an active structural animation are not animated.\n\t *\n\t * Note that even if `ngAnimteChildren` is set, no child animations will run when the parent element is removed from the DOM (`leave` animation).\n\t *\n\t *\n\t * @param {string} ngAnimateChildren If the value is empty, `true` or `on`,\n\t *     then child animations are allowed. If the value is `false`, child animations are not allowed.\n\t *\n\t * @example\n\t * <example module=\"ngAnimateChildren\" name=\"ngAnimateChildren\" deps=\"angular-animate.js\" animations=\"true\">\n\t     <file name=\"index.html\">\n\t       <div ng-controller=\"mainController as main\">\n\t         <label>Show container? <input type=\"checkbox\" ng-model=\"main.enterElement\" /></label>\n\t         <label>Animate children? <input type=\"checkbox\" ng-model=\"main.animateChildren\" /></label>\n\t         <hr>\n\t         <div ng-animate-children=\"{{main.animateChildren}}\">\n\t           <div ng-if=\"main.enterElement\" class=\"container\">\n\t             List of items:\n\t             <div ng-repeat=\"item in [0, 1, 2, 3]\" class=\"item\">Item {{item}}</div>\n\t           </div>\n\t         </div>\n\t       </div>\n\t     </file>\n\t     <file name=\"animations.css\">\n\t\n\t      .container.ng-enter,\n\t      .container.ng-leave {\n\t        transition: all ease 1.5s;\n\t      }\n\t\n\t      .container.ng-enter,\n\t      .container.ng-leave-active {\n\t        opacity: 0;\n\t      }\n\t\n\t      .container.ng-leave,\n\t      .container.ng-enter-active {\n\t        opacity: 1;\n\t      }\n\t\n\t      .item {\n\t        background: firebrick;\n\t        color: #FFF;\n\t        margin-bottom: 10px;\n\t      }\n\t\n\t      .item.ng-enter,\n\t      .item.ng-leave {\n\t        transition: transform 1.5s ease;\n\t      }\n\t\n\t      .item.ng-enter {\n\t        transform: translateX(50px);\n\t      }\n\t\n\t      .item.ng-enter-active {\n\t        transform: translateX(0);\n\t      }\n\t    </file>\n\t    <file name=\"script.js\">\n\t      angular.module('ngAnimateChildren', ['ngAnimate'])\n\t        .controller('mainController', function() {\n\t          this.animateChildren = false;\n\t          this.enterElement = false;\n\t        });\n\t    </file>\n\t  </example>\n\t */\n\tvar $$AnimateChildrenDirective = ['$interpolate', function($interpolate) {\n\t  return {\n\t    link: function(scope, element, attrs) {\n\t      var val = attrs.ngAnimateChildren;\n\t      if (isString(val) && val.length === 0) { //empty attribute\n\t        element.data(NG_ANIMATE_CHILDREN_DATA, true);\n\t      } else {\n\t        // Interpolate and set the value, so that it is available to\n\t        // animations that run right after compilation\n\t        setData($interpolate(val)(scope));\n\t        attrs.$observe('ngAnimateChildren', setData);\n\t      }\n\t\n\t      function setData(value) {\n\t        value = value === 'on' || value === 'true';\n\t        element.data(NG_ANIMATE_CHILDREN_DATA, value);\n\t      }\n\t    }\n\t  };\n\t}];\n\t\n\tvar ANIMATE_TIMER_KEY = '$$animateCss';\n\t\n\t/**\n\t * @ngdoc service\n\t * @name $animateCss\n\t * @kind object\n\t *\n\t * @description\n\t * The `$animateCss` service is a useful utility to trigger customized CSS-based transitions/keyframes\n\t * from a JavaScript-based animation or directly from a directive. The purpose of `$animateCss` is NOT\n\t * to side-step how `$animate` and ngAnimate work, but the goal is to allow pre-existing animations or\n\t * directives to create more complex animations that can be purely driven using CSS code.\n\t *\n\t * Note that only browsers that support CSS transitions and/or keyframe animations are capable of\n\t * rendering animations triggered via `$animateCss` (bad news for IE9 and lower).\n\t *\n\t * ## Usage\n\t * Once again, `$animateCss` is designed to be used inside of a registered JavaScript animation that\n\t * is powered by ngAnimate. It is possible to use `$animateCss` directly inside of a directive, however,\n\t * any automatic control over cancelling animations and/or preventing animations from being run on\n\t * child elements will not be handled by Angular. For this to work as expected, please use `$animate` to\n\t * trigger the animation and then setup a JavaScript animation that injects `$animateCss` to trigger\n\t * the CSS animation.\n\t *\n\t * The example below shows how we can create a folding animation on an element using `ng-if`:\n\t *\n\t * ```html\n\t * <!-- notice the `fold-animation` CSS class -->\n\t * <div ng-if=\"onOff\" class=\"fold-animation\">\n\t *   This element will go BOOM\n\t * </div>\n\t * <button ng-click=\"onOff=true\">Fold In</button>\n\t * ```\n\t *\n\t * Now we create the **JavaScript animation** that will trigger the CSS transition:\n\t *\n\t * ```js\n\t * ngModule.animation('.fold-animation', ['$animateCss', function($animateCss) {\n\t *   return {\n\t *     enter: function(element, doneFn) {\n\t *       var height = element[0].offsetHeight;\n\t *       return $animateCss(element, {\n\t *         from: { height:'0px' },\n\t *         to: { height:height + 'px' },\n\t *         duration: 1 // one second\n\t *       });\n\t *     }\n\t *   }\n\t * }]);\n\t * ```\n\t *\n\t * ## More Advanced Uses\n\t *\n\t * `$animateCss` is the underlying code that ngAnimate uses to power **CSS-based animations** behind the scenes. Therefore CSS hooks\n\t * like `.ng-EVENT`, `.ng-EVENT-active`, `.ng-EVENT-stagger` are all features that can be triggered using `$animateCss` via JavaScript code.\n\t *\n\t * This also means that just about any combination of adding classes, removing classes, setting styles, dynamically setting a keyframe animation,\n\t * applying a hardcoded duration or delay value, changing the animation easing or applying a stagger animation are all options that work with\n\t * `$animateCss`. The service itself is smart enough to figure out the combination of options and examine the element styling properties in order\n\t * to provide a working animation that will run in CSS.\n\t *\n\t * The example below showcases a more advanced version of the `.fold-animation` from the example above:\n\t *\n\t * ```js\n\t * ngModule.animation('.fold-animation', ['$animateCss', function($animateCss) {\n\t *   return {\n\t *     enter: function(element, doneFn) {\n\t *       var height = element[0].offsetHeight;\n\t *       return $animateCss(element, {\n\t *         addClass: 'red large-text pulse-twice',\n\t *         easing: 'ease-out',\n\t *         from: { height:'0px' },\n\t *         to: { height:height + 'px' },\n\t *         duration: 1 // one second\n\t *       });\n\t *     }\n\t *   }\n\t * }]);\n\t * ```\n\t *\n\t * Since we're adding/removing CSS classes then the CSS transition will also pick those up:\n\t *\n\t * ```css\n\t * /&#42; since a hardcoded duration value of 1 was provided in the JavaScript animation code,\n\t * the CSS classes below will be transitioned despite them being defined as regular CSS classes &#42;/\n\t * .red { background:red; }\n\t * .large-text { font-size:20px; }\n\t *\n\t * /&#42; we can also use a keyframe animation and $animateCss will make it work alongside the transition &#42;/\n\t * .pulse-twice {\n\t *   animation: 0.5s pulse linear 2;\n\t *   -webkit-animation: 0.5s pulse linear 2;\n\t * }\n\t *\n\t * @keyframes pulse {\n\t *   from { transform: scale(0.5); }\n\t *   to { transform: scale(1.5); }\n\t * }\n\t *\n\t * @-webkit-keyframes pulse {\n\t *   from { -webkit-transform: scale(0.5); }\n\t *   to { -webkit-transform: scale(1.5); }\n\t * }\n\t * ```\n\t *\n\t * Given this complex combination of CSS classes, styles and options, `$animateCss` will figure everything out and make the animation happen.\n\t *\n\t * ## How the Options are handled\n\t *\n\t * `$animateCss` is very versatile and intelligent when it comes to figuring out what configurations to apply to the element to ensure the animation\n\t * works with the options provided. Say for example we were adding a class that contained a keyframe value and we wanted to also animate some inline\n\t * styles using the `from` and `to` properties.\n\t *\n\t * ```js\n\t * var animator = $animateCss(element, {\n\t *   from: { background:'red' },\n\t *   to: { background:'blue' }\n\t * });\n\t * animator.start();\n\t * ```\n\t *\n\t * ```css\n\t * .rotating-animation {\n\t *   animation:0.5s rotate linear;\n\t *   -webkit-animation:0.5s rotate linear;\n\t * }\n\t *\n\t * @keyframes rotate {\n\t *   from { transform: rotate(0deg); }\n\t *   to { transform: rotate(360deg); }\n\t * }\n\t *\n\t * @-webkit-keyframes rotate {\n\t *   from { -webkit-transform: rotate(0deg); }\n\t *   to { -webkit-transform: rotate(360deg); }\n\t * }\n\t * ```\n\t *\n\t * The missing pieces here are that we do not have a transition set (within the CSS code nor within the `$animateCss` options) and the duration of the animation is\n\t * going to be detected from what the keyframe styles on the CSS class are. In this event, `$animateCss` will automatically create an inline transition\n\t * style matching the duration detected from the keyframe style (which is present in the CSS class that is being added) and then prepare both the transition\n\t * and keyframe animations to run in parallel on the element. Then when the animation is underway the provided `from` and `to` CSS styles will be applied\n\t * and spread across the transition and keyframe animation.\n\t *\n\t * ## What is returned\n\t *\n\t * `$animateCss` works in two stages: a preparation phase and an animation phase. Therefore when `$animateCss` is first called it will NOT actually\n\t * start the animation. All that is going on here is that the element is being prepared for the animation (which means that the generated CSS classes are\n\t * added and removed on the element). Once `$animateCss` is called it will return an object with the following properties:\n\t *\n\t * ```js\n\t * var animator = $animateCss(element, { ... });\n\t * ```\n\t *\n\t * Now what do the contents of our `animator` variable look like:\n\t *\n\t * ```js\n\t * {\n\t *   // starts the animation\n\t *   start: Function,\n\t *\n\t *   // ends (aborts) the animation\n\t *   end: Function\n\t * }\n\t * ```\n\t *\n\t * To actually start the animation we need to run `animation.start()` which will then return a promise that we can hook into to detect when the animation ends.\n\t * If we choose not to run the animation then we MUST run `animation.end()` to perform a cleanup on the element (since some CSS classes and styles may have been\n\t * applied to the element during the preparation phase). Note that all other properties such as duration, delay, transitions and keyframes are just properties\n\t * and that changing them will not reconfigure the parameters of the animation.\n\t *\n\t * ### runner.done() vs runner.then()\n\t * It is documented that `animation.start()` will return a promise object and this is true, however, there is also an additional method available on the\n\t * runner called `.done(callbackFn)`. The done method works the same as `.finally(callbackFn)`, however, it does **not trigger a digest to occur**.\n\t * Therefore, for performance reasons, it's always best to use `runner.done(callback)` instead of `runner.then()`, `runner.catch()` or `runner.finally()`\n\t * unless you really need a digest to kick off afterwards.\n\t *\n\t * Keep in mind that, to make this easier, ngAnimate has tweaked the JS animations API to recognize when a runner instance is returned from $animateCss\n\t * (so there is no need to call `runner.done(doneFn)` inside of your JavaScript animation code).\n\t * Check the {@link ngAnimate.$animateCss#usage animation code above} to see how this works.\n\t *\n\t * @param {DOMElement} element the element that will be animated\n\t * @param {object} options the animation-related options that will be applied during the animation\n\t *\n\t * * `event` - The DOM event (e.g. enter, leave, move). When used, a generated CSS class of `ng-EVENT` and `ng-EVENT-active` will be applied\n\t * to the element during the animation. Multiple events can be provided when spaces are used as a separator. (Note that this will not perform any DOM operation.)\n\t * * `structural` - Indicates that the `ng-` prefix will be added to the event class. Setting to `false` or omitting will turn `ng-EVENT` and\n\t * `ng-EVENT-active` in `EVENT` and `EVENT-active`. Unused if `event` is omitted.\n\t * * `easing` - The CSS easing value that will be applied to the transition or keyframe animation (or both).\n\t * * `transitionStyle` - The raw CSS transition style that will be used (e.g. `1s linear all`).\n\t * * `keyframeStyle` - The raw CSS keyframe animation style that will be used (e.g. `1s my_animation linear`).\n\t * * `from` - The starting CSS styles (a key/value object) that will be applied at the start of the animation.\n\t * * `to` - The ending CSS styles (a key/value object) that will be applied across the animation via a CSS transition.\n\t * * `addClass` - A space separated list of CSS classes that will be added to the element and spread across the animation.\n\t * * `removeClass` - A space separated list of CSS classes that will be removed from the element and spread across the animation.\n\t * * `duration` - A number value representing the total duration of the transition and/or keyframe (note that a value of 1 is 1000ms). If a value of `0`\n\t * is provided then the animation will be skipped entirely.\n\t * * `delay` - A number value representing the total delay of the transition and/or keyframe (note that a value of 1 is 1000ms). If a value of `true` is\n\t * used then whatever delay value is detected from the CSS classes will be mirrored on the elements styles (e.g. by setting delay true then the style value\n\t * of the element will be `transition-delay: DETECTED_VALUE`). Using `true` is useful when you want the CSS classes and inline styles to all share the same\n\t * CSS delay value.\n\t * * `stagger` - A numeric time value representing the delay between successively animated elements\n\t * ({@link ngAnimate#css-staggering-animations Click here to learn how CSS-based staggering works in ngAnimate.})\n\t * * `staggerIndex` - The numeric index representing the stagger item (e.g. a value of 5 is equal to the sixth item in the stagger; therefore when a\n\t *   `stagger` option value of `0.1` is used then there will be a stagger delay of `600ms`)\n\t * * `applyClassesEarly` - Whether or not the classes being added or removed will be used when detecting the animation. This is set by `$animate` when enter/leave/move animations are fired to ensure that the CSS classes are resolved in time. (Note that this will prevent any transitions from occurring on the classes being added and removed.)\n\t * * `cleanupStyles` - Whether or not the provided `from` and `to` styles will be removed once\n\t *    the animation is closed. This is useful for when the styles are used purely for the sake of\n\t *    the animation and do not have a lasting visual effect on the element (e.g. a collapse and open animation).\n\t *    By default this value is set to `false`.\n\t *\n\t * @return {object} an object with start and end methods and details about the animation.\n\t *\n\t * * `start` - The method to start the animation. This will return a `Promise` when called.\n\t * * `end` - This method will cancel the animation and remove all applied CSS classes and styles.\n\t */\n\tvar ONE_SECOND = 1000;\n\tvar BASE_TEN = 10;\n\t\n\tvar ELAPSED_TIME_MAX_DECIMAL_PLACES = 3;\n\tvar CLOSING_TIME_BUFFER = 1.5;\n\t\n\tvar DETECT_CSS_PROPERTIES = {\n\t  transitionDuration:      TRANSITION_DURATION_PROP,\n\t  transitionDelay:         TRANSITION_DELAY_PROP,\n\t  transitionProperty:      TRANSITION_PROP + PROPERTY_KEY,\n\t  animationDuration:       ANIMATION_DURATION_PROP,\n\t  animationDelay:          ANIMATION_DELAY_PROP,\n\t  animationIterationCount: ANIMATION_PROP + ANIMATION_ITERATION_COUNT_KEY\n\t};\n\t\n\tvar DETECT_STAGGER_CSS_PROPERTIES = {\n\t  transitionDuration:      TRANSITION_DURATION_PROP,\n\t  transitionDelay:         TRANSITION_DELAY_PROP,\n\t  animationDuration:       ANIMATION_DURATION_PROP,\n\t  animationDelay:          ANIMATION_DELAY_PROP\n\t};\n\t\n\tfunction getCssKeyframeDurationStyle(duration) {\n\t  return [ANIMATION_DURATION_PROP, duration + 's'];\n\t}\n\t\n\tfunction getCssDelayStyle(delay, isKeyframeAnimation) {\n\t  var prop = isKeyframeAnimation ? ANIMATION_DELAY_PROP : TRANSITION_DELAY_PROP;\n\t  return [prop, delay + 's'];\n\t}\n\t\n\tfunction computeCssStyles($window, element, properties) {\n\t  var styles = Object.create(null);\n\t  var detectedStyles = $window.getComputedStyle(element) || {};\n\t  forEach(properties, function(formalStyleName, actualStyleName) {\n\t    var val = detectedStyles[formalStyleName];\n\t    if (val) {\n\t      var c = val.charAt(0);\n\t\n\t      // only numerical-based values have a negative sign or digit as the first value\n\t      if (c === '-' || c === '+' || c >= 0) {\n\t        val = parseMaxTime(val);\n\t      }\n\t\n\t      // by setting this to null in the event that the delay is not set or is set directly as 0\n\t      // then we can still allow for negative values to be used later on and not mistake this\n\t      // value for being greater than any other negative value.\n\t      if (val === 0) {\n\t        val = null;\n\t      }\n\t      styles[actualStyleName] = val;\n\t    }\n\t  });\n\t\n\t  return styles;\n\t}\n\t\n\tfunction parseMaxTime(str) {\n\t  var maxValue = 0;\n\t  var values = str.split(/\\s*,\\s*/);\n\t  forEach(values, function(value) {\n\t    // it's always safe to consider only second values and omit `ms` values since\n\t    // getComputedStyle will always handle the conversion for us\n\t    if (value.charAt(value.length - 1) == 's') {\n\t      value = value.substring(0, value.length - 1);\n\t    }\n\t    value = parseFloat(value) || 0;\n\t    maxValue = maxValue ? Math.max(value, maxValue) : value;\n\t  });\n\t  return maxValue;\n\t}\n\t\n\tfunction truthyTimingValue(val) {\n\t  return val === 0 || val != null;\n\t}\n\t\n\tfunction getCssTransitionDurationStyle(duration, applyOnlyDuration) {\n\t  var style = TRANSITION_PROP;\n\t  var value = duration + 's';\n\t  if (applyOnlyDuration) {\n\t    style += DURATION_KEY;\n\t  } else {\n\t    value += ' linear all';\n\t  }\n\t  return [style, value];\n\t}\n\t\n\tfunction createLocalCacheLookup() {\n\t  var cache = Object.create(null);\n\t  return {\n\t    flush: function() {\n\t      cache = Object.create(null);\n\t    },\n\t\n\t    count: function(key) {\n\t      var entry = cache[key];\n\t      return entry ? entry.total : 0;\n\t    },\n\t\n\t    get: function(key) {\n\t      var entry = cache[key];\n\t      return entry && entry.value;\n\t    },\n\t\n\t    put: function(key, value) {\n\t      if (!cache[key]) {\n\t        cache[key] = { total: 1, value: value };\n\t      } else {\n\t        cache[key].total++;\n\t      }\n\t    }\n\t  };\n\t}\n\t\n\t// we do not reassign an already present style value since\n\t// if we detect the style property value again we may be\n\t// detecting styles that were added via the `from` styles.\n\t// We make use of `isDefined` here since an empty string\n\t// or null value (which is what getPropertyValue will return\n\t// for a non-existing style) will still be marked as a valid\n\t// value for the style (a falsy value implies that the style\n\t// is to be removed at the end of the animation). If we had a simple\n\t// \"OR\" statement then it would not be enough to catch that.\n\tfunction registerRestorableStyles(backup, node, properties) {\n\t  forEach(properties, function(prop) {\n\t    backup[prop] = isDefined(backup[prop])\n\t        ? backup[prop]\n\t        : node.style.getPropertyValue(prop);\n\t  });\n\t}\n\t\n\tvar $AnimateCssProvider = ['$animateProvider', function($animateProvider) {\n\t  var gcsLookup = createLocalCacheLookup();\n\t  var gcsStaggerLookup = createLocalCacheLookup();\n\t\n\t  this.$get = ['$window', '$$jqLite', '$$AnimateRunner', '$timeout',\n\t               '$$forceReflow', '$sniffer', '$$rAFScheduler', '$$animateQueue',\n\t       function($window,   $$jqLite,   $$AnimateRunner,   $timeout,\n\t                $$forceReflow,   $sniffer,   $$rAFScheduler, $$animateQueue) {\n\t\n\t    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);\n\t\n\t    var parentCounter = 0;\n\t    function gcsHashFn(node, extraClasses) {\n\t      var KEY = \"$$ngAnimateParentKey\";\n\t      var parentNode = node.parentNode;\n\t      var parentID = parentNode[KEY] || (parentNode[KEY] = ++parentCounter);\n\t      return parentID + '-' + node.getAttribute('class') + '-' + extraClasses;\n\t    }\n\t\n\t    function computeCachedCssStyles(node, className, cacheKey, properties) {\n\t      var timings = gcsLookup.get(cacheKey);\n\t\n\t      if (!timings) {\n\t        timings = computeCssStyles($window, node, properties);\n\t        if (timings.animationIterationCount === 'infinite') {\n\t          timings.animationIterationCount = 1;\n\t        }\n\t      }\n\t\n\t      // we keep putting this in multiple times even though the value and the cacheKey are the same\n\t      // because we're keeping an internal tally of how many duplicate animations are detected.\n\t      gcsLookup.put(cacheKey, timings);\n\t      return timings;\n\t    }\n\t\n\t    function computeCachedCssStaggerStyles(node, className, cacheKey, properties) {\n\t      var stagger;\n\t\n\t      // if we have one or more existing matches of matching elements\n\t      // containing the same parent + CSS styles (which is how cacheKey works)\n\t      // then staggering is possible\n\t      if (gcsLookup.count(cacheKey) > 0) {\n\t        stagger = gcsStaggerLookup.get(cacheKey);\n\t\n\t        if (!stagger) {\n\t          var staggerClassName = pendClasses(className, '-stagger');\n\t\n\t          $$jqLite.addClass(node, staggerClassName);\n\t\n\t          stagger = computeCssStyles($window, node, properties);\n\t\n\t          // force the conversion of a null value to zero incase not set\n\t          stagger.animationDuration = Math.max(stagger.animationDuration, 0);\n\t          stagger.transitionDuration = Math.max(stagger.transitionDuration, 0);\n\t\n\t          $$jqLite.removeClass(node, staggerClassName);\n\t\n\t          gcsStaggerLookup.put(cacheKey, stagger);\n\t        }\n\t      }\n\t\n\t      return stagger || {};\n\t    }\n\t\n\t    var cancelLastRAFRequest;\n\t    var rafWaitQueue = [];\n\t    function waitUntilQuiet(callback) {\n\t      rafWaitQueue.push(callback);\n\t      $$rAFScheduler.waitUntilQuiet(function() {\n\t        gcsLookup.flush();\n\t        gcsStaggerLookup.flush();\n\t\n\t        // DO NOT REMOVE THIS LINE OR REFACTOR OUT THE `pageWidth` variable.\n\t        // PLEASE EXAMINE THE `$$forceReflow` service to understand why.\n\t        var pageWidth = $$forceReflow();\n\t\n\t        // we use a for loop to ensure that if the queue is changed\n\t        // during this looping then it will consider new requests\n\t        for (var i = 0; i < rafWaitQueue.length; i++) {\n\t          rafWaitQueue[i](pageWidth);\n\t        }\n\t        rafWaitQueue.length = 0;\n\t      });\n\t    }\n\t\n\t    function computeTimings(node, className, cacheKey) {\n\t      var timings = computeCachedCssStyles(node, className, cacheKey, DETECT_CSS_PROPERTIES);\n\t      var aD = timings.animationDelay;\n\t      var tD = timings.transitionDelay;\n\t      timings.maxDelay = aD && tD\n\t          ? Math.max(aD, tD)\n\t          : (aD || tD);\n\t      timings.maxDuration = Math.max(\n\t          timings.animationDuration * timings.animationIterationCount,\n\t          timings.transitionDuration);\n\t\n\t      return timings;\n\t    }\n\t\n\t    return function init(element, initialOptions) {\n\t      // all of the animation functions should create\n\t      // a copy of the options data, however, if a\n\t      // parent service has already created a copy then\n\t      // we should stick to using that\n\t      var options = initialOptions || {};\n\t      if (!options.$$prepared) {\n\t        options = prepareAnimationOptions(copy(options));\n\t      }\n\t\n\t      var restoreStyles = {};\n\t      var node = getDomNode(element);\n\t      if (!node\n\t          || !node.parentNode\n\t          || !$$animateQueue.enabled()) {\n\t        return closeAndReturnNoopAnimator();\n\t      }\n\t\n\t      var temporaryStyles = [];\n\t      var classes = element.attr('class');\n\t      var styles = packageStyles(options);\n\t      var animationClosed;\n\t      var animationPaused;\n\t      var animationCompleted;\n\t      var runner;\n\t      var runnerHost;\n\t      var maxDelay;\n\t      var maxDelayTime;\n\t      var maxDuration;\n\t      var maxDurationTime;\n\t      var startTime;\n\t      var events = [];\n\t\n\t      if (options.duration === 0 || (!$sniffer.animations && !$sniffer.transitions)) {\n\t        return closeAndReturnNoopAnimator();\n\t      }\n\t\n\t      var method = options.event && isArray(options.event)\n\t            ? options.event.join(' ')\n\t            : options.event;\n\t\n\t      var isStructural = method && options.structural;\n\t      var structuralClassName = '';\n\t      var addRemoveClassName = '';\n\t\n\t      if (isStructural) {\n\t        structuralClassName = pendClasses(method, EVENT_CLASS_PREFIX, true);\n\t      } else if (method) {\n\t        structuralClassName = method;\n\t      }\n\t\n\t      if (options.addClass) {\n\t        addRemoveClassName += pendClasses(options.addClass, ADD_CLASS_SUFFIX);\n\t      }\n\t\n\t      if (options.removeClass) {\n\t        if (addRemoveClassName.length) {\n\t          addRemoveClassName += ' ';\n\t        }\n\t        addRemoveClassName += pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX);\n\t      }\n\t\n\t      // there may be a situation where a structural animation is combined together\n\t      // with CSS classes that need to resolve before the animation is computed.\n\t      // However this means that there is no explicit CSS code to block the animation\n\t      // from happening (by setting 0s none in the class name). If this is the case\n\t      // we need to apply the classes before the first rAF so we know to continue if\n\t      // there actually is a detected transition or keyframe animation\n\t      if (options.applyClassesEarly && addRemoveClassName.length) {\n\t        applyAnimationClasses(element, options);\n\t      }\n\t\n\t      var preparationClasses = [structuralClassName, addRemoveClassName].join(' ').trim();\n\t      var fullClassName = classes + ' ' + preparationClasses;\n\t      var activeClasses = pendClasses(preparationClasses, ACTIVE_CLASS_SUFFIX);\n\t      var hasToStyles = styles.to && Object.keys(styles.to).length > 0;\n\t      var containsKeyframeAnimation = (options.keyframeStyle || '').length > 0;\n\t\n\t      // there is no way we can trigger an animation if no styles and\n\t      // no classes are being applied which would then trigger a transition,\n\t      // unless there a is raw keyframe value that is applied to the element.\n\t      if (!containsKeyframeAnimation\n\t           && !hasToStyles\n\t           && !preparationClasses) {\n\t        return closeAndReturnNoopAnimator();\n\t      }\n\t\n\t      var cacheKey, stagger;\n\t      if (options.stagger > 0) {\n\t        var staggerVal = parseFloat(options.stagger);\n\t        stagger = {\n\t          transitionDelay: staggerVal,\n\t          animationDelay: staggerVal,\n\t          transitionDuration: 0,\n\t          animationDuration: 0\n\t        };\n\t      } else {\n\t        cacheKey = gcsHashFn(node, fullClassName);\n\t        stagger = computeCachedCssStaggerStyles(node, preparationClasses, cacheKey, DETECT_STAGGER_CSS_PROPERTIES);\n\t      }\n\t\n\t      if (!options.$$skipPreparationClasses) {\n\t        $$jqLite.addClass(element, preparationClasses);\n\t      }\n\t\n\t      var applyOnlyDuration;\n\t\n\t      if (options.transitionStyle) {\n\t        var transitionStyle = [TRANSITION_PROP, options.transitionStyle];\n\t        applyInlineStyle(node, transitionStyle);\n\t        temporaryStyles.push(transitionStyle);\n\t      }\n\t\n\t      if (options.duration >= 0) {\n\t        applyOnlyDuration = node.style[TRANSITION_PROP].length > 0;\n\t        var durationStyle = getCssTransitionDurationStyle(options.duration, applyOnlyDuration);\n\t\n\t        // we set the duration so that it will be picked up by getComputedStyle later\n\t        applyInlineStyle(node, durationStyle);\n\t        temporaryStyles.push(durationStyle);\n\t      }\n\t\n\t      if (options.keyframeStyle) {\n\t        var keyframeStyle = [ANIMATION_PROP, options.keyframeStyle];\n\t        applyInlineStyle(node, keyframeStyle);\n\t        temporaryStyles.push(keyframeStyle);\n\t      }\n\t\n\t      var itemIndex = stagger\n\t          ? options.staggerIndex >= 0\n\t              ? options.staggerIndex\n\t              : gcsLookup.count(cacheKey)\n\t          : 0;\n\t\n\t      var isFirst = itemIndex === 0;\n\t\n\t      // this is a pre-emptive way of forcing the setup classes to be added and applied INSTANTLY\n\t      // without causing any combination of transitions to kick in. By adding a negative delay value\n\t      // it forces the setup class' transition to end immediately. We later then remove the negative\n\t      // transition delay to allow for the transition to naturally do it's thing. The beauty here is\n\t      // that if there is no transition defined then nothing will happen and this will also allow\n\t      // other transitions to be stacked on top of each other without any chopping them out.\n\t      if (isFirst && !options.skipBlocking) {\n\t        blockTransitions(node, SAFE_FAST_FORWARD_DURATION_VALUE);\n\t      }\n\t\n\t      var timings = computeTimings(node, fullClassName, cacheKey);\n\t      var relativeDelay = timings.maxDelay;\n\t      maxDelay = Math.max(relativeDelay, 0);\n\t      maxDuration = timings.maxDuration;\n\t\n\t      var flags = {};\n\t      flags.hasTransitions          = timings.transitionDuration > 0;\n\t      flags.hasAnimations           = timings.animationDuration > 0;\n\t      flags.hasTransitionAll        = flags.hasTransitions && timings.transitionProperty == 'all';\n\t      flags.applyTransitionDuration = hasToStyles && (\n\t                                        (flags.hasTransitions && !flags.hasTransitionAll)\n\t                                         || (flags.hasAnimations && !flags.hasTransitions));\n\t      flags.applyAnimationDuration  = options.duration && flags.hasAnimations;\n\t      flags.applyTransitionDelay    = truthyTimingValue(options.delay) && (flags.applyTransitionDuration || flags.hasTransitions);\n\t      flags.applyAnimationDelay     = truthyTimingValue(options.delay) && flags.hasAnimations;\n\t      flags.recalculateTimingStyles = addRemoveClassName.length > 0;\n\t\n\t      if (flags.applyTransitionDuration || flags.applyAnimationDuration) {\n\t        maxDuration = options.duration ? parseFloat(options.duration) : maxDuration;\n\t\n\t        if (flags.applyTransitionDuration) {\n\t          flags.hasTransitions = true;\n\t          timings.transitionDuration = maxDuration;\n\t          applyOnlyDuration = node.style[TRANSITION_PROP + PROPERTY_KEY].length > 0;\n\t          temporaryStyles.push(getCssTransitionDurationStyle(maxDuration, applyOnlyDuration));\n\t        }\n\t\n\t        if (flags.applyAnimationDuration) {\n\t          flags.hasAnimations = true;\n\t          timings.animationDuration = maxDuration;\n\t          temporaryStyles.push(getCssKeyframeDurationStyle(maxDuration));\n\t        }\n\t      }\n\t\n\t      if (maxDuration === 0 && !flags.recalculateTimingStyles) {\n\t        return closeAndReturnNoopAnimator();\n\t      }\n\t\n\t      if (options.delay != null) {\n\t        var delayStyle;\n\t        if (typeof options.delay !== \"boolean\") {\n\t          delayStyle = parseFloat(options.delay);\n\t          // number in options.delay means we have to recalculate the delay for the closing timeout\n\t          maxDelay = Math.max(delayStyle, 0);\n\t        }\n\t\n\t        if (flags.applyTransitionDelay) {\n\t          temporaryStyles.push(getCssDelayStyle(delayStyle));\n\t        }\n\t\n\t        if (flags.applyAnimationDelay) {\n\t          temporaryStyles.push(getCssDelayStyle(delayStyle, true));\n\t        }\n\t      }\n\t\n\t      // we need to recalculate the delay value since we used a pre-emptive negative\n\t      // delay value and the delay value is required for the final event checking. This\n\t      // property will ensure that this will happen after the RAF phase has passed.\n\t      if (options.duration == null && timings.transitionDuration > 0) {\n\t        flags.recalculateTimingStyles = flags.recalculateTimingStyles || isFirst;\n\t      }\n\t\n\t      maxDelayTime = maxDelay * ONE_SECOND;\n\t      maxDurationTime = maxDuration * ONE_SECOND;\n\t      if (!options.skipBlocking) {\n\t        flags.blockTransition = timings.transitionDuration > 0;\n\t        flags.blockKeyframeAnimation = timings.animationDuration > 0 &&\n\t                                       stagger.animationDelay > 0 &&\n\t                                       stagger.animationDuration === 0;\n\t      }\n\t\n\t      if (options.from) {\n\t        if (options.cleanupStyles) {\n\t          registerRestorableStyles(restoreStyles, node, Object.keys(options.from));\n\t        }\n\t        applyAnimationFromStyles(element, options);\n\t      }\n\t\n\t      if (flags.blockTransition || flags.blockKeyframeAnimation) {\n\t        applyBlocking(maxDuration);\n\t      } else if (!options.skipBlocking) {\n\t        blockTransitions(node, false);\n\t      }\n\t\n\t      // TODO(matsko): for 1.5 change this code to have an animator object for better debugging\n\t      return {\n\t        $$willAnimate: true,\n\t        end: endFn,\n\t        start: function() {\n\t          if (animationClosed) return;\n\t\n\t          runnerHost = {\n\t            end: endFn,\n\t            cancel: cancelFn,\n\t            resume: null, //this will be set during the start() phase\n\t            pause: null\n\t          };\n\t\n\t          runner = new $$AnimateRunner(runnerHost);\n\t\n\t          waitUntilQuiet(start);\n\t\n\t          // we don't have access to pause/resume the animation\n\t          // since it hasn't run yet. AnimateRunner will therefore\n\t          // set noop functions for resume and pause and they will\n\t          // later be overridden once the animation is triggered\n\t          return runner;\n\t        }\n\t      };\n\t\n\t      function endFn() {\n\t        close();\n\t      }\n\t\n\t      function cancelFn() {\n\t        close(true);\n\t      }\n\t\n\t      function close(rejected) { // jshint ignore:line\n\t        // if the promise has been called already then we shouldn't close\n\t        // the animation again\n\t        if (animationClosed || (animationCompleted && animationPaused)) return;\n\t        animationClosed = true;\n\t        animationPaused = false;\n\t\n\t        if (!options.$$skipPreparationClasses) {\n\t          $$jqLite.removeClass(element, preparationClasses);\n\t        }\n\t        $$jqLite.removeClass(element, activeClasses);\n\t\n\t        blockKeyframeAnimations(node, false);\n\t        blockTransitions(node, false);\n\t\n\t        forEach(temporaryStyles, function(entry) {\n\t          // There is only one way to remove inline style properties entirely from elements.\n\t          // By using `removeProperty` this works, but we need to convert camel-cased CSS\n\t          // styles down to hyphenated values.\n\t          node.style[entry[0]] = '';\n\t        });\n\t\n\t        applyAnimationClasses(element, options);\n\t        applyAnimationStyles(element, options);\n\t\n\t        if (Object.keys(restoreStyles).length) {\n\t          forEach(restoreStyles, function(value, prop) {\n\t            value ? node.style.setProperty(prop, value)\n\t                  : node.style.removeProperty(prop);\n\t          });\n\t        }\n\t\n\t        // the reason why we have this option is to allow a synchronous closing callback\n\t        // that is fired as SOON as the animation ends (when the CSS is removed) or if\n\t        // the animation never takes off at all. A good example is a leave animation since\n\t        // the element must be removed just after the animation is over or else the element\n\t        // will appear on screen for one animation frame causing an overbearing flicker.\n\t        if (options.onDone) {\n\t          options.onDone();\n\t        }\n\t\n\t        if (events && events.length) {\n\t          // Remove the transitionend / animationend listener(s)\n\t          element.off(events.join(' '), onAnimationProgress);\n\t        }\n\t\n\t        //Cancel the fallback closing timeout and remove the timer data\n\t        var animationTimerData = element.data(ANIMATE_TIMER_KEY);\n\t        if (animationTimerData) {\n\t          $timeout.cancel(animationTimerData[0].timer);\n\t          element.removeData(ANIMATE_TIMER_KEY);\n\t        }\n\t\n\t        // if the preparation function fails then the promise is not setup\n\t        if (runner) {\n\t          runner.complete(!rejected);\n\t        }\n\t      }\n\t\n\t      function applyBlocking(duration) {\n\t        if (flags.blockTransition) {\n\t          blockTransitions(node, duration);\n\t        }\n\t\n\t        if (flags.blockKeyframeAnimation) {\n\t          blockKeyframeAnimations(node, !!duration);\n\t        }\n\t      }\n\t\n\t      function closeAndReturnNoopAnimator() {\n\t        runner = new $$AnimateRunner({\n\t          end: endFn,\n\t          cancel: cancelFn\n\t        });\n\t\n\t        // should flush the cache animation\n\t        waitUntilQuiet(noop);\n\t        close();\n\t\n\t        return {\n\t          $$willAnimate: false,\n\t          start: function() {\n\t            return runner;\n\t          },\n\t          end: endFn\n\t        };\n\t      }\n\t\n\t      function onAnimationProgress(event) {\n\t        event.stopPropagation();\n\t        var ev = event.originalEvent || event;\n\t\n\t        // we now always use `Date.now()` due to the recent changes with\n\t        // event.timeStamp in Firefox, Webkit and Chrome (see #13494 for more info)\n\t        var timeStamp = ev.$manualTimeStamp || Date.now();\n\t\n\t        /* Firefox (or possibly just Gecko) likes to not round values up\n\t         * when a ms measurement is used for the animation */\n\t        var elapsedTime = parseFloat(ev.elapsedTime.toFixed(ELAPSED_TIME_MAX_DECIMAL_PLACES));\n\t\n\t        /* $manualTimeStamp is a mocked timeStamp value which is set\n\t         * within browserTrigger(). This is only here so that tests can\n\t         * mock animations properly. Real events fallback to event.timeStamp,\n\t         * or, if they don't, then a timeStamp is automatically created for them.\n\t         * We're checking to see if the timeStamp surpasses the expected delay,\n\t         * but we're using elapsedTime instead of the timeStamp on the 2nd\n\t         * pre-condition since animationPauseds sometimes close off early */\n\t        if (Math.max(timeStamp - startTime, 0) >= maxDelayTime && elapsedTime >= maxDuration) {\n\t          // we set this flag to ensure that if the transition is paused then, when resumed,\n\t          // the animation will automatically close itself since transitions cannot be paused.\n\t          animationCompleted = true;\n\t          close();\n\t        }\n\t      }\n\t\n\t      function start() {\n\t        if (animationClosed) return;\n\t        if (!node.parentNode) {\n\t          close();\n\t          return;\n\t        }\n\t\n\t        // even though we only pause keyframe animations here the pause flag\n\t        // will still happen when transitions are used. Only the transition will\n\t        // not be paused since that is not possible. If the animation ends when\n\t        // paused then it will not complete until unpaused or cancelled.\n\t        var playPause = function(playAnimation) {\n\t          if (!animationCompleted) {\n\t            animationPaused = !playAnimation;\n\t            if (timings.animationDuration) {\n\t              var value = blockKeyframeAnimations(node, animationPaused);\n\t              animationPaused\n\t                  ? temporaryStyles.push(value)\n\t                  : removeFromArray(temporaryStyles, value);\n\t            }\n\t          } else if (animationPaused && playAnimation) {\n\t            animationPaused = false;\n\t            close();\n\t          }\n\t        };\n\t\n\t        // checking the stagger duration prevents an accidentally cascade of the CSS delay style\n\t        // being inherited from the parent. If the transition duration is zero then we can safely\n\t        // rely that the delay value is an intentional stagger delay style.\n\t        var maxStagger = itemIndex > 0\n\t                         && ((timings.transitionDuration && stagger.transitionDuration === 0) ||\n\t                            (timings.animationDuration && stagger.animationDuration === 0))\n\t                         && Math.max(stagger.animationDelay, stagger.transitionDelay);\n\t        if (maxStagger) {\n\t          $timeout(triggerAnimationStart,\n\t                   Math.floor(maxStagger * itemIndex * ONE_SECOND),\n\t                   false);\n\t        } else {\n\t          triggerAnimationStart();\n\t        }\n\t\n\t        // this will decorate the existing promise runner with pause/resume methods\n\t        runnerHost.resume = function() {\n\t          playPause(true);\n\t        };\n\t\n\t        runnerHost.pause = function() {\n\t          playPause(false);\n\t        };\n\t\n\t        function triggerAnimationStart() {\n\t          // just incase a stagger animation kicks in when the animation\n\t          // itself was cancelled entirely\n\t          if (animationClosed) return;\n\t\n\t          applyBlocking(false);\n\t\n\t          forEach(temporaryStyles, function(entry) {\n\t            var key = entry[0];\n\t            var value = entry[1];\n\t            node.style[key] = value;\n\t          });\n\t\n\t          applyAnimationClasses(element, options);\n\t          $$jqLite.addClass(element, activeClasses);\n\t\n\t          if (flags.recalculateTimingStyles) {\n\t            fullClassName = node.className + ' ' + preparationClasses;\n\t            cacheKey = gcsHashFn(node, fullClassName);\n\t\n\t            timings = computeTimings(node, fullClassName, cacheKey);\n\t            relativeDelay = timings.maxDelay;\n\t            maxDelay = Math.max(relativeDelay, 0);\n\t            maxDuration = timings.maxDuration;\n\t\n\t            if (maxDuration === 0) {\n\t              close();\n\t              return;\n\t            }\n\t\n\t            flags.hasTransitions = timings.transitionDuration > 0;\n\t            flags.hasAnimations = timings.animationDuration > 0;\n\t          }\n\t\n\t          if (flags.applyAnimationDelay) {\n\t            relativeDelay = typeof options.delay !== \"boolean\" && truthyTimingValue(options.delay)\n\t                  ? parseFloat(options.delay)\n\t                  : relativeDelay;\n\t\n\t            maxDelay = Math.max(relativeDelay, 0);\n\t            timings.animationDelay = relativeDelay;\n\t            delayStyle = getCssDelayStyle(relativeDelay, true);\n\t            temporaryStyles.push(delayStyle);\n\t            node.style[delayStyle[0]] = delayStyle[1];\n\t          }\n\t\n\t          maxDelayTime = maxDelay * ONE_SECOND;\n\t          maxDurationTime = maxDuration * ONE_SECOND;\n\t\n\t          if (options.easing) {\n\t            var easeProp, easeVal = options.easing;\n\t            if (flags.hasTransitions) {\n\t              easeProp = TRANSITION_PROP + TIMING_KEY;\n\t              temporaryStyles.push([easeProp, easeVal]);\n\t              node.style[easeProp] = easeVal;\n\t            }\n\t            if (flags.hasAnimations) {\n\t              easeProp = ANIMATION_PROP + TIMING_KEY;\n\t              temporaryStyles.push([easeProp, easeVal]);\n\t              node.style[easeProp] = easeVal;\n\t            }\n\t          }\n\t\n\t          if (timings.transitionDuration) {\n\t            events.push(TRANSITIONEND_EVENT);\n\t          }\n\t\n\t          if (timings.animationDuration) {\n\t            events.push(ANIMATIONEND_EVENT);\n\t          }\n\t\n\t          startTime = Date.now();\n\t          var timerTime = maxDelayTime + CLOSING_TIME_BUFFER * maxDurationTime;\n\t          var endTime = startTime + timerTime;\n\t\n\t          var animationsData = element.data(ANIMATE_TIMER_KEY) || [];\n\t          var setupFallbackTimer = true;\n\t          if (animationsData.length) {\n\t            var currentTimerData = animationsData[0];\n\t            setupFallbackTimer = endTime > currentTimerData.expectedEndTime;\n\t            if (setupFallbackTimer) {\n\t              $timeout.cancel(currentTimerData.timer);\n\t            } else {\n\t              animationsData.push(close);\n\t            }\n\t          }\n\t\n\t          if (setupFallbackTimer) {\n\t            var timer = $timeout(onAnimationExpired, timerTime, false);\n\t            animationsData[0] = {\n\t              timer: timer,\n\t              expectedEndTime: endTime\n\t            };\n\t            animationsData.push(close);\n\t            element.data(ANIMATE_TIMER_KEY, animationsData);\n\t          }\n\t\n\t          if (events.length) {\n\t            element.on(events.join(' '), onAnimationProgress);\n\t          }\n\t\n\t          if (options.to) {\n\t            if (options.cleanupStyles) {\n\t              registerRestorableStyles(restoreStyles, node, Object.keys(options.to));\n\t            }\n\t            applyAnimationToStyles(element, options);\n\t          }\n\t        }\n\t\n\t        function onAnimationExpired() {\n\t          var animationsData = element.data(ANIMATE_TIMER_KEY);\n\t\n\t          // this will be false in the event that the element was\n\t          // removed from the DOM (via a leave animation or something\n\t          // similar)\n\t          if (animationsData) {\n\t            for (var i = 1; i < animationsData.length; i++) {\n\t              animationsData[i]();\n\t            }\n\t            element.removeData(ANIMATE_TIMER_KEY);\n\t          }\n\t        }\n\t      }\n\t    };\n\t  }];\n\t}];\n\t\n\tvar $$AnimateCssDriverProvider = ['$$animationProvider', function($$animationProvider) {\n\t  $$animationProvider.drivers.push('$$animateCssDriver');\n\t\n\t  var NG_ANIMATE_SHIM_CLASS_NAME = 'ng-animate-shim';\n\t  var NG_ANIMATE_ANCHOR_CLASS_NAME = 'ng-anchor';\n\t\n\t  var NG_OUT_ANCHOR_CLASS_NAME = 'ng-anchor-out';\n\t  var NG_IN_ANCHOR_CLASS_NAME = 'ng-anchor-in';\n\t\n\t  function isDocumentFragment(node) {\n\t    return node.parentNode && node.parentNode.nodeType === 11;\n\t  }\n\t\n\t  this.$get = ['$animateCss', '$rootScope', '$$AnimateRunner', '$rootElement', '$sniffer', '$$jqLite', '$document',\n\t       function($animateCss,   $rootScope,   $$AnimateRunner,   $rootElement,   $sniffer,   $$jqLite,   $document) {\n\t\n\t    // only browsers that support these properties can render animations\n\t    if (!$sniffer.animations && !$sniffer.transitions) return noop;\n\t\n\t    var bodyNode = $document[0].body;\n\t    var rootNode = getDomNode($rootElement);\n\t\n\t    var rootBodyElement = jqLite(\n\t      // this is to avoid using something that exists outside of the body\n\t      // we also special case the doc fragment case because our unit test code\n\t      // appends the $rootElement to the body after the app has been bootstrapped\n\t      isDocumentFragment(rootNode) || bodyNode.contains(rootNode) ? rootNode : bodyNode\n\t    );\n\t\n\t    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);\n\t\n\t    return function initDriverFn(animationDetails) {\n\t      return animationDetails.from && animationDetails.to\n\t          ? prepareFromToAnchorAnimation(animationDetails.from,\n\t                                         animationDetails.to,\n\t                                         animationDetails.classes,\n\t                                         animationDetails.anchors)\n\t          : prepareRegularAnimation(animationDetails);\n\t    };\n\t\n\t    function filterCssClasses(classes) {\n\t      //remove all the `ng-` stuff\n\t      return classes.replace(/\\bng-\\S+\\b/g, '');\n\t    }\n\t\n\t    function getUniqueValues(a, b) {\n\t      if (isString(a)) a = a.split(' ');\n\t      if (isString(b)) b = b.split(' ');\n\t      return a.filter(function(val) {\n\t        return b.indexOf(val) === -1;\n\t      }).join(' ');\n\t    }\n\t\n\t    function prepareAnchoredAnimation(classes, outAnchor, inAnchor) {\n\t      var clone = jqLite(getDomNode(outAnchor).cloneNode(true));\n\t      var startingClasses = filterCssClasses(getClassVal(clone));\n\t\n\t      outAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME);\n\t      inAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME);\n\t\n\t      clone.addClass(NG_ANIMATE_ANCHOR_CLASS_NAME);\n\t\n\t      rootBodyElement.append(clone);\n\t\n\t      var animatorIn, animatorOut = prepareOutAnimation();\n\t\n\t      // the user may not end up using the `out` animation and\n\t      // only making use of the `in` animation or vice-versa.\n\t      // In either case we should allow this and not assume the\n\t      // animation is over unless both animations are not used.\n\t      if (!animatorOut) {\n\t        animatorIn = prepareInAnimation();\n\t        if (!animatorIn) {\n\t          return end();\n\t        }\n\t      }\n\t\n\t      var startingAnimator = animatorOut || animatorIn;\n\t\n\t      return {\n\t        start: function() {\n\t          var runner;\n\t\n\t          var currentAnimation = startingAnimator.start();\n\t          currentAnimation.done(function() {\n\t            currentAnimation = null;\n\t            if (!animatorIn) {\n\t              animatorIn = prepareInAnimation();\n\t              if (animatorIn) {\n\t                currentAnimation = animatorIn.start();\n\t                currentAnimation.done(function() {\n\t                  currentAnimation = null;\n\t                  end();\n\t                  runner.complete();\n\t                });\n\t                return currentAnimation;\n\t              }\n\t            }\n\t            // in the event that there is no `in` animation\n\t            end();\n\t            runner.complete();\n\t          });\n\t\n\t          runner = new $$AnimateRunner({\n\t            end: endFn,\n\t            cancel: endFn\n\t          });\n\t\n\t          return runner;\n\t\n\t          function endFn() {\n\t            if (currentAnimation) {\n\t              currentAnimation.end();\n\t            }\n\t          }\n\t        }\n\t      };\n\t\n\t      function calculateAnchorStyles(anchor) {\n\t        var styles = {};\n\t\n\t        var coords = getDomNode(anchor).getBoundingClientRect();\n\t\n\t        // we iterate directly since safari messes up and doesn't return\n\t        // all the keys for the coords object when iterated\n\t        forEach(['width','height','top','left'], function(key) {\n\t          var value = coords[key];\n\t          switch (key) {\n\t            case 'top':\n\t              value += bodyNode.scrollTop;\n\t              break;\n\t            case 'left':\n\t              value += bodyNode.scrollLeft;\n\t              break;\n\t          }\n\t          styles[key] = Math.floor(value) + 'px';\n\t        });\n\t        return styles;\n\t      }\n\t\n\t      function prepareOutAnimation() {\n\t        var animator = $animateCss(clone, {\n\t          addClass: NG_OUT_ANCHOR_CLASS_NAME,\n\t          delay: true,\n\t          from: calculateAnchorStyles(outAnchor)\n\t        });\n\t\n\t        // read the comment within `prepareRegularAnimation` to understand\n\t        // why this check is necessary\n\t        return animator.$$willAnimate ? animator : null;\n\t      }\n\t\n\t      function getClassVal(element) {\n\t        return element.attr('class') || '';\n\t      }\n\t\n\t      function prepareInAnimation() {\n\t        var endingClasses = filterCssClasses(getClassVal(inAnchor));\n\t        var toAdd = getUniqueValues(endingClasses, startingClasses);\n\t        var toRemove = getUniqueValues(startingClasses, endingClasses);\n\t\n\t        var animator = $animateCss(clone, {\n\t          to: calculateAnchorStyles(inAnchor),\n\t          addClass: NG_IN_ANCHOR_CLASS_NAME + ' ' + toAdd,\n\t          removeClass: NG_OUT_ANCHOR_CLASS_NAME + ' ' + toRemove,\n\t          delay: true\n\t        });\n\t\n\t        // read the comment within `prepareRegularAnimation` to understand\n\t        // why this check is necessary\n\t        return animator.$$willAnimate ? animator : null;\n\t      }\n\t\n\t      function end() {\n\t        clone.remove();\n\t        outAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME);\n\t        inAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME);\n\t      }\n\t    }\n\t\n\t    function prepareFromToAnchorAnimation(from, to, classes, anchors) {\n\t      var fromAnimation = prepareRegularAnimation(from, noop);\n\t      var toAnimation = prepareRegularAnimation(to, noop);\n\t\n\t      var anchorAnimations = [];\n\t      forEach(anchors, function(anchor) {\n\t        var outElement = anchor['out'];\n\t        var inElement = anchor['in'];\n\t        var animator = prepareAnchoredAnimation(classes, outElement, inElement);\n\t        if (animator) {\n\t          anchorAnimations.push(animator);\n\t        }\n\t      });\n\t\n\t      // no point in doing anything when there are no elements to animate\n\t      if (!fromAnimation && !toAnimation && anchorAnimations.length === 0) return;\n\t\n\t      return {\n\t        start: function() {\n\t          var animationRunners = [];\n\t\n\t          if (fromAnimation) {\n\t            animationRunners.push(fromAnimation.start());\n\t          }\n\t\n\t          if (toAnimation) {\n\t            animationRunners.push(toAnimation.start());\n\t          }\n\t\n\t          forEach(anchorAnimations, function(animation) {\n\t            animationRunners.push(animation.start());\n\t          });\n\t\n\t          var runner = new $$AnimateRunner({\n\t            end: endFn,\n\t            cancel: endFn // CSS-driven animations cannot be cancelled, only ended\n\t          });\n\t\n\t          $$AnimateRunner.all(animationRunners, function(status) {\n\t            runner.complete(status);\n\t          });\n\t\n\t          return runner;\n\t\n\t          function endFn() {\n\t            forEach(animationRunners, function(runner) {\n\t              runner.end();\n\t            });\n\t          }\n\t        }\n\t      };\n\t    }\n\t\n\t    function prepareRegularAnimation(animationDetails) {\n\t      var element = animationDetails.element;\n\t      var options = animationDetails.options || {};\n\t\n\t      if (animationDetails.structural) {\n\t        options.event = animationDetails.event;\n\t        options.structural = true;\n\t        options.applyClassesEarly = true;\n\t\n\t        // we special case the leave animation since we want to ensure that\n\t        // the element is removed as soon as the animation is over. Otherwise\n\t        // a flicker might appear or the element may not be removed at all\n\t        if (animationDetails.event === 'leave') {\n\t          options.onDone = options.domOperation;\n\t        }\n\t      }\n\t\n\t      // We assign the preparationClasses as the actual animation event since\n\t      // the internals of $animateCss will just suffix the event token values\n\t      // with `-active` to trigger the animation.\n\t      if (options.preparationClasses) {\n\t        options.event = concatWithSpace(options.event, options.preparationClasses);\n\t      }\n\t\n\t      var animator = $animateCss(element, options);\n\t\n\t      // the driver lookup code inside of $$animation attempts to spawn a\n\t      // driver one by one until a driver returns a.$$willAnimate animator object.\n\t      // $animateCss will always return an object, however, it will pass in\n\t      // a flag as a hint as to whether an animation was detected or not\n\t      return animator.$$willAnimate ? animator : null;\n\t    }\n\t  }];\n\t}];\n\t\n\t// TODO(matsko): use caching here to speed things up for detection\n\t// TODO(matsko): add documentation\n\t//  by the time...\n\t\n\tvar $$AnimateJsProvider = ['$animateProvider', function($animateProvider) {\n\t  this.$get = ['$injector', '$$AnimateRunner', '$$jqLite',\n\t       function($injector,   $$AnimateRunner,   $$jqLite) {\n\t\n\t    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);\n\t         // $animateJs(element, 'enter');\n\t    return function(element, event, classes, options) {\n\t      var animationClosed = false;\n\t\n\t      // the `classes` argument is optional and if it is not used\n\t      // then the classes will be resolved from the element's className\n\t      // property as well as options.addClass/options.removeClass.\n\t      if (arguments.length === 3 && isObject(classes)) {\n\t        options = classes;\n\t        classes = null;\n\t      }\n\t\n\t      options = prepareAnimationOptions(options);\n\t      if (!classes) {\n\t        classes = element.attr('class') || '';\n\t        if (options.addClass) {\n\t          classes += ' ' + options.addClass;\n\t        }\n\t        if (options.removeClass) {\n\t          classes += ' ' + options.removeClass;\n\t        }\n\t      }\n\t\n\t      var classesToAdd = options.addClass;\n\t      var classesToRemove = options.removeClass;\n\t\n\t      // the lookupAnimations function returns a series of animation objects that are\n\t      // matched up with one or more of the CSS classes. These animation objects are\n\t      // defined via the module.animation factory function. If nothing is detected then\n\t      // we don't return anything which then makes $animation query the next driver.\n\t      var animations = lookupAnimations(classes);\n\t      var before, after;\n\t      if (animations.length) {\n\t        var afterFn, beforeFn;\n\t        if (event == 'leave') {\n\t          beforeFn = 'leave';\n\t          afterFn = 'afterLeave'; // TODO(matsko): get rid of this\n\t        } else {\n\t          beforeFn = 'before' + event.charAt(0).toUpperCase() + event.substr(1);\n\t          afterFn = event;\n\t        }\n\t\n\t        if (event !== 'enter' && event !== 'move') {\n\t          before = packageAnimations(element, event, options, animations, beforeFn);\n\t        }\n\t        after  = packageAnimations(element, event, options, animations, afterFn);\n\t      }\n\t\n\t      // no matching animations\n\t      if (!before && !after) return;\n\t\n\t      function applyOptions() {\n\t        options.domOperation();\n\t        applyAnimationClasses(element, options);\n\t      }\n\t\n\t      function close() {\n\t        animationClosed = true;\n\t        applyOptions();\n\t        applyAnimationStyles(element, options);\n\t      }\n\t\n\t      var runner;\n\t\n\t      return {\n\t        $$willAnimate: true,\n\t        end: function() {\n\t          if (runner) {\n\t            runner.end();\n\t          } else {\n\t            close();\n\t            runner = new $$AnimateRunner();\n\t            runner.complete(true);\n\t          }\n\t          return runner;\n\t        },\n\t        start: function() {\n\t          if (runner) {\n\t            return runner;\n\t          }\n\t\n\t          runner = new $$AnimateRunner();\n\t          var closeActiveAnimations;\n\t          var chain = [];\n\t\n\t          if (before) {\n\t            chain.push(function(fn) {\n\t              closeActiveAnimations = before(fn);\n\t            });\n\t          }\n\t\n\t          if (chain.length) {\n\t            chain.push(function(fn) {\n\t              applyOptions();\n\t              fn(true);\n\t            });\n\t          } else {\n\t            applyOptions();\n\t          }\n\t\n\t          if (after) {\n\t            chain.push(function(fn) {\n\t              closeActiveAnimations = after(fn);\n\t            });\n\t          }\n\t\n\t          runner.setHost({\n\t            end: function() {\n\t              endAnimations();\n\t            },\n\t            cancel: function() {\n\t              endAnimations(true);\n\t            }\n\t          });\n\t\n\t          $$AnimateRunner.chain(chain, onComplete);\n\t          return runner;\n\t\n\t          function onComplete(success) {\n\t            close(success);\n\t            runner.complete(success);\n\t          }\n\t\n\t          function endAnimations(cancelled) {\n\t            if (!animationClosed) {\n\t              (closeActiveAnimations || noop)(cancelled);\n\t              onComplete(cancelled);\n\t            }\n\t          }\n\t        }\n\t      };\n\t\n\t      function executeAnimationFn(fn, element, event, options, onDone) {\n\t        var args;\n\t        switch (event) {\n\t          case 'animate':\n\t            args = [element, options.from, options.to, onDone];\n\t            break;\n\t\n\t          case 'setClass':\n\t            args = [element, classesToAdd, classesToRemove, onDone];\n\t            break;\n\t\n\t          case 'addClass':\n\t            args = [element, classesToAdd, onDone];\n\t            break;\n\t\n\t          case 'removeClass':\n\t            args = [element, classesToRemove, onDone];\n\t            break;\n\t\n\t          default:\n\t            args = [element, onDone];\n\t            break;\n\t        }\n\t\n\t        args.push(options);\n\t\n\t        var value = fn.apply(fn, args);\n\t        if (value) {\n\t          if (isFunction(value.start)) {\n\t            value = value.start();\n\t          }\n\t\n\t          if (value instanceof $$AnimateRunner) {\n\t            value.done(onDone);\n\t          } else if (isFunction(value)) {\n\t            // optional onEnd / onCancel callback\n\t            return value;\n\t          }\n\t        }\n\t\n\t        return noop;\n\t      }\n\t\n\t      function groupEventedAnimations(element, event, options, animations, fnName) {\n\t        var operations = [];\n\t        forEach(animations, function(ani) {\n\t          var animation = ani[fnName];\n\t          if (!animation) return;\n\t\n\t          // note that all of these animations will run in parallel\n\t          operations.push(function() {\n\t            var runner;\n\t            var endProgressCb;\n\t\n\t            var resolved = false;\n\t            var onAnimationComplete = function(rejected) {\n\t              if (!resolved) {\n\t                resolved = true;\n\t                (endProgressCb || noop)(rejected);\n\t                runner.complete(!rejected);\n\t              }\n\t            };\n\t\n\t            runner = new $$AnimateRunner({\n\t              end: function() {\n\t                onAnimationComplete();\n\t              },\n\t              cancel: function() {\n\t                onAnimationComplete(true);\n\t              }\n\t            });\n\t\n\t            endProgressCb = executeAnimationFn(animation, element, event, options, function(result) {\n\t              var cancelled = result === false;\n\t              onAnimationComplete(cancelled);\n\t            });\n\t\n\t            return runner;\n\t          });\n\t        });\n\t\n\t        return operations;\n\t      }\n\t\n\t      function packageAnimations(element, event, options, animations, fnName) {\n\t        var operations = groupEventedAnimations(element, event, options, animations, fnName);\n\t        if (operations.length === 0) {\n\t          var a,b;\n\t          if (fnName === 'beforeSetClass') {\n\t            a = groupEventedAnimations(element, 'removeClass', options, animations, 'beforeRemoveClass');\n\t            b = groupEventedAnimations(element, 'addClass', options, animations, 'beforeAddClass');\n\t          } else if (fnName === 'setClass') {\n\t            a = groupEventedAnimations(element, 'removeClass', options, animations, 'removeClass');\n\t            b = groupEventedAnimations(element, 'addClass', options, animations, 'addClass');\n\t          }\n\t\n\t          if (a) {\n\t            operations = operations.concat(a);\n\t          }\n\t          if (b) {\n\t            operations = operations.concat(b);\n\t          }\n\t        }\n\t\n\t        if (operations.length === 0) return;\n\t\n\t        // TODO(matsko): add documentation\n\t        return function startAnimation(callback) {\n\t          var runners = [];\n\t          if (operations.length) {\n\t            forEach(operations, function(animateFn) {\n\t              runners.push(animateFn());\n\t            });\n\t          }\n\t\n\t          runners.length ? $$AnimateRunner.all(runners, callback) : callback();\n\t\n\t          return function endFn(reject) {\n\t            forEach(runners, function(runner) {\n\t              reject ? runner.cancel() : runner.end();\n\t            });\n\t          };\n\t        };\n\t      }\n\t    };\n\t\n\t    function lookupAnimations(classes) {\n\t      classes = isArray(classes) ? classes : classes.split(' ');\n\t      var matches = [], flagMap = {};\n\t      for (var i=0; i < classes.length; i++) {\n\t        var klass = classes[i],\n\t            animationFactory = $animateProvider.$$registeredAnimations[klass];\n\t        if (animationFactory && !flagMap[klass]) {\n\t          matches.push($injector.get(animationFactory));\n\t          flagMap[klass] = true;\n\t        }\n\t      }\n\t      return matches;\n\t    }\n\t  }];\n\t}];\n\t\n\tvar $$AnimateJsDriverProvider = ['$$animationProvider', function($$animationProvider) {\n\t  $$animationProvider.drivers.push('$$animateJsDriver');\n\t  this.$get = ['$$animateJs', '$$AnimateRunner', function($$animateJs, $$AnimateRunner) {\n\t    return function initDriverFn(animationDetails) {\n\t      if (animationDetails.from && animationDetails.to) {\n\t        var fromAnimation = prepareAnimation(animationDetails.from);\n\t        var toAnimation = prepareAnimation(animationDetails.to);\n\t        if (!fromAnimation && !toAnimation) return;\n\t\n\t        return {\n\t          start: function() {\n\t            var animationRunners = [];\n\t\n\t            if (fromAnimation) {\n\t              animationRunners.push(fromAnimation.start());\n\t            }\n\t\n\t            if (toAnimation) {\n\t              animationRunners.push(toAnimation.start());\n\t            }\n\t\n\t            $$AnimateRunner.all(animationRunners, done);\n\t\n\t            var runner = new $$AnimateRunner({\n\t              end: endFnFactory(),\n\t              cancel: endFnFactory()\n\t            });\n\t\n\t            return runner;\n\t\n\t            function endFnFactory() {\n\t              return function() {\n\t                forEach(animationRunners, function(runner) {\n\t                  // at this point we cannot cancel animations for groups just yet. 1.5+\n\t                  runner.end();\n\t                });\n\t              };\n\t            }\n\t\n\t            function done(status) {\n\t              runner.complete(status);\n\t            }\n\t          }\n\t        };\n\t      } else {\n\t        return prepareAnimation(animationDetails);\n\t      }\n\t    };\n\t\n\t    function prepareAnimation(animationDetails) {\n\t      // TODO(matsko): make sure to check for grouped animations and delegate down to normal animations\n\t      var element = animationDetails.element;\n\t      var event = animationDetails.event;\n\t      var options = animationDetails.options;\n\t      var classes = animationDetails.classes;\n\t      return $$animateJs(element, event, classes, options);\n\t    }\n\t  }];\n\t}];\n\t\n\tvar NG_ANIMATE_ATTR_NAME = 'data-ng-animate';\n\tvar NG_ANIMATE_PIN_DATA = '$ngAnimatePin';\n\tvar $$AnimateQueueProvider = ['$animateProvider', function($animateProvider) {\n\t  var PRE_DIGEST_STATE = 1;\n\t  var RUNNING_STATE = 2;\n\t  var ONE_SPACE = ' ';\n\t\n\t  var rules = this.rules = {\n\t    skip: [],\n\t    cancel: [],\n\t    join: []\n\t  };\n\t\n\t  function makeTruthyCssClassMap(classString) {\n\t    if (!classString) {\n\t      return null;\n\t    }\n\t\n\t    var keys = classString.split(ONE_SPACE);\n\t    var map = Object.create(null);\n\t\n\t    forEach(keys, function(key) {\n\t      map[key] = true;\n\t    });\n\t    return map;\n\t  }\n\t\n\t  function hasMatchingClasses(newClassString, currentClassString) {\n\t    if (newClassString && currentClassString) {\n\t      var currentClassMap = makeTruthyCssClassMap(currentClassString);\n\t      return newClassString.split(ONE_SPACE).some(function(className) {\n\t        return currentClassMap[className];\n\t      });\n\t    }\n\t  }\n\t\n\t  function isAllowed(ruleType, element, currentAnimation, previousAnimation) {\n\t    return rules[ruleType].some(function(fn) {\n\t      return fn(element, currentAnimation, previousAnimation);\n\t    });\n\t  }\n\t\n\t  function hasAnimationClasses(animation, and) {\n\t    var a = (animation.addClass || '').length > 0;\n\t    var b = (animation.removeClass || '').length > 0;\n\t    return and ? a && b : a || b;\n\t  }\n\t\n\t  rules.join.push(function(element, newAnimation, currentAnimation) {\n\t    // if the new animation is class-based then we can just tack that on\n\t    return !newAnimation.structural && hasAnimationClasses(newAnimation);\n\t  });\n\t\n\t  rules.skip.push(function(element, newAnimation, currentAnimation) {\n\t    // there is no need to animate anything if no classes are being added and\n\t    // there is no structural animation that will be triggered\n\t    return !newAnimation.structural && !hasAnimationClasses(newAnimation);\n\t  });\n\t\n\t  rules.skip.push(function(element, newAnimation, currentAnimation) {\n\t    // why should we trigger a new structural animation if the element will\n\t    // be removed from the DOM anyway?\n\t    return currentAnimation.event == 'leave' && newAnimation.structural;\n\t  });\n\t\n\t  rules.skip.push(function(element, newAnimation, currentAnimation) {\n\t    // if there is an ongoing current animation then don't even bother running the class-based animation\n\t    return currentAnimation.structural && currentAnimation.state === RUNNING_STATE && !newAnimation.structural;\n\t  });\n\t\n\t  rules.cancel.push(function(element, newAnimation, currentAnimation) {\n\t    // there can never be two structural animations running at the same time\n\t    return currentAnimation.structural && newAnimation.structural;\n\t  });\n\t\n\t  rules.cancel.push(function(element, newAnimation, currentAnimation) {\n\t    // if the previous animation is already running, but the new animation will\n\t    // be triggered, but the new animation is structural\n\t    return currentAnimation.state === RUNNING_STATE && newAnimation.structural;\n\t  });\n\t\n\t  rules.cancel.push(function(element, newAnimation, currentAnimation) {\n\t    // cancel the animation if classes added / removed in both animation cancel each other out,\n\t    // but only if the current animation isn't structural\n\t\n\t    if (currentAnimation.structural) return false;\n\t\n\t    var nA = newAnimation.addClass;\n\t    var nR = newAnimation.removeClass;\n\t    var cA = currentAnimation.addClass;\n\t    var cR = currentAnimation.removeClass;\n\t\n\t    // early detection to save the global CPU shortage :)\n\t    if ((isUndefined(nA) && isUndefined(nR)) || (isUndefined(cA) && isUndefined(cR))) {\n\t      return false;\n\t    }\n\t\n\t    return hasMatchingClasses(nA, cR) || hasMatchingClasses(nR, cA);\n\t  });\n\t\n\t  this.$get = ['$$rAF', '$rootScope', '$rootElement', '$document', '$$HashMap',\n\t               '$$animation', '$$AnimateRunner', '$templateRequest', '$$jqLite', '$$forceReflow',\n\t       function($$rAF,   $rootScope,   $rootElement,   $document,   $$HashMap,\n\t                $$animation,   $$AnimateRunner,   $templateRequest,   $$jqLite,   $$forceReflow) {\n\t\n\t    var activeAnimationsLookup = new $$HashMap();\n\t    var disabledElementsLookup = new $$HashMap();\n\t    var animationsEnabled = null;\n\t\n\t    function postDigestTaskFactory() {\n\t      var postDigestCalled = false;\n\t      return function(fn) {\n\t        // we only issue a call to postDigest before\n\t        // it has first passed. This prevents any callbacks\n\t        // from not firing once the animation has completed\n\t        // since it will be out of the digest cycle.\n\t        if (postDigestCalled) {\n\t          fn();\n\t        } else {\n\t          $rootScope.$$postDigest(function() {\n\t            postDigestCalled = true;\n\t            fn();\n\t          });\n\t        }\n\t      };\n\t    }\n\t\n\t    // Wait until all directive and route-related templates are downloaded and\n\t    // compiled. The $templateRequest.totalPendingRequests variable keeps track of\n\t    // all of the remote templates being currently downloaded. If there are no\n\t    // templates currently downloading then the watcher will still fire anyway.\n\t    var deregisterWatch = $rootScope.$watch(\n\t      function() { return $templateRequest.totalPendingRequests === 0; },\n\t      function(isEmpty) {\n\t        if (!isEmpty) return;\n\t        deregisterWatch();\n\t\n\t        // Now that all templates have been downloaded, $animate will wait until\n\t        // the post digest queue is empty before enabling animations. By having two\n\t        // calls to $postDigest calls we can ensure that the flag is enabled at the\n\t        // very end of the post digest queue. Since all of the animations in $animate\n\t        // use $postDigest, it's important that the code below executes at the end.\n\t        // This basically means that the page is fully downloaded and compiled before\n\t        // any animations are triggered.\n\t        $rootScope.$$postDigest(function() {\n\t          $rootScope.$$postDigest(function() {\n\t            // we check for null directly in the event that the application already called\n\t            // .enabled() with whatever arguments that it provided it with\n\t            if (animationsEnabled === null) {\n\t              animationsEnabled = true;\n\t            }\n\t          });\n\t        });\n\t      }\n\t    );\n\t\n\t    var callbackRegistry = Object.create(null);\n\t\n\t    // remember that the classNameFilter is set during the provider/config\n\t    // stage therefore we can optimize here and setup a helper function\n\t    var classNameFilter = $animateProvider.classNameFilter();\n\t    var isAnimatableClassName = !classNameFilter\n\t              ? function() { return true; }\n\t              : function(className) {\n\t                return classNameFilter.test(className);\n\t              };\n\t\n\t    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);\n\t\n\t    function normalizeAnimationDetails(element, animation) {\n\t      return mergeAnimationDetails(element, animation, {});\n\t    }\n\t\n\t    // IE9-11 has no method \"contains\" in SVG element and in Node.prototype. Bug #10259.\n\t    var contains = window.Node.prototype.contains || function(arg) {\n\t      // jshint bitwise: false\n\t      return this === arg || !!(this.compareDocumentPosition(arg) & 16);\n\t      // jshint bitwise: true\n\t    };\n\t\n\t    function findCallbacks(parent, element, event) {\n\t      var targetNode = getDomNode(element);\n\t      var targetParentNode = getDomNode(parent);\n\t\n\t      var matches = [];\n\t      var entries = callbackRegistry[event];\n\t      if (entries) {\n\t        forEach(entries, function(entry) {\n\t          if (contains.call(entry.node, targetNode)) {\n\t            matches.push(entry.callback);\n\t          } else if (event === 'leave' && contains.call(entry.node, targetParentNode)) {\n\t            matches.push(entry.callback);\n\t          }\n\t        });\n\t      }\n\t\n\t      return matches;\n\t    }\n\t\n\t    function filterFromRegistry(list, matchContainer, matchCallback) {\n\t      var containerNode = extractElementNode(matchContainer);\n\t      return list.filter(function(entry) {\n\t        var isMatch = entry.node === containerNode &&\n\t                        (!matchCallback || entry.callback === matchCallback);\n\t        return !isMatch;\n\t      });\n\t    }\n\t\n\t    function cleanupEventListeners(phase, element) {\n\t      if (phase === 'close' && !element[0].parentNode) {\n\t        // If the element is not attached to a parentNode, it has been removed by\n\t        // the domOperation, and we can safely remove the event callbacks\n\t        $animate.off(element);\n\t      }\n\t    }\n\t\n\t    var $animate = {\n\t      on: function(event, container, callback) {\n\t        var node = extractElementNode(container);\n\t        callbackRegistry[event] = callbackRegistry[event] || [];\n\t        callbackRegistry[event].push({\n\t          node: node,\n\t          callback: callback\n\t        });\n\t\n\t        // Remove the callback when the element is removed from the DOM\n\t        jqLite(container).on('$destroy', function() {\n\t          var animationDetails = activeAnimationsLookup.get(node);\n\t\n\t          if (!animationDetails) {\n\t            // If there's an animation ongoing, the callback calling code will remove\n\t            // the event listeners. If we'd remove here, the callbacks would be removed\n\t            // before the animation ends\n\t            $animate.off(event, container, callback);\n\t          }\n\t        });\n\t      },\n\t\n\t      off: function(event, container, callback) {\n\t        if (arguments.length === 1 && !isString(arguments[0])) {\n\t          container = arguments[0];\n\t          for (var eventType in callbackRegistry) {\n\t            callbackRegistry[eventType] = filterFromRegistry(callbackRegistry[eventType], container);\n\t          }\n\t\n\t          return;\n\t        }\n\t\n\t        var entries = callbackRegistry[event];\n\t        if (!entries) return;\n\t\n\t        callbackRegistry[event] = arguments.length === 1\n\t            ? null\n\t            : filterFromRegistry(entries, container, callback);\n\t      },\n\t\n\t      pin: function(element, parentElement) {\n\t        assertArg(isElement(element), 'element', 'not an element');\n\t        assertArg(isElement(parentElement), 'parentElement', 'not an element');\n\t        element.data(NG_ANIMATE_PIN_DATA, parentElement);\n\t      },\n\t\n\t      push: function(element, event, options, domOperation) {\n\t        options = options || {};\n\t        options.domOperation = domOperation;\n\t        return queueAnimation(element, event, options);\n\t      },\n\t\n\t      // this method has four signatures:\n\t      //  () - global getter\n\t      //  (bool) - global setter\n\t      //  (element) - element getter\n\t      //  (element, bool) - element setter<F37>\n\t      enabled: function(element, bool) {\n\t        var argCount = arguments.length;\n\t\n\t        if (argCount === 0) {\n\t          // () - Global getter\n\t          bool = !!animationsEnabled;\n\t        } else {\n\t          var hasElement = isElement(element);\n\t\n\t          if (!hasElement) {\n\t            // (bool) - Global setter\n\t            bool = animationsEnabled = !!element;\n\t          } else {\n\t            var node = getDomNode(element);\n\t\n\t            if (argCount === 1) {\n\t              // (element) - Element getter\n\t              bool = !disabledElementsLookup.get(node);\n\t            } else {\n\t              // (element, bool) - Element setter\n\t              disabledElementsLookup.put(node, !bool);\n\t            }\n\t          }\n\t        }\n\t\n\t        return bool;\n\t      }\n\t    };\n\t\n\t    return $animate;\n\t\n\t    function queueAnimation(element, event, initialOptions) {\n\t      // we always make a copy of the options since\n\t      // there should never be any side effects on\n\t      // the input data when running `$animateCss`.\n\t      var options = copy(initialOptions);\n\t\n\t      var node, parent;\n\t      element = stripCommentsFromElement(element);\n\t      if (element) {\n\t        node = getDomNode(element);\n\t        parent = element.parent();\n\t      }\n\t\n\t      options = prepareAnimationOptions(options);\n\t\n\t      // we create a fake runner with a working promise.\n\t      // These methods will become available after the digest has passed\n\t      var runner = new $$AnimateRunner();\n\t\n\t      // this is used to trigger callbacks in postDigest mode\n\t      var runInNextPostDigestOrNow = postDigestTaskFactory();\n\t\n\t      if (isArray(options.addClass)) {\n\t        options.addClass = options.addClass.join(' ');\n\t      }\n\t\n\t      if (options.addClass && !isString(options.addClass)) {\n\t        options.addClass = null;\n\t      }\n\t\n\t      if (isArray(options.removeClass)) {\n\t        options.removeClass = options.removeClass.join(' ');\n\t      }\n\t\n\t      if (options.removeClass && !isString(options.removeClass)) {\n\t        options.removeClass = null;\n\t      }\n\t\n\t      if (options.from && !isObject(options.from)) {\n\t        options.from = null;\n\t      }\n\t\n\t      if (options.to && !isObject(options.to)) {\n\t        options.to = null;\n\t      }\n\t\n\t      // there are situations where a directive issues an animation for\n\t      // a jqLite wrapper that contains only comment nodes... If this\n\t      // happens then there is no way we can perform an animation\n\t      if (!node) {\n\t        close();\n\t        return runner;\n\t      }\n\t\n\t      var className = [node.className, options.addClass, options.removeClass].join(' ');\n\t      if (!isAnimatableClassName(className)) {\n\t        close();\n\t        return runner;\n\t      }\n\t\n\t      var isStructural = ['enter', 'move', 'leave'].indexOf(event) >= 0;\n\t\n\t      var documentHidden = $document[0].hidden;\n\t\n\t      // this is a hard disable of all animations for the application or on\n\t      // the element itself, therefore  there is no need to continue further\n\t      // past this point if not enabled\n\t      // Animations are also disabled if the document is currently hidden (page is not visible\n\t      // to the user), because browsers slow down or do not flush calls to requestAnimationFrame\n\t      var skipAnimations = !animationsEnabled || documentHidden || disabledElementsLookup.get(node);\n\t      var existingAnimation = (!skipAnimations && activeAnimationsLookup.get(node)) || {};\n\t      var hasExistingAnimation = !!existingAnimation.state;\n\t\n\t      // there is no point in traversing the same collection of parent ancestors if a followup\n\t      // animation will be run on the same element that already did all that checking work\n\t      if (!skipAnimations && (!hasExistingAnimation || existingAnimation.state != PRE_DIGEST_STATE)) {\n\t        skipAnimations = !areAnimationsAllowed(element, parent, event);\n\t      }\n\t\n\t      if (skipAnimations) {\n\t        // Callbacks should fire even if the document is hidden (regression fix for issue #14120)\n\t        if (documentHidden) notifyProgress(runner, event, 'start');\n\t        close();\n\t        if (documentHidden) notifyProgress(runner, event, 'close');\n\t        return runner;\n\t      }\n\t\n\t      if (isStructural) {\n\t        closeChildAnimations(element);\n\t      }\n\t\n\t      var newAnimation = {\n\t        structural: isStructural,\n\t        element: element,\n\t        event: event,\n\t        addClass: options.addClass,\n\t        removeClass: options.removeClass,\n\t        close: close,\n\t        options: options,\n\t        runner: runner\n\t      };\n\t\n\t      if (hasExistingAnimation) {\n\t        var skipAnimationFlag = isAllowed('skip', element, newAnimation, existingAnimation);\n\t        if (skipAnimationFlag) {\n\t          if (existingAnimation.state === RUNNING_STATE) {\n\t            close();\n\t            return runner;\n\t          } else {\n\t            mergeAnimationDetails(element, existingAnimation, newAnimation);\n\t            return existingAnimation.runner;\n\t          }\n\t        }\n\t        var cancelAnimationFlag = isAllowed('cancel', element, newAnimation, existingAnimation);\n\t        if (cancelAnimationFlag) {\n\t          if (existingAnimation.state === RUNNING_STATE) {\n\t            // this will end the animation right away and it is safe\n\t            // to do so since the animation is already running and the\n\t            // runner callback code will run in async\n\t            existingAnimation.runner.end();\n\t          } else if (existingAnimation.structural) {\n\t            // this means that the animation is queued into a digest, but\n\t            // hasn't started yet. Therefore it is safe to run the close\n\t            // method which will call the runner methods in async.\n\t            existingAnimation.close();\n\t          } else {\n\t            // this will merge the new animation options into existing animation options\n\t            mergeAnimationDetails(element, existingAnimation, newAnimation);\n\t\n\t            return existingAnimation.runner;\n\t          }\n\t        } else {\n\t          // a joined animation means that this animation will take over the existing one\n\t          // so an example would involve a leave animation taking over an enter. Then when\n\t          // the postDigest kicks in the enter will be ignored.\n\t          var joinAnimationFlag = isAllowed('join', element, newAnimation, existingAnimation);\n\t          if (joinAnimationFlag) {\n\t            if (existingAnimation.state === RUNNING_STATE) {\n\t              normalizeAnimationDetails(element, newAnimation);\n\t            } else {\n\t              applyGeneratedPreparationClasses(element, isStructural ? event : null, options);\n\t\n\t              event = newAnimation.event = existingAnimation.event;\n\t              options = mergeAnimationDetails(element, existingAnimation, newAnimation);\n\t\n\t              //we return the same runner since only the option values of this animation will\n\t              //be fed into the `existingAnimation`.\n\t              return existingAnimation.runner;\n\t            }\n\t          }\n\t        }\n\t      } else {\n\t        // normalization in this case means that it removes redundant CSS classes that\n\t        // already exist (addClass) or do not exist (removeClass) on the element\n\t        normalizeAnimationDetails(element, newAnimation);\n\t      }\n\t\n\t      // when the options are merged and cleaned up we may end up not having to do\n\t      // an animation at all, therefore we should check this before issuing a post\n\t      // digest callback. Structural animations will always run no matter what.\n\t      var isValidAnimation = newAnimation.structural;\n\t      if (!isValidAnimation) {\n\t        // animate (from/to) can be quickly checked first, otherwise we check if any classes are present\n\t        isValidAnimation = (newAnimation.event === 'animate' && Object.keys(newAnimation.options.to || {}).length > 0)\n\t                            || hasAnimationClasses(newAnimation);\n\t      }\n\t\n\t      if (!isValidAnimation) {\n\t        close();\n\t        clearElementAnimationState(element);\n\t        return runner;\n\t      }\n\t\n\t      // the counter keeps track of cancelled animations\n\t      var counter = (existingAnimation.counter || 0) + 1;\n\t      newAnimation.counter = counter;\n\t\n\t      markElementAnimationState(element, PRE_DIGEST_STATE, newAnimation);\n\t\n\t      $rootScope.$$postDigest(function() {\n\t        var animationDetails = activeAnimationsLookup.get(node);\n\t        var animationCancelled = !animationDetails;\n\t        animationDetails = animationDetails || {};\n\t\n\t        // if addClass/removeClass is called before something like enter then the\n\t        // registered parent element may not be present. The code below will ensure\n\t        // that a final value for parent element is obtained\n\t        var parentElement = element.parent() || [];\n\t\n\t        // animate/structural/class-based animations all have requirements. Otherwise there\n\t        // is no point in performing an animation. The parent node must also be set.\n\t        var isValidAnimation = parentElement.length > 0\n\t                                && (animationDetails.event === 'animate'\n\t                                    || animationDetails.structural\n\t                                    || hasAnimationClasses(animationDetails));\n\t\n\t        // this means that the previous animation was cancelled\n\t        // even if the follow-up animation is the same event\n\t        if (animationCancelled || animationDetails.counter !== counter || !isValidAnimation) {\n\t          // if another animation did not take over then we need\n\t          // to make sure that the domOperation and options are\n\t          // handled accordingly\n\t          if (animationCancelled) {\n\t            applyAnimationClasses(element, options);\n\t            applyAnimationStyles(element, options);\n\t          }\n\t\n\t          // if the event changed from something like enter to leave then we do\n\t          // it, otherwise if it's the same then the end result will be the same too\n\t          if (animationCancelled || (isStructural && animationDetails.event !== event)) {\n\t            options.domOperation();\n\t            runner.end();\n\t          }\n\t\n\t          // in the event that the element animation was not cancelled or a follow-up animation\n\t          // isn't allowed to animate from here then we need to clear the state of the element\n\t          // so that any future animations won't read the expired animation data.\n\t          if (!isValidAnimation) {\n\t            clearElementAnimationState(element);\n\t          }\n\t\n\t          return;\n\t        }\n\t\n\t        // this combined multiple class to addClass / removeClass into a setClass event\n\t        // so long as a structural event did not take over the animation\n\t        event = !animationDetails.structural && hasAnimationClasses(animationDetails, true)\n\t            ? 'setClass'\n\t            : animationDetails.event;\n\t\n\t        markElementAnimationState(element, RUNNING_STATE);\n\t        var realRunner = $$animation(element, event, animationDetails.options);\n\t\n\t        // this will update the runner's flow-control events based on\n\t        // the `realRunner` object.\n\t        runner.setHost(realRunner);\n\t        notifyProgress(runner, event, 'start', {});\n\t\n\t        realRunner.done(function(status) {\n\t          close(!status);\n\t          var animationDetails = activeAnimationsLookup.get(node);\n\t          if (animationDetails && animationDetails.counter === counter) {\n\t            clearElementAnimationState(getDomNode(element));\n\t          }\n\t          notifyProgress(runner, event, 'close', {});\n\t        });\n\t      });\n\t\n\t      return runner;\n\t\n\t      function notifyProgress(runner, event, phase, data) {\n\t        runInNextPostDigestOrNow(function() {\n\t          var callbacks = findCallbacks(parent, element, event);\n\t          if (callbacks.length) {\n\t            // do not optimize this call here to RAF because\n\t            // we don't know how heavy the callback code here will\n\t            // be and if this code is buffered then this can\n\t            // lead to a performance regression.\n\t            $$rAF(function() {\n\t              forEach(callbacks, function(callback) {\n\t                callback(element, phase, data);\n\t              });\n\t              cleanupEventListeners(phase, element);\n\t            });\n\t          } else {\n\t            cleanupEventListeners(phase, element);\n\t          }\n\t        });\n\t        runner.progress(event, phase, data);\n\t      }\n\t\n\t      function close(reject) { // jshint ignore:line\n\t        clearGeneratedClasses(element, options);\n\t        applyAnimationClasses(element, options);\n\t        applyAnimationStyles(element, options);\n\t        options.domOperation();\n\t        runner.complete(!reject);\n\t      }\n\t    }\n\t\n\t    function closeChildAnimations(element) {\n\t      var node = getDomNode(element);\n\t      var children = node.querySelectorAll('[' + NG_ANIMATE_ATTR_NAME + ']');\n\t      forEach(children, function(child) {\n\t        var state = parseInt(child.getAttribute(NG_ANIMATE_ATTR_NAME));\n\t        var animationDetails = activeAnimationsLookup.get(child);\n\t        if (animationDetails) {\n\t          switch (state) {\n\t            case RUNNING_STATE:\n\t              animationDetails.runner.end();\n\t              /* falls through */\n\t            case PRE_DIGEST_STATE:\n\t              activeAnimationsLookup.remove(child);\n\t              break;\n\t          }\n\t        }\n\t      });\n\t    }\n\t\n\t    function clearElementAnimationState(element) {\n\t      var node = getDomNode(element);\n\t      node.removeAttribute(NG_ANIMATE_ATTR_NAME);\n\t      activeAnimationsLookup.remove(node);\n\t    }\n\t\n\t    function isMatchingElement(nodeOrElmA, nodeOrElmB) {\n\t      return getDomNode(nodeOrElmA) === getDomNode(nodeOrElmB);\n\t    }\n\t\n\t    /**\n\t     * This fn returns false if any of the following is true:\n\t     * a) animations on any parent element are disabled, and animations on the element aren't explicitly allowed\n\t     * b) a parent element has an ongoing structural animation, and animateChildren is false\n\t     * c) the element is not a child of the body\n\t     * d) the element is not a child of the $rootElement\n\t     */\n\t    function areAnimationsAllowed(element, parentElement, event) {\n\t      var bodyElement = jqLite($document[0].body);\n\t      var bodyElementDetected = isMatchingElement(element, bodyElement) || element[0].nodeName === 'HTML';\n\t      var rootElementDetected = isMatchingElement(element, $rootElement);\n\t      var parentAnimationDetected = false;\n\t      var animateChildren;\n\t      var elementDisabled = disabledElementsLookup.get(getDomNode(element));\n\t\n\t      var parentHost = jqLite.data(element[0], NG_ANIMATE_PIN_DATA);\n\t      if (parentHost) {\n\t        parentElement = parentHost;\n\t      }\n\t\n\t      parentElement = getDomNode(parentElement);\n\t\n\t      while (parentElement) {\n\t        if (!rootElementDetected) {\n\t          // angular doesn't want to attempt to animate elements outside of the application\n\t          // therefore we need to ensure that the rootElement is an ancestor of the current element\n\t          rootElementDetected = isMatchingElement(parentElement, $rootElement);\n\t        }\n\t\n\t        if (parentElement.nodeType !== ELEMENT_NODE) {\n\t          // no point in inspecting the #document element\n\t          break;\n\t        }\n\t\n\t        var details = activeAnimationsLookup.get(parentElement) || {};\n\t        // either an enter, leave or move animation will commence\n\t        // therefore we can't allow any animations to take place\n\t        // but if a parent animation is class-based then that's ok\n\t        if (!parentAnimationDetected) {\n\t          var parentElementDisabled = disabledElementsLookup.get(parentElement);\n\t\n\t          if (parentElementDisabled === true && elementDisabled !== false) {\n\t            // disable animations if the user hasn't explicitly enabled animations on the\n\t            // current element\n\t            elementDisabled = true;\n\t            // element is disabled via parent element, no need to check anything else\n\t            break;\n\t          } else if (parentElementDisabled === false) {\n\t            elementDisabled = false;\n\t          }\n\t          parentAnimationDetected = details.structural;\n\t        }\n\t\n\t        if (isUndefined(animateChildren) || animateChildren === true) {\n\t          var value = jqLite.data(parentElement, NG_ANIMATE_CHILDREN_DATA);\n\t          if (isDefined(value)) {\n\t            animateChildren = value;\n\t          }\n\t        }\n\t\n\t        // there is no need to continue traversing at this point\n\t        if (parentAnimationDetected && animateChildren === false) break;\n\t\n\t        if (!bodyElementDetected) {\n\t          // we also need to ensure that the element is or will be a part of the body element\n\t          // otherwise it is pointless to even issue an animation to be rendered\n\t          bodyElementDetected = isMatchingElement(parentElement, bodyElement);\n\t        }\n\t\n\t        if (bodyElementDetected && rootElementDetected) {\n\t          // If both body and root have been found, any other checks are pointless,\n\t          // as no animation data should live outside the application\n\t          break;\n\t        }\n\t\n\t        if (!rootElementDetected) {\n\t          // If no rootElement is detected, check if the parentElement is pinned to another element\n\t          parentHost = jqLite.data(parentElement, NG_ANIMATE_PIN_DATA);\n\t          if (parentHost) {\n\t            // The pin target element becomes the next parent element\n\t            parentElement = getDomNode(parentHost);\n\t            continue;\n\t          }\n\t        }\n\t\n\t        parentElement = parentElement.parentNode;\n\t      }\n\t\n\t      var allowAnimation = (!parentAnimationDetected || animateChildren) && elementDisabled !== true;\n\t      return allowAnimation && rootElementDetected && bodyElementDetected;\n\t    }\n\t\n\t    function markElementAnimationState(element, state, details) {\n\t      details = details || {};\n\t      details.state = state;\n\t\n\t      var node = getDomNode(element);\n\t      node.setAttribute(NG_ANIMATE_ATTR_NAME, state);\n\t\n\t      var oldValue = activeAnimationsLookup.get(node);\n\t      var newValue = oldValue\n\t          ? extend(oldValue, details)\n\t          : details;\n\t      activeAnimationsLookup.put(node, newValue);\n\t    }\n\t  }];\n\t}];\n\t\n\tvar $$AnimationProvider = ['$animateProvider', function($animateProvider) {\n\t  var NG_ANIMATE_REF_ATTR = 'ng-animate-ref';\n\t\n\t  var drivers = this.drivers = [];\n\t\n\t  var RUNNER_STORAGE_KEY = '$$animationRunner';\n\t\n\t  function setRunner(element, runner) {\n\t    element.data(RUNNER_STORAGE_KEY, runner);\n\t  }\n\t\n\t  function removeRunner(element) {\n\t    element.removeData(RUNNER_STORAGE_KEY);\n\t  }\n\t\n\t  function getRunner(element) {\n\t    return element.data(RUNNER_STORAGE_KEY);\n\t  }\n\t\n\t  this.$get = ['$$jqLite', '$rootScope', '$injector', '$$AnimateRunner', '$$HashMap', '$$rAFScheduler',\n\t       function($$jqLite,   $rootScope,   $injector,   $$AnimateRunner,   $$HashMap,   $$rAFScheduler) {\n\t\n\t    var animationQueue = [];\n\t    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);\n\t\n\t    function sortAnimations(animations) {\n\t      var tree = { children: [] };\n\t      var i, lookup = new $$HashMap();\n\t\n\t      // this is done first beforehand so that the hashmap\n\t      // is filled with a list of the elements that will be animated\n\t      for (i = 0; i < animations.length; i++) {\n\t        var animation = animations[i];\n\t        lookup.put(animation.domNode, animations[i] = {\n\t          domNode: animation.domNode,\n\t          fn: animation.fn,\n\t          children: []\n\t        });\n\t      }\n\t\n\t      for (i = 0; i < animations.length; i++) {\n\t        processNode(animations[i]);\n\t      }\n\t\n\t      return flatten(tree);\n\t\n\t      function processNode(entry) {\n\t        if (entry.processed) return entry;\n\t        entry.processed = true;\n\t\n\t        var elementNode = entry.domNode;\n\t        var parentNode = elementNode.parentNode;\n\t        lookup.put(elementNode, entry);\n\t\n\t        var parentEntry;\n\t        while (parentNode) {\n\t          parentEntry = lookup.get(parentNode);\n\t          if (parentEntry) {\n\t            if (!parentEntry.processed) {\n\t              parentEntry = processNode(parentEntry);\n\t            }\n\t            break;\n\t          }\n\t          parentNode = parentNode.parentNode;\n\t        }\n\t\n\t        (parentEntry || tree).children.push(entry);\n\t        return entry;\n\t      }\n\t\n\t      function flatten(tree) {\n\t        var result = [];\n\t        var queue = [];\n\t        var i;\n\t\n\t        for (i = 0; i < tree.children.length; i++) {\n\t          queue.push(tree.children[i]);\n\t        }\n\t\n\t        var remainingLevelEntries = queue.length;\n\t        var nextLevelEntries = 0;\n\t        var row = [];\n\t\n\t        for (i = 0; i < queue.length; i++) {\n\t          var entry = queue[i];\n\t          if (remainingLevelEntries <= 0) {\n\t            remainingLevelEntries = nextLevelEntries;\n\t            nextLevelEntries = 0;\n\t            result.push(row);\n\t            row = [];\n\t          }\n\t          row.push(entry.fn);\n\t          entry.children.forEach(function(childEntry) {\n\t            nextLevelEntries++;\n\t            queue.push(childEntry);\n\t          });\n\t          remainingLevelEntries--;\n\t        }\n\t\n\t        if (row.length) {\n\t          result.push(row);\n\t        }\n\t\n\t        return result;\n\t      }\n\t    }\n\t\n\t    // TODO(matsko): document the signature in a better way\n\t    return function(element, event, options) {\n\t      options = prepareAnimationOptions(options);\n\t      var isStructural = ['enter', 'move', 'leave'].indexOf(event) >= 0;\n\t\n\t      // there is no animation at the current moment, however\n\t      // these runner methods will get later updated with the\n\t      // methods leading into the driver's end/cancel methods\n\t      // for now they just stop the animation from starting\n\t      var runner = new $$AnimateRunner({\n\t        end: function() { close(); },\n\t        cancel: function() { close(true); }\n\t      });\n\t\n\t      if (!drivers.length) {\n\t        close();\n\t        return runner;\n\t      }\n\t\n\t      setRunner(element, runner);\n\t\n\t      var classes = mergeClasses(element.attr('class'), mergeClasses(options.addClass, options.removeClass));\n\t      var tempClasses = options.tempClasses;\n\t      if (tempClasses) {\n\t        classes += ' ' + tempClasses;\n\t        options.tempClasses = null;\n\t      }\n\t\n\t      var prepareClassName;\n\t      if (isStructural) {\n\t        prepareClassName = 'ng-' + event + PREPARE_CLASS_SUFFIX;\n\t        $$jqLite.addClass(element, prepareClassName);\n\t      }\n\t\n\t      animationQueue.push({\n\t        // this data is used by the postDigest code and passed into\n\t        // the driver step function\n\t        element: element,\n\t        classes: classes,\n\t        event: event,\n\t        structural: isStructural,\n\t        options: options,\n\t        beforeStart: beforeStart,\n\t        close: close\n\t      });\n\t\n\t      element.on('$destroy', handleDestroyedElement);\n\t\n\t      // we only want there to be one function called within the post digest\n\t      // block. This way we can group animations for all the animations that\n\t      // were apart of the same postDigest flush call.\n\t      if (animationQueue.length > 1) return runner;\n\t\n\t      $rootScope.$$postDigest(function() {\n\t        var animations = [];\n\t        forEach(animationQueue, function(entry) {\n\t          // the element was destroyed early on which removed the runner\n\t          // form its storage. This means we can't animate this element\n\t          // at all and it already has been closed due to destruction.\n\t          if (getRunner(entry.element)) {\n\t            animations.push(entry);\n\t          } else {\n\t            entry.close();\n\t          }\n\t        });\n\t\n\t        // now any future animations will be in another postDigest\n\t        animationQueue.length = 0;\n\t\n\t        var groupedAnimations = groupAnimations(animations);\n\t        var toBeSortedAnimations = [];\n\t\n\t        forEach(groupedAnimations, function(animationEntry) {\n\t          toBeSortedAnimations.push({\n\t            domNode: getDomNode(animationEntry.from ? animationEntry.from.element : animationEntry.element),\n\t            fn: function triggerAnimationStart() {\n\t              // it's important that we apply the `ng-animate` CSS class and the\n\t              // temporary classes before we do any driver invoking since these\n\t              // CSS classes may be required for proper CSS detection.\n\t              animationEntry.beforeStart();\n\t\n\t              var startAnimationFn, closeFn = animationEntry.close;\n\t\n\t              // in the event that the element was removed before the digest runs or\n\t              // during the RAF sequencing then we should not trigger the animation.\n\t              var targetElement = animationEntry.anchors\n\t                  ? (animationEntry.from.element || animationEntry.to.element)\n\t                  : animationEntry.element;\n\t\n\t              if (getRunner(targetElement)) {\n\t                var operation = invokeFirstDriver(animationEntry);\n\t                if (operation) {\n\t                  startAnimationFn = operation.start;\n\t                }\n\t              }\n\t\n\t              if (!startAnimationFn) {\n\t                closeFn();\n\t              } else {\n\t                var animationRunner = startAnimationFn();\n\t                animationRunner.done(function(status) {\n\t                  closeFn(!status);\n\t                });\n\t                updateAnimationRunners(animationEntry, animationRunner);\n\t              }\n\t            }\n\t          });\n\t        });\n\t\n\t        // we need to sort each of the animations in order of parent to child\n\t        // relationships. This ensures that the child classes are applied at the\n\t        // right time.\n\t        $$rAFScheduler(sortAnimations(toBeSortedAnimations));\n\t      });\n\t\n\t      return runner;\n\t\n\t      // TODO(matsko): change to reference nodes\n\t      function getAnchorNodes(node) {\n\t        var SELECTOR = '[' + NG_ANIMATE_REF_ATTR + ']';\n\t        var items = node.hasAttribute(NG_ANIMATE_REF_ATTR)\n\t              ? [node]\n\t              : node.querySelectorAll(SELECTOR);\n\t        var anchors = [];\n\t        forEach(items, function(node) {\n\t          var attr = node.getAttribute(NG_ANIMATE_REF_ATTR);\n\t          if (attr && attr.length) {\n\t            anchors.push(node);\n\t          }\n\t        });\n\t        return anchors;\n\t      }\n\t\n\t      function groupAnimations(animations) {\n\t        var preparedAnimations = [];\n\t        var refLookup = {};\n\t        forEach(animations, function(animation, index) {\n\t          var element = animation.element;\n\t          var node = getDomNode(element);\n\t          var event = animation.event;\n\t          var enterOrMove = ['enter', 'move'].indexOf(event) >= 0;\n\t          var anchorNodes = animation.structural ? getAnchorNodes(node) : [];\n\t\n\t          if (anchorNodes.length) {\n\t            var direction = enterOrMove ? 'to' : 'from';\n\t\n\t            forEach(anchorNodes, function(anchor) {\n\t              var key = anchor.getAttribute(NG_ANIMATE_REF_ATTR);\n\t              refLookup[key] = refLookup[key] || {};\n\t              refLookup[key][direction] = {\n\t                animationID: index,\n\t                element: jqLite(anchor)\n\t              };\n\t            });\n\t          } else {\n\t            preparedAnimations.push(animation);\n\t          }\n\t        });\n\t\n\t        var usedIndicesLookup = {};\n\t        var anchorGroups = {};\n\t        forEach(refLookup, function(operations, key) {\n\t          var from = operations.from;\n\t          var to = operations.to;\n\t\n\t          if (!from || !to) {\n\t            // only one of these is set therefore we can't have an\n\t            // anchor animation since all three pieces are required\n\t            var index = from ? from.animationID : to.animationID;\n\t            var indexKey = index.toString();\n\t            if (!usedIndicesLookup[indexKey]) {\n\t              usedIndicesLookup[indexKey] = true;\n\t              preparedAnimations.push(animations[index]);\n\t            }\n\t            return;\n\t          }\n\t\n\t          var fromAnimation = animations[from.animationID];\n\t          var toAnimation = animations[to.animationID];\n\t          var lookupKey = from.animationID.toString();\n\t          if (!anchorGroups[lookupKey]) {\n\t            var group = anchorGroups[lookupKey] = {\n\t              structural: true,\n\t              beforeStart: function() {\n\t                fromAnimation.beforeStart();\n\t                toAnimation.beforeStart();\n\t              },\n\t              close: function() {\n\t                fromAnimation.close();\n\t                toAnimation.close();\n\t              },\n\t              classes: cssClassesIntersection(fromAnimation.classes, toAnimation.classes),\n\t              from: fromAnimation,\n\t              to: toAnimation,\n\t              anchors: [] // TODO(matsko): change to reference nodes\n\t            };\n\t\n\t            // the anchor animations require that the from and to elements both have at least\n\t            // one shared CSS class which effectively marries the two elements together to use\n\t            // the same animation driver and to properly sequence the anchor animation.\n\t            if (group.classes.length) {\n\t              preparedAnimations.push(group);\n\t            } else {\n\t              preparedAnimations.push(fromAnimation);\n\t              preparedAnimations.push(toAnimation);\n\t            }\n\t          }\n\t\n\t          anchorGroups[lookupKey].anchors.push({\n\t            'out': from.element, 'in': to.element\n\t          });\n\t        });\n\t\n\t        return preparedAnimations;\n\t      }\n\t\n\t      function cssClassesIntersection(a,b) {\n\t        a = a.split(' ');\n\t        b = b.split(' ');\n\t        var matches = [];\n\t\n\t        for (var i = 0; i < a.length; i++) {\n\t          var aa = a[i];\n\t          if (aa.substring(0,3) === 'ng-') continue;\n\t\n\t          for (var j = 0; j < b.length; j++) {\n\t            if (aa === b[j]) {\n\t              matches.push(aa);\n\t              break;\n\t            }\n\t          }\n\t        }\n\t\n\t        return matches.join(' ');\n\t      }\n\t\n\t      function invokeFirstDriver(animationDetails) {\n\t        // we loop in reverse order since the more general drivers (like CSS and JS)\n\t        // may attempt more elements, but custom drivers are more particular\n\t        for (var i = drivers.length - 1; i >= 0; i--) {\n\t          var driverName = drivers[i];\n\t          var factory = $injector.get(driverName);\n\t          var driver = factory(animationDetails);\n\t          if (driver) {\n\t            return driver;\n\t          }\n\t        }\n\t      }\n\t\n\t      function beforeStart() {\n\t        element.addClass(NG_ANIMATE_CLASSNAME);\n\t        if (tempClasses) {\n\t          $$jqLite.addClass(element, tempClasses);\n\t        }\n\t        if (prepareClassName) {\n\t          $$jqLite.removeClass(element, prepareClassName);\n\t          prepareClassName = null;\n\t        }\n\t      }\n\t\n\t      function updateAnimationRunners(animation, newRunner) {\n\t        if (animation.from && animation.to) {\n\t          update(animation.from.element);\n\t          update(animation.to.element);\n\t        } else {\n\t          update(animation.element);\n\t        }\n\t\n\t        function update(element) {\n\t          var runner = getRunner(element);\n\t          if (runner) runner.setHost(newRunner);\n\t        }\n\t      }\n\t\n\t      function handleDestroyedElement() {\n\t        var runner = getRunner(element);\n\t        if (runner && (event !== 'leave' || !options.$$domOperationFired)) {\n\t          runner.end();\n\t        }\n\t      }\n\t\n\t      function close(rejected) { // jshint ignore:line\n\t        element.off('$destroy', handleDestroyedElement);\n\t        removeRunner(element);\n\t\n\t        applyAnimationClasses(element, options);\n\t        applyAnimationStyles(element, options);\n\t        options.domOperation();\n\t\n\t        if (tempClasses) {\n\t          $$jqLite.removeClass(element, tempClasses);\n\t        }\n\t\n\t        element.removeClass(NG_ANIMATE_CLASSNAME);\n\t        runner.complete(!rejected);\n\t      }\n\t    };\n\t  }];\n\t}];\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name ngAnimateSwap\n\t * @restrict A\n\t * @scope\n\t *\n\t * @description\n\t *\n\t * ngAnimateSwap is a animation-oriented directive that allows for the container to\n\t * be removed and entered in whenever the associated expression changes. A\n\t * common usecase for this directive is a rotating banner or slider component which\n\t * contains one image being present at a time. When the active image changes\n\t * then the old image will perform a `leave` animation and the new element\n\t * will be inserted via an `enter` animation.\n\t *\n\t * @animations\n\t * | Animation                        | Occurs                               |\n\t * |----------------------------------|--------------------------------------|\n\t * | {@link ng.$animate#enter enter}  | when the new element is inserted to the DOM  |\n\t * | {@link ng.$animate#leave leave}  | when the old element is removed from the DOM |\n\t *\n\t * @example\n\t * <example name=\"ngAnimateSwap-directive\" module=\"ngAnimateSwapExample\"\n\t *          deps=\"angular-animate.js\"\n\t *          animations=\"true\" fixBase=\"true\">\n\t *   <file name=\"index.html\">\n\t *     <div class=\"container\" ng-controller=\"AppCtrl\">\n\t *       <div ng-animate-swap=\"number\" class=\"cell swap-animation\" ng-class=\"colorClass(number)\">\n\t *         {{ number }}\n\t *       </div>\n\t *     </div>\n\t *   </file>\n\t *   <file name=\"script.js\">\n\t *     angular.module('ngAnimateSwapExample', ['ngAnimate'])\n\t *       .controller('AppCtrl', ['$scope', '$interval', function($scope, $interval) {\n\t *         $scope.number = 0;\n\t *         $interval(function() {\n\t *           $scope.number++;\n\t *         }, 1000);\n\t *\n\t *         var colors = ['red','blue','green','yellow','orange'];\n\t *         $scope.colorClass = function(number) {\n\t *           return colors[number % colors.length];\n\t *         };\n\t *       }]);\n\t *   </file>\n\t *  <file name=\"animations.css\">\n\t *  .container {\n\t *    height:250px;\n\t *    width:250px;\n\t *    position:relative;\n\t *    overflow:hidden;\n\t *    border:2px solid black;\n\t *  }\n\t *  .container .cell {\n\t *    font-size:150px;\n\t *    text-align:center;\n\t *    line-height:250px;\n\t *    position:absolute;\n\t *    top:0;\n\t *    left:0;\n\t *    right:0;\n\t *    border-bottom:2px solid black;\n\t *  }\n\t *  .swap-animation.ng-enter, .swap-animation.ng-leave {\n\t *    transition:0.5s linear all;\n\t *  }\n\t *  .swap-animation.ng-enter {\n\t *    top:-250px;\n\t *  }\n\t *  .swap-animation.ng-enter-active {\n\t *    top:0px;\n\t *  }\n\t *  .swap-animation.ng-leave {\n\t *    top:0px;\n\t *  }\n\t *  .swap-animation.ng-leave-active {\n\t *    top:250px;\n\t *  }\n\t *  .red { background:red; }\n\t *  .green { background:green; }\n\t *  .blue { background:blue; }\n\t *  .yellow { background:yellow; }\n\t *  .orange { background:orange; }\n\t *  </file>\n\t * </example>\n\t */\n\tvar ngAnimateSwapDirective = ['$animate', '$rootScope', function($animate, $rootScope) {\n\t  return {\n\t    restrict: 'A',\n\t    transclude: 'element',\n\t    terminal: true,\n\t    priority: 600, // we use 600 here to ensure that the directive is caught before others\n\t    link: function(scope, $element, attrs, ctrl, $transclude) {\n\t      var previousElement, previousScope;\n\t      scope.$watchCollection(attrs.ngAnimateSwap || attrs['for'], function(value) {\n\t        if (previousElement) {\n\t          $animate.leave(previousElement);\n\t        }\n\t        if (previousScope) {\n\t          previousScope.$destroy();\n\t          previousScope = null;\n\t        }\n\t        if (value || value === 0) {\n\t          previousScope = scope.$new();\n\t          $transclude(previousScope, function(element) {\n\t            previousElement = element;\n\t            $animate.enter(element, null, $element);\n\t          });\n\t        }\n\t      });\n\t    }\n\t  };\n\t}];\n\t\n\t/**\n\t * @ngdoc module\n\t * @name ngAnimate\n\t * @description\n\t *\n\t * The `ngAnimate` module provides support for CSS-based animations (keyframes and transitions) as well as JavaScript-based animations via\n\t * callback hooks. Animations are not enabled by default, however, by including `ngAnimate` the animation hooks are enabled for an Angular app.\n\t *\n\t * <div doc-module-components=\"ngAnimate\"></div>\n\t *\n\t * # Usage\n\t * Simply put, there are two ways to make use of animations when ngAnimate is used: by using **CSS** and **JavaScript**. The former works purely based\n\t * using CSS (by using matching CSS selectors/styles) and the latter triggers animations that are registered via `module.animation()`. For\n\t * both CSS and JS animations the sole requirement is to have a matching `CSS class` that exists both in the registered animation and within\n\t * the HTML element that the animation will be triggered on.\n\t *\n\t * ## Directive Support\n\t * The following directives are \"animation aware\":\n\t *\n\t * | Directive                                                                                                | Supported Animations                                                     |\n\t * |----------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------|\n\t * | {@link ng.directive:ngRepeat#animations ngRepeat}                                                        | enter, leave and move                                                    |\n\t * | {@link ngRoute.directive:ngView#animations ngView}                                                       | enter and leave                                                          |\n\t * | {@link ng.directive:ngInclude#animations ngInclude}                                                      | enter and leave                                                          |\n\t * | {@link ng.directive:ngSwitch#animations ngSwitch}                                                        | enter and leave                                                          |\n\t * | {@link ng.directive:ngIf#animations ngIf}                                                                | enter and leave                                                          |\n\t * | {@link ng.directive:ngClass#animations ngClass}                                                          | add and remove (the CSS class(es) present)                               |\n\t * | {@link ng.directive:ngShow#animations ngShow} & {@link ng.directive:ngHide#animations ngHide}            | add and remove (the ng-hide class value)                                 |\n\t * | {@link ng.directive:form#animation-hooks form} & {@link ng.directive:ngModel#animation-hooks ngModel}    | add and remove (dirty, pristine, valid, invalid & all other validations) |\n\t * | {@link module:ngMessages#animations ngMessages}                                                          | add and remove (ng-active & ng-inactive)                                 |\n\t * | {@link module:ngMessages#animations ngMessage}                                                           | enter and leave                                                          |\n\t *\n\t * (More information can be found by visiting each the documentation associated with each directive.)\n\t *\n\t * ## CSS-based Animations\n\t *\n\t * CSS-based animations with ngAnimate are unique since they require no JavaScript code at all. By using a CSS class that we reference between our HTML\n\t * and CSS code we can create an animation that will be picked up by Angular when an the underlying directive performs an operation.\n\t *\n\t * The example below shows how an `enter` animation can be made possible on an element using `ng-if`:\n\t *\n\t * ```html\n\t * <div ng-if=\"bool\" class=\"fade\">\n\t *    Fade me in out\n\t * </div>\n\t * <button ng-click=\"bool=true\">Fade In!</button>\n\t * <button ng-click=\"bool=false\">Fade Out!</button>\n\t * ```\n\t *\n\t * Notice the CSS class **fade**? We can now create the CSS transition code that references this class:\n\t *\n\t * ```css\n\t * /&#42; The starting CSS styles for the enter animation &#42;/\n\t * .fade.ng-enter {\n\t *   transition:0.5s linear all;\n\t *   opacity:0;\n\t * }\n\t *\n\t * /&#42; The finishing CSS styles for the enter animation &#42;/\n\t * .fade.ng-enter.ng-enter-active {\n\t *   opacity:1;\n\t * }\n\t * ```\n\t *\n\t * The key thing to remember here is that, depending on the animation event (which each of the directives above trigger depending on what's going on) two\n\t * generated CSS classes will be applied to the element; in the example above we have `.ng-enter` and `.ng-enter-active`. For CSS transitions, the transition\n\t * code **must** be defined within the starting CSS class (in this case `.ng-enter`). The destination class is what the transition will animate towards.\n\t *\n\t * If for example we wanted to create animations for `leave` and `move` (ngRepeat triggers move) then we can do so using the same CSS naming conventions:\n\t *\n\t * ```css\n\t * /&#42; now the element will fade out before it is removed from the DOM &#42;/\n\t * .fade.ng-leave {\n\t *   transition:0.5s linear all;\n\t *   opacity:1;\n\t * }\n\t * .fade.ng-leave.ng-leave-active {\n\t *   opacity:0;\n\t * }\n\t * ```\n\t *\n\t * We can also make use of **CSS Keyframes** by referencing the keyframe animation within the starting CSS class:\n\t *\n\t * ```css\n\t * /&#42; there is no need to define anything inside of the destination\n\t * CSS class since the keyframe will take charge of the animation &#42;/\n\t * .fade.ng-leave {\n\t *   animation: my_fade_animation 0.5s linear;\n\t *   -webkit-animation: my_fade_animation 0.5s linear;\n\t * }\n\t *\n\t * @keyframes my_fade_animation {\n\t *   from { opacity:1; }\n\t *   to { opacity:0; }\n\t * }\n\t *\n\t * @-webkit-keyframes my_fade_animation {\n\t *   from { opacity:1; }\n\t *   to { opacity:0; }\n\t * }\n\t * ```\n\t *\n\t * Feel free also mix transitions and keyframes together as well as any other CSS classes on the same element.\n\t *\n\t * ### CSS Class-based Animations\n\t *\n\t * Class-based animations (animations that are triggered via `ngClass`, `ngShow`, `ngHide` and some other directives) have a slightly different\n\t * naming convention. Class-based animations are basic enough that a standard transition or keyframe can be referenced on the class being added\n\t * and removed.\n\t *\n\t * For example if we wanted to do a CSS animation for `ngHide` then we place an animation on the `.ng-hide` CSS class:\n\t *\n\t * ```html\n\t * <div ng-show=\"bool\" class=\"fade\">\n\t *   Show and hide me\n\t * </div>\n\t * <button ng-click=\"bool=!bool\">Toggle</button>\n\t *\n\t * <style>\n\t * .fade.ng-hide {\n\t *   transition:0.5s linear all;\n\t *   opacity:0;\n\t * }\n\t * </style>\n\t * ```\n\t *\n\t * All that is going on here with ngShow/ngHide behind the scenes is the `.ng-hide` class is added/removed (when the hidden state is valid). Since\n\t * ngShow and ngHide are animation aware then we can match up a transition and ngAnimate handles the rest.\n\t *\n\t * In addition the addition and removal of the CSS class, ngAnimate also provides two helper methods that we can use to further decorate the animation\n\t * with CSS styles.\n\t *\n\t * ```html\n\t * <div ng-class=\"{on:onOff}\" class=\"highlight\">\n\t *   Highlight this box\n\t * </div>\n\t * <button ng-click=\"onOff=!onOff\">Toggle</button>\n\t *\n\t * <style>\n\t * .highlight {\n\t *   transition:0.5s linear all;\n\t * }\n\t * .highlight.on-add {\n\t *   background:white;\n\t * }\n\t * .highlight.on {\n\t *   background:yellow;\n\t * }\n\t * .highlight.on-remove {\n\t *   background:black;\n\t * }\n\t * </style>\n\t * ```\n\t *\n\t * We can also make use of CSS keyframes by placing them within the CSS classes.\n\t *\n\t *\n\t * ### CSS Staggering Animations\n\t * A Staggering animation is a collection of animations that are issued with a slight delay in between each successive operation resulting in a\n\t * curtain-like effect. The ngAnimate module (versions >=1.2) supports staggering animations and the stagger effect can be\n\t * performed by creating a **ng-EVENT-stagger** CSS class and attaching that class to the base CSS class used for\n\t * the animation. The style property expected within the stagger class can either be a **transition-delay** or an\n\t * **animation-delay** property (or both if your animation contains both transitions and keyframe animations).\n\t *\n\t * ```css\n\t * .my-animation.ng-enter {\n\t *   /&#42; standard transition code &#42;/\n\t *   transition: 1s linear all;\n\t *   opacity:0;\n\t * }\n\t * .my-animation.ng-enter-stagger {\n\t *   /&#42; this will have a 100ms delay between each successive leave animation &#42;/\n\t *   transition-delay: 0.1s;\n\t *\n\t *   /&#42; As of 1.4.4, this must always be set: it signals ngAnimate\n\t *     to not accidentally inherit a delay property from another CSS class &#42;/\n\t *   transition-duration: 0s;\n\t * }\n\t * .my-animation.ng-enter.ng-enter-active {\n\t *   /&#42; standard transition styles &#42;/\n\t *   opacity:1;\n\t * }\n\t * ```\n\t *\n\t * Staggering animations work by default in ngRepeat (so long as the CSS class is defined). Outside of ngRepeat, to use staggering animations\n\t * on your own, they can be triggered by firing multiple calls to the same event on $animate. However, the restrictions surrounding this\n\t * are that each of the elements must have the same CSS className value as well as the same parent element. A stagger operation\n\t * will also be reset if one or more animation frames have passed since the multiple calls to `$animate` were fired.\n\t *\n\t * The following code will issue the **ng-leave-stagger** event on the element provided:\n\t *\n\t * ```js\n\t * var kids = parent.children();\n\t *\n\t * $animate.leave(kids[0]); //stagger index=0\n\t * $animate.leave(kids[1]); //stagger index=1\n\t * $animate.leave(kids[2]); //stagger index=2\n\t * $animate.leave(kids[3]); //stagger index=3\n\t * $animate.leave(kids[4]); //stagger index=4\n\t *\n\t * window.requestAnimationFrame(function() {\n\t *   //stagger has reset itself\n\t *   $animate.leave(kids[5]); //stagger index=0\n\t *   $animate.leave(kids[6]); //stagger index=1\n\t *\n\t *   $scope.$digest();\n\t * });\n\t * ```\n\t *\n\t * Stagger animations are currently only supported within CSS-defined animations.\n\t *\n\t * ### The `ng-animate` CSS class\n\t *\n\t * When ngAnimate is animating an element it will apply the `ng-animate` CSS class to the element for the duration of the animation.\n\t * This is a temporary CSS class and it will be removed once the animation is over (for both JavaScript and CSS-based animations).\n\t *\n\t * Therefore, animations can be applied to an element using this temporary class directly via CSS.\n\t *\n\t * ```css\n\t * .zipper.ng-animate {\n\t *   transition:0.5s linear all;\n\t * }\n\t * .zipper.ng-enter {\n\t *   opacity:0;\n\t * }\n\t * .zipper.ng-enter.ng-enter-active {\n\t *   opacity:1;\n\t * }\n\t * .zipper.ng-leave {\n\t *   opacity:1;\n\t * }\n\t * .zipper.ng-leave.ng-leave-active {\n\t *   opacity:0;\n\t * }\n\t * ```\n\t *\n\t * (Note that the `ng-animate` CSS class is reserved and it cannot be applied on an element directly since ngAnimate will always remove\n\t * the CSS class once an animation has completed.)\n\t *\n\t *\n\t * ### The `ng-[event]-prepare` class\n\t *\n\t * This is a special class that can be used to prevent unwanted flickering / flash of content before\n\t * the actual animation starts. The class is added as soon as an animation is initialized, but removed\n\t * before the actual animation starts (after waiting for a $digest).\n\t * It is also only added for *structural* animations (`enter`, `move`, and `leave`).\n\t *\n\t * In practice, flickering can appear when nesting elements with structural animations such as `ngIf`\n\t * into elements that have class-based animations such as `ngClass`.\n\t *\n\t * ```html\n\t * <div ng-class=\"{red: myProp}\">\n\t *   <div ng-class=\"{blue: myProp}\">\n\t *     <div class=\"message\" ng-if=\"myProp\"></div>\n\t *   </div>\n\t * </div>\n\t * ```\n\t *\n\t * It is possible that during the `enter` animation, the `.message` div will be briefly visible before it starts animating.\n\t * In that case, you can add styles to the CSS that make sure the element stays hidden before the animation starts:\n\t *\n\t * ```css\n\t * .message.ng-enter-prepare {\n\t *   opacity: 0;\n\t * }\n\t *\n\t * ```\n\t *\n\t * ## JavaScript-based Animations\n\t *\n\t * ngAnimate also allows for animations to be consumed by JavaScript code. The approach is similar to CSS-based animations (where there is a shared\n\t * CSS class that is referenced in our HTML code) but in addition we need to register the JavaScript animation on the module. By making use of the\n\t * `module.animation()` module function we can register the animation.\n\t *\n\t * Let's see an example of a enter/leave animation using `ngRepeat`:\n\t *\n\t * ```html\n\t * <div ng-repeat=\"item in items\" class=\"slide\">\n\t *   {{ item }}\n\t * </div>\n\t * ```\n\t *\n\t * See the **slide** CSS class? Let's use that class to define an animation that we'll structure in our module code by using `module.animation`:\n\t *\n\t * ```js\n\t * myModule.animation('.slide', [function() {\n\t *   return {\n\t *     // make note that other events (like addClass/removeClass)\n\t *     // have different function input parameters\n\t *     enter: function(element, doneFn) {\n\t *       jQuery(element).fadeIn(1000, doneFn);\n\t *\n\t *       // remember to call doneFn so that angular\n\t *       // knows that the animation has concluded\n\t *     },\n\t *\n\t *     move: function(element, doneFn) {\n\t *       jQuery(element).fadeIn(1000, doneFn);\n\t *     },\n\t *\n\t *     leave: function(element, doneFn) {\n\t *       jQuery(element).fadeOut(1000, doneFn);\n\t *     }\n\t *   }\n\t * }]);\n\t * ```\n\t *\n\t * The nice thing about JS-based animations is that we can inject other services and make use of advanced animation libraries such as\n\t * greensock.js and velocity.js.\n\t *\n\t * If our animation code class-based (meaning that something like `ngClass`, `ngHide` and `ngShow` triggers it) then we can still define\n\t * our animations inside of the same registered animation, however, the function input arguments are a bit different:\n\t *\n\t * ```html\n\t * <div ng-class=\"color\" class=\"colorful\">\n\t *   this box is moody\n\t * </div>\n\t * <button ng-click=\"color='red'\">Change to red</button>\n\t * <button ng-click=\"color='blue'\">Change to blue</button>\n\t * <button ng-click=\"color='green'\">Change to green</button>\n\t * ```\n\t *\n\t * ```js\n\t * myModule.animation('.colorful', [function() {\n\t *   return {\n\t *     addClass: function(element, className, doneFn) {\n\t *       // do some cool animation and call the doneFn\n\t *     },\n\t *     removeClass: function(element, className, doneFn) {\n\t *       // do some cool animation and call the doneFn\n\t *     },\n\t *     setClass: function(element, addedClass, removedClass, doneFn) {\n\t *       // do some cool animation and call the doneFn\n\t *     }\n\t *   }\n\t * }]);\n\t * ```\n\t *\n\t * ## CSS + JS Animations Together\n\t *\n\t * AngularJS 1.4 and higher has taken steps to make the amalgamation of CSS and JS animations more flexible. However, unlike earlier versions of Angular,\n\t * defining CSS and JS animations to work off of the same CSS class will not work anymore. Therefore the example below will only result in **JS animations taking\n\t * charge of the animation**:\n\t *\n\t * ```html\n\t * <div ng-if=\"bool\" class=\"slide\">\n\t *   Slide in and out\n\t * </div>\n\t * ```\n\t *\n\t * ```js\n\t * myModule.animation('.slide', [function() {\n\t *   return {\n\t *     enter: function(element, doneFn) {\n\t *       jQuery(element).slideIn(1000, doneFn);\n\t *     }\n\t *   }\n\t * }]);\n\t * ```\n\t *\n\t * ```css\n\t * .slide.ng-enter {\n\t *   transition:0.5s linear all;\n\t *   transform:translateY(-100px);\n\t * }\n\t * .slide.ng-enter.ng-enter-active {\n\t *   transform:translateY(0);\n\t * }\n\t * ```\n\t *\n\t * Does this mean that CSS and JS animations cannot be used together? Do JS-based animations always have higher priority? We can make up for the\n\t * lack of CSS animations by using the `$animateCss` service to trigger our own tweaked-out, CSS-based animations directly from\n\t * our own JS-based animation code:\n\t *\n\t * ```js\n\t * myModule.animation('.slide', ['$animateCss', function($animateCss) {\n\t *   return {\n\t *     enter: function(element) {\n\t*        // this will trigger `.slide.ng-enter` and `.slide.ng-enter-active`.\n\t *       return $animateCss(element, {\n\t *         event: 'enter',\n\t *         structural: true\n\t *       });\n\t *     }\n\t *   }\n\t * }]);\n\t * ```\n\t *\n\t * The nice thing here is that we can save bandwidth by sticking to our CSS-based animation code and we don't need to rely on a 3rd-party animation framework.\n\t *\n\t * The `$animateCss` service is very powerful since we can feed in all kinds of extra properties that will be evaluated and fed into a CSS transition or\n\t * keyframe animation. For example if we wanted to animate the height of an element while adding and removing classes then we can do so by providing that\n\t * data into `$animateCss` directly:\n\t *\n\t * ```js\n\t * myModule.animation('.slide', ['$animateCss', function($animateCss) {\n\t *   return {\n\t *     enter: function(element) {\n\t *       return $animateCss(element, {\n\t *         event: 'enter',\n\t *         structural: true,\n\t *         addClass: 'maroon-setting',\n\t *         from: { height:0 },\n\t *         to: { height: 200 }\n\t *       });\n\t *     }\n\t *   }\n\t * }]);\n\t * ```\n\t *\n\t * Now we can fill in the rest via our transition CSS code:\n\t *\n\t * ```css\n\t * /&#42; the transition tells ngAnimate to make the animation happen &#42;/\n\t * .slide.ng-enter { transition:0.5s linear all; }\n\t *\n\t * /&#42; this extra CSS class will be absorbed into the transition\n\t * since the $animateCss code is adding the class &#42;/\n\t * .maroon-setting { background:red; }\n\t * ```\n\t *\n\t * And `$animateCss` will figure out the rest. Just make sure to have the `done()` callback fire the `doneFn` function to signal when the animation is over.\n\t *\n\t * To learn more about what's possible be sure to visit the {@link ngAnimate.$animateCss $animateCss service}.\n\t *\n\t * ## Animation Anchoring (via `ng-animate-ref`)\n\t *\n\t * ngAnimate in AngularJS 1.4 comes packed with the ability to cross-animate elements between\n\t * structural areas of an application (like views) by pairing up elements using an attribute\n\t * called `ng-animate-ref`.\n\t *\n\t * Let's say for example we have two views that are managed by `ng-view` and we want to show\n\t * that there is a relationship between two components situated in within these views. By using the\n\t * `ng-animate-ref` attribute we can identify that the two components are paired together and we\n\t * can then attach an animation, which is triggered when the view changes.\n\t *\n\t * Say for example we have the following template code:\n\t *\n\t * ```html\n\t * <!-- index.html -->\n\t * <div ng-view class=\"view-animation\">\n\t * </div>\n\t *\n\t * <!-- home.html -->\n\t * <a href=\"#/banner-page\">\n\t *   <img src=\"./banner.jpg\" class=\"banner\" ng-animate-ref=\"banner\">\n\t * </a>\n\t *\n\t * <!-- banner-page.html -->\n\t * <img src=\"./banner.jpg\" class=\"banner\" ng-animate-ref=\"banner\">\n\t * ```\n\t *\n\t * Now, when the view changes (once the link is clicked), ngAnimate will examine the\n\t * HTML contents to see if there is a match reference between any components in the view\n\t * that is leaving and the view that is entering. It will scan both the view which is being\n\t * removed (leave) and inserted (enter) to see if there are any paired DOM elements that\n\t * contain a matching ref value.\n\t *\n\t * The two images match since they share the same ref value. ngAnimate will now create a\n\t * transport element (which is a clone of the first image element) and it will then attempt\n\t * to animate to the position of the second image element in the next view. For the animation to\n\t * work a special CSS class called `ng-anchor` will be added to the transported element.\n\t *\n\t * We can now attach a transition onto the `.banner.ng-anchor` CSS class and then\n\t * ngAnimate will handle the entire transition for us as well as the addition and removal of\n\t * any changes of CSS classes between the elements:\n\t *\n\t * ```css\n\t * .banner.ng-anchor {\n\t *   /&#42; this animation will last for 1 second since there are\n\t *          two phases to the animation (an `in` and an `out` phase) &#42;/\n\t *   transition:0.5s linear all;\n\t * }\n\t * ```\n\t *\n\t * We also **must** include animations for the views that are being entered and removed\n\t * (otherwise anchoring wouldn't be possible since the new view would be inserted right away).\n\t *\n\t * ```css\n\t * .view-animation.ng-enter, .view-animation.ng-leave {\n\t *   transition:0.5s linear all;\n\t *   position:fixed;\n\t *   left:0;\n\t *   top:0;\n\t *   width:100%;\n\t * }\n\t * .view-animation.ng-enter {\n\t *   transform:translateX(100%);\n\t * }\n\t * .view-animation.ng-leave,\n\t * .view-animation.ng-enter.ng-enter-active {\n\t *   transform:translateX(0%);\n\t * }\n\t * .view-animation.ng-leave.ng-leave-active {\n\t *   transform:translateX(-100%);\n\t * }\n\t * ```\n\t *\n\t * Now we can jump back to the anchor animation. When the animation happens, there are two stages that occur:\n\t * an `out` and an `in` stage. The `out` stage happens first and that is when the element is animated away\n\t * from its origin. Once that animation is over then the `in` stage occurs which animates the\n\t * element to its destination. The reason why there are two animations is to give enough time\n\t * for the enter animation on the new element to be ready.\n\t *\n\t * The example above sets up a transition for both the in and out phases, but we can also target the out or\n\t * in phases directly via `ng-anchor-out` and `ng-anchor-in`.\n\t *\n\t * ```css\n\t * .banner.ng-anchor-out {\n\t *   transition: 0.5s linear all;\n\t *\n\t *   /&#42; the scale will be applied during the out animation,\n\t *          but will be animated away when the in animation runs &#42;/\n\t *   transform: scale(1.2);\n\t * }\n\t *\n\t * .banner.ng-anchor-in {\n\t *   transition: 1s linear all;\n\t * }\n\t * ```\n\t *\n\t *\n\t *\n\t *\n\t * ### Anchoring Demo\n\t *\n\t  <example module=\"anchoringExample\"\n\t           name=\"anchoringExample\"\n\t           id=\"anchoringExample\"\n\t           deps=\"angular-animate.js;angular-route.js\"\n\t           animations=\"true\">\n\t    <file name=\"index.html\">\n\t      <a href=\"#/\">Home</a>\n\t      <hr />\n\t      <div class=\"view-container\">\n\t        <div ng-view class=\"view\"></div>\n\t      </div>\n\t    </file>\n\t    <file name=\"script.js\">\n\t      angular.module('anchoringExample', ['ngAnimate', 'ngRoute'])\n\t        .config(['$routeProvider', function($routeProvider) {\n\t          $routeProvider.when('/', {\n\t            templateUrl: 'home.html',\n\t            controller: 'HomeController as home'\n\t          });\n\t          $routeProvider.when('/profile/:id', {\n\t            templateUrl: 'profile.html',\n\t            controller: 'ProfileController as profile'\n\t          });\n\t        }])\n\t        .run(['$rootScope', function($rootScope) {\n\t          $rootScope.records = [\n\t            { id:1, title: \"Miss Beulah Roob\" },\n\t            { id:2, title: \"Trent Morissette\" },\n\t            { id:3, title: \"Miss Ava Pouros\" },\n\t            { id:4, title: \"Rod Pouros\" },\n\t            { id:5, title: \"Abdul Rice\" },\n\t            { id:6, title: \"Laurie Rutherford Sr.\" },\n\t            { id:7, title: \"Nakia McLaughlin\" },\n\t            { id:8, title: \"Jordon Blanda DVM\" },\n\t            { id:9, title: \"Rhoda Hand\" },\n\t            { id:10, title: \"Alexandrea Sauer\" }\n\t          ];\n\t        }])\n\t        .controller('HomeController', [function() {\n\t          //empty\n\t        }])\n\t        .controller('ProfileController', ['$rootScope', '$routeParams', function($rootScope, $routeParams) {\n\t          var index = parseInt($routeParams.id, 10);\n\t          var record = $rootScope.records[index - 1];\n\t\n\t          this.title = record.title;\n\t          this.id = record.id;\n\t        }]);\n\t    </file>\n\t    <file name=\"home.html\">\n\t      <h2>Welcome to the home page</h1>\n\t      <p>Please click on an element</p>\n\t      <a class=\"record\"\n\t         ng-href=\"#/profile/{{ record.id }}\"\n\t         ng-animate-ref=\"{{ record.id }}\"\n\t         ng-repeat=\"record in records\">\n\t        {{ record.title }}\n\t      </a>\n\t    </file>\n\t    <file name=\"profile.html\">\n\t      <div class=\"profile record\" ng-animate-ref=\"{{ profile.id }}\">\n\t        {{ profile.title }}\n\t      </div>\n\t    </file>\n\t    <file name=\"animations.css\">\n\t      .record {\n\t        display:block;\n\t        font-size:20px;\n\t      }\n\t      .profile {\n\t        background:black;\n\t        color:white;\n\t        font-size:100px;\n\t      }\n\t      .view-container {\n\t        position:relative;\n\t      }\n\t      .view-container > .view.ng-animate {\n\t        position:absolute;\n\t        top:0;\n\t        left:0;\n\t        width:100%;\n\t        min-height:500px;\n\t      }\n\t      .view.ng-enter, .view.ng-leave,\n\t      .record.ng-anchor {\n\t        transition:0.5s linear all;\n\t      }\n\t      .view.ng-enter {\n\t        transform:translateX(100%);\n\t      }\n\t      .view.ng-enter.ng-enter-active, .view.ng-leave {\n\t        transform:translateX(0%);\n\t      }\n\t      .view.ng-leave.ng-leave-active {\n\t        transform:translateX(-100%);\n\t      }\n\t      .record.ng-anchor-out {\n\t        background:red;\n\t      }\n\t    </file>\n\t  </example>\n\t *\n\t * ### How is the element transported?\n\t *\n\t * When an anchor animation occurs, ngAnimate will clone the starting element and position it exactly where the starting\n\t * element is located on screen via absolute positioning. The cloned element will be placed inside of the root element\n\t * of the application (where ng-app was defined) and all of the CSS classes of the starting element will be applied. The\n\t * element will then animate into the `out` and `in` animations and will eventually reach the coordinates and match\n\t * the dimensions of the destination element. During the entire animation a CSS class of `.ng-animate-shim` will be applied\n\t * to both the starting and destination elements in order to hide them from being visible (the CSS styling for the class\n\t * is: `visibility:hidden`). Once the anchor reaches its destination then it will be removed and the destination element\n\t * will become visible since the shim class will be removed.\n\t *\n\t * ### How is the morphing handled?\n\t *\n\t * CSS Anchoring relies on transitions and keyframes and the internal code is intelligent enough to figure out\n\t * what CSS classes differ between the starting element and the destination element. These different CSS classes\n\t * will be added/removed on the anchor element and a transition will be applied (the transition that is provided\n\t * in the anchor class). Long story short, ngAnimate will figure out what classes to add and remove which will\n\t * make the transition of the element as smooth and automatic as possible. Be sure to use simple CSS classes that\n\t * do not rely on DOM nesting structure so that the anchor element appears the same as the starting element (since\n\t * the cloned element is placed inside of root element which is likely close to the body element).\n\t *\n\t * Note that if the root element is on the `<html>` element then the cloned node will be placed inside of body.\n\t *\n\t *\n\t * ## Using $animate in your directive code\n\t *\n\t * So far we've explored how to feed in animations into an Angular application, but how do we trigger animations within our own directives in our application?\n\t * By injecting the `$animate` service into our directive code, we can trigger structural and class-based hooks which can then be consumed by animations. Let's\n\t * imagine we have a greeting box that shows and hides itself when the data changes\n\t *\n\t * ```html\n\t * <greeting-box active=\"onOrOff\">Hi there</greeting-box>\n\t * ```\n\t *\n\t * ```js\n\t * ngModule.directive('greetingBox', ['$animate', function($animate) {\n\t *   return function(scope, element, attrs) {\n\t *     attrs.$observe('active', function(value) {\n\t *       value ? $animate.addClass(element, 'on') : $animate.removeClass(element, 'on');\n\t *     });\n\t *   });\n\t * }]);\n\t * ```\n\t *\n\t * Now the `on` CSS class is added and removed on the greeting box component. Now if we add a CSS class on top of the greeting box element\n\t * in our HTML code then we can trigger a CSS or JS animation to happen.\n\t *\n\t * ```css\n\t * /&#42; normally we would create a CSS class to reference on the element &#42;/\n\t * greeting-box.on { transition:0.5s linear all; background:green; color:white; }\n\t * ```\n\t *\n\t * The `$animate` service contains a variety of other methods like `enter`, `leave`, `animate` and `setClass`. To learn more about what's\n\t * possible be sure to visit the {@link ng.$animate $animate service API page}.\n\t *\n\t *\n\t * ## Callbacks and Promises\n\t *\n\t * When `$animate` is called it returns a promise that can be used to capture when the animation has ended. Therefore if we were to trigger\n\t * an animation (within our directive code) then we can continue performing directive and scope related activities after the animation has\n\t * ended by chaining onto the returned promise that animation method returns.\n\t *\n\t * ```js\n\t * // somewhere within the depths of the directive\n\t * $animate.enter(element, parent).then(function() {\n\t *   //the animation has completed\n\t * });\n\t * ```\n\t *\n\t * (Note that earlier versions of Angular prior to v1.4 required the promise code to be wrapped using `$scope.$apply(...)`. This is not the case\n\t * anymore.)\n\t *\n\t * In addition to the animation promise, we can also make use of animation-related callbacks within our directives and controller code by registering\n\t * an event listener using the `$animate` service. Let's say for example that an animation was triggered on our view\n\t * routing controller to hook into that:\n\t *\n\t * ```js\n\t * ngModule.controller('HomePageController', ['$animate', function($animate) {\n\t *   $animate.on('enter', ngViewElement, function(element) {\n\t *     // the animation for this route has completed\n\t *   }]);\n\t * }])\n\t * ```\n\t *\n\t * (Note that you will need to trigger a digest within the callback to get angular to notice any scope-related changes.)\n\t */\n\t\n\tvar copy;\n\tvar extend;\n\tvar forEach;\n\tvar isArray;\n\tvar isDefined;\n\tvar isElement;\n\tvar isFunction;\n\tvar isObject;\n\tvar isString;\n\tvar isUndefined;\n\tvar jqLite;\n\tvar noop;\n\t\n\t/**\n\t * @ngdoc service\n\t * @name $animate\n\t * @kind object\n\t *\n\t * @description\n\t * The ngAnimate `$animate` service documentation is the same for the core `$animate` service.\n\t *\n\t * Click here {@link ng.$animate to learn more about animations with `$animate`}.\n\t */\n\tangular.module('ngAnimate', [], function initAngularHelpers() {\n\t  // Access helpers from angular core.\n\t  // Do it inside a `config` block to ensure `window.angular` is available.\n\t  noop        = angular.noop;\n\t  copy        = angular.copy;\n\t  extend      = angular.extend;\n\t  jqLite      = angular.element;\n\t  forEach     = angular.forEach;\n\t  isArray     = angular.isArray;\n\t  isString    = angular.isString;\n\t  isObject    = angular.isObject;\n\t  isUndefined = angular.isUndefined;\n\t  isDefined   = angular.isDefined;\n\t  isFunction  = angular.isFunction;\n\t  isElement   = angular.isElement;\n\t})\n\t  .directive('ngAnimateSwap', ngAnimateSwapDirective)\n\t\n\t  .directive('ngAnimateChildren', $$AnimateChildrenDirective)\n\t  .factory('$$rAFScheduler', $$rAFSchedulerFactory)\n\t\n\t  .provider('$$animateQueue', $$AnimateQueueProvider)\n\t  .provider('$$animation', $$AnimationProvider)\n\t\n\t  .provider('$animateCss', $AnimateCssProvider)\n\t  .provider('$$animateCssDriver', $$AnimateCssDriverProvider)\n\t\n\t  .provider('$$animateJs', $$AnimateJsProvider)\n\t  .provider('$$animateJsDriver', $$AnimateJsDriverProvider);\n\t\n\t\n\t})(window, window.angular);\n\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(8);\n\tmodule.exports = 'ngSanitize';\n\n\n/***/ },\n/* 8 */\n/***/ function(module, exports) {\n\n\t/**\n\t * @license AngularJS v1.5.8\n\t * (c) 2010-2016 Google, Inc. http://angularjs.org\n\t * License: MIT\n\t */\n\t(function(window, angular) {'use strict';\n\t\n\t/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\t *     Any commits to this file should be reviewed with security in mind.  *\n\t *   Changes to this file can potentially create security vulnerabilities. *\n\t *          An approval from 2 Core members with history of modifying      *\n\t *                         this file is required.                          *\n\t *                                                                         *\n\t *  Does the change somehow allow for arbitrary javascript to be executed? *\n\t *    Or allows for someone to change the prototype of built-in objects?   *\n\t *     Or gives undesired access to variables likes document or window?    *\n\t * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\t\n\tvar $sanitizeMinErr = angular.$$minErr('$sanitize');\n\tvar bind;\n\tvar extend;\n\tvar forEach;\n\tvar isDefined;\n\tvar lowercase;\n\tvar noop;\n\tvar htmlParser;\n\tvar htmlSanitizeWriter;\n\t\n\t/**\n\t * @ngdoc module\n\t * @name ngSanitize\n\t * @description\n\t *\n\t * # ngSanitize\n\t *\n\t * The `ngSanitize` module provides functionality to sanitize HTML.\n\t *\n\t *\n\t * <div doc-module-components=\"ngSanitize\"></div>\n\t *\n\t * See {@link ngSanitize.$sanitize `$sanitize`} for usage.\n\t */\n\t\n\t/**\n\t * @ngdoc service\n\t * @name $sanitize\n\t * @kind function\n\t *\n\t * @description\n\t *   Sanitizes an html string by stripping all potentially dangerous tokens.\n\t *\n\t *   The input is sanitized by parsing the HTML into tokens. All safe tokens (from a whitelist) are\n\t *   then serialized back to properly escaped html string. This means that no unsafe input can make\n\t *   it into the returned string.\n\t *\n\t *   The whitelist for URL sanitization of attribute values is configured using the functions\n\t *   `aHrefSanitizationWhitelist` and `imgSrcSanitizationWhitelist` of {@link ng.$compileProvider\n\t *   `$compileProvider`}.\n\t *\n\t *   The input may also contain SVG markup if this is enabled via {@link $sanitizeProvider}.\n\t *\n\t * @param {string} html HTML input.\n\t * @returns {string} Sanitized HTML.\n\t *\n\t * @example\n\t   <example module=\"sanitizeExample\" deps=\"angular-sanitize.js\">\n\t   <file name=\"index.html\">\n\t     <script>\n\t         angular.module('sanitizeExample', ['ngSanitize'])\n\t           .controller('ExampleController', ['$scope', '$sce', function($scope, $sce) {\n\t             $scope.snippet =\n\t               '<p style=\"color:blue\">an html\\n' +\n\t               '<em onmouseover=\"this.textContent=\\'PWN3D!\\'\">click here</em>\\n' +\n\t               'snippet</p>';\n\t             $scope.deliberatelyTrustDangerousSnippet = function() {\n\t               return $sce.trustAsHtml($scope.snippet);\n\t             };\n\t           }]);\n\t     </script>\n\t     <div ng-controller=\"ExampleController\">\n\t        Snippet: <textarea ng-model=\"snippet\" cols=\"60\" rows=\"3\"></textarea>\n\t       <table>\n\t         <tr>\n\t           <td>Directive</td>\n\t           <td>How</td>\n\t           <td>Source</td>\n\t           <td>Rendered</td>\n\t         </tr>\n\t         <tr id=\"bind-html-with-sanitize\">\n\t           <td>ng-bind-html</td>\n\t           <td>Automatically uses $sanitize</td>\n\t           <td><pre>&lt;div ng-bind-html=\"snippet\"&gt;<br/>&lt;/div&gt;</pre></td>\n\t           <td><div ng-bind-html=\"snippet\"></div></td>\n\t         </tr>\n\t         <tr id=\"bind-html-with-trust\">\n\t           <td>ng-bind-html</td>\n\t           <td>Bypass $sanitize by explicitly trusting the dangerous value</td>\n\t           <td>\n\t           <pre>&lt;div ng-bind-html=\"deliberatelyTrustDangerousSnippet()\"&gt;\n\t&lt;/div&gt;</pre>\n\t           </td>\n\t           <td><div ng-bind-html=\"deliberatelyTrustDangerousSnippet()\"></div></td>\n\t         </tr>\n\t         <tr id=\"bind-default\">\n\t           <td>ng-bind</td>\n\t           <td>Automatically escapes</td>\n\t           <td><pre>&lt;div ng-bind=\"snippet\"&gt;<br/>&lt;/div&gt;</pre></td>\n\t           <td><div ng-bind=\"snippet\"></div></td>\n\t         </tr>\n\t       </table>\n\t       </div>\n\t   </file>\n\t   <file name=\"protractor.js\" type=\"protractor\">\n\t     it('should sanitize the html snippet by default', function() {\n\t       expect(element(by.css('#bind-html-with-sanitize div')).getInnerHtml()).\n\t         toBe('<p>an html\\n<em>click here</em>\\nsnippet</p>');\n\t     });\n\t\n\t     it('should inline raw snippet if bound to a trusted value', function() {\n\t       expect(element(by.css('#bind-html-with-trust div')).getInnerHtml()).\n\t         toBe(\"<p style=\\\"color:blue\\\">an html\\n\" +\n\t              \"<em onmouseover=\\\"this.textContent='PWN3D!'\\\">click here</em>\\n\" +\n\t              \"snippet</p>\");\n\t     });\n\t\n\t     it('should escape snippet without any filter', function() {\n\t       expect(element(by.css('#bind-default div')).getInnerHtml()).\n\t         toBe(\"&lt;p style=\\\"color:blue\\\"&gt;an html\\n\" +\n\t              \"&lt;em onmouseover=\\\"this.textContent='PWN3D!'\\\"&gt;click here&lt;/em&gt;\\n\" +\n\t              \"snippet&lt;/p&gt;\");\n\t     });\n\t\n\t     it('should update', function() {\n\t       element(by.model('snippet')).clear();\n\t       element(by.model('snippet')).sendKeys('new <b onclick=\"alert(1)\">text</b>');\n\t       expect(element(by.css('#bind-html-with-sanitize div')).getInnerHtml()).\n\t         toBe('new <b>text</b>');\n\t       expect(element(by.css('#bind-html-with-trust div')).getInnerHtml()).toBe(\n\t         'new <b onclick=\"alert(1)\">text</b>');\n\t       expect(element(by.css('#bind-default div')).getInnerHtml()).toBe(\n\t         \"new &lt;b onclick=\\\"alert(1)\\\"&gt;text&lt;/b&gt;\");\n\t     });\n\t   </file>\n\t   </example>\n\t */\n\t\n\t\n\t/**\n\t * @ngdoc provider\n\t * @name $sanitizeProvider\n\t *\n\t * @description\n\t * Creates and configures {@link $sanitize} instance.\n\t */\n\tfunction $SanitizeProvider() {\n\t  var svgEnabled = false;\n\t\n\t  this.$get = ['$$sanitizeUri', function($$sanitizeUri) {\n\t    if (svgEnabled) {\n\t      extend(validElements, svgElements);\n\t    }\n\t    return function(html) {\n\t      var buf = [];\n\t      htmlParser(html, htmlSanitizeWriter(buf, function(uri, isImage) {\n\t        return !/^unsafe:/.test($$sanitizeUri(uri, isImage));\n\t      }));\n\t      return buf.join('');\n\t    };\n\t  }];\n\t\n\t\n\t  /**\n\t   * @ngdoc method\n\t   * @name $sanitizeProvider#enableSvg\n\t   * @kind function\n\t   *\n\t   * @description\n\t   * Enables a subset of svg to be supported by the sanitizer.\n\t   *\n\t   * <div class=\"alert alert-warning\">\n\t   *   <p>By enabling this setting without taking other precautions, you might expose your\n\t   *   application to click-hijacking attacks. In these attacks, sanitized svg elements could be positioned\n\t   *   outside of the containing element and be rendered over other elements on the page (e.g. a login\n\t   *   link). Such behavior can then result in phishing incidents.</p>\n\t   *\n\t   *   <p>To protect against these, explicitly setup `overflow: hidden` css rule for all potential svg\n\t   *   tags within the sanitized content:</p>\n\t   *\n\t   *   <br>\n\t   *\n\t   *   <pre><code>\n\t   *   .rootOfTheIncludedContent svg {\n\t   *     overflow: hidden !important;\n\t   *   }\n\t   *   </code></pre>\n\t   * </div>\n\t   *\n\t   * @param {boolean=} flag Enable or disable SVG support in the sanitizer.\n\t   * @returns {boolean|ng.$sanitizeProvider} Returns the currently configured value if called\n\t   *    without an argument or self for chaining otherwise.\n\t   */\n\t  this.enableSvg = function(enableSvg) {\n\t    if (isDefined(enableSvg)) {\n\t      svgEnabled = enableSvg;\n\t      return this;\n\t    } else {\n\t      return svgEnabled;\n\t    }\n\t  };\n\t\n\t  //////////////////////////////////////////////////////////////////////////////////////////////////\n\t  // Private stuff\n\t  //////////////////////////////////////////////////////////////////////////////////////////////////\n\t\n\t  bind = angular.bind;\n\t  extend = angular.extend;\n\t  forEach = angular.forEach;\n\t  isDefined = angular.isDefined;\n\t  lowercase = angular.lowercase;\n\t  noop = angular.noop;\n\t\n\t  htmlParser = htmlParserImpl;\n\t  htmlSanitizeWriter = htmlSanitizeWriterImpl;\n\t\n\t  // Regular Expressions for parsing tags and attributes\n\t  var SURROGATE_PAIR_REGEXP = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g,\n\t    // Match everything outside of normal chars and \" (quote character)\n\t    NON_ALPHANUMERIC_REGEXP = /([^\\#-~ |!])/g;\n\t\n\t\n\t  // Good source of info about elements and attributes\n\t  // http://dev.w3.org/html5/spec/Overview.html#semantics\n\t  // http://simon.html5.org/html-elements\n\t\n\t  // Safe Void Elements - HTML5\n\t  // http://dev.w3.org/html5/spec/Overview.html#void-elements\n\t  var voidElements = toMap(\"area,br,col,hr,img,wbr\");\n\t\n\t  // Elements that you can, intentionally, leave open (and which close themselves)\n\t  // http://dev.w3.org/html5/spec/Overview.html#optional-tags\n\t  var optionalEndTagBlockElements = toMap(\"colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr\"),\n\t      optionalEndTagInlineElements = toMap(\"rp,rt\"),\n\t      optionalEndTagElements = extend({},\n\t                                              optionalEndTagInlineElements,\n\t                                              optionalEndTagBlockElements);\n\t\n\t  // Safe Block Elements - HTML5\n\t  var blockElements = extend({}, optionalEndTagBlockElements, toMap(\"address,article,\" +\n\t          \"aside,blockquote,caption,center,del,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,\" +\n\t          \"h6,header,hgroup,hr,ins,map,menu,nav,ol,pre,section,table,ul\"));\n\t\n\t  // Inline Elements - HTML5\n\t  var inlineElements = extend({}, optionalEndTagInlineElements, toMap(\"a,abbr,acronym,b,\" +\n\t          \"bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,q,ruby,rp,rt,s,\" +\n\t          \"samp,small,span,strike,strong,sub,sup,time,tt,u,var\"));\n\t\n\t  // SVG Elements\n\t  // https://wiki.whatwg.org/wiki/Sanitization_rules#svg_Elements\n\t  // Note: the elements animate,animateColor,animateMotion,animateTransform,set are intentionally omitted.\n\t  // They can potentially allow for arbitrary javascript to be executed. See #11290\n\t  var svgElements = toMap(\"circle,defs,desc,ellipse,font-face,font-face-name,font-face-src,g,glyph,\" +\n\t          \"hkern,image,linearGradient,line,marker,metadata,missing-glyph,mpath,path,polygon,polyline,\" +\n\t          \"radialGradient,rect,stop,svg,switch,text,title,tspan\");\n\t\n\t  // Blocked Elements (will be stripped)\n\t  var blockedElements = toMap(\"script,style\");\n\t\n\t  var validElements = extend({},\n\t                                     voidElements,\n\t                                     blockElements,\n\t                                     inlineElements,\n\t                                     optionalEndTagElements);\n\t\n\t  //Attributes that have href and hence need to be sanitized\n\t  var uriAttrs = toMap(\"background,cite,href,longdesc,src,xlink:href\");\n\t\n\t  var htmlAttrs = toMap('abbr,align,alt,axis,bgcolor,border,cellpadding,cellspacing,class,clear,' +\n\t      'color,cols,colspan,compact,coords,dir,face,headers,height,hreflang,hspace,' +\n\t      'ismap,lang,language,nohref,nowrap,rel,rev,rows,rowspan,rules,' +\n\t      'scope,scrolling,shape,size,span,start,summary,tabindex,target,title,type,' +\n\t      'valign,value,vspace,width');\n\t\n\t  // SVG attributes (without \"id\" and \"name\" attributes)\n\t  // https://wiki.whatwg.org/wiki/Sanitization_rules#svg_Attributes\n\t  var svgAttrs = toMap('accent-height,accumulate,additive,alphabetic,arabic-form,ascent,' +\n\t      'baseProfile,bbox,begin,by,calcMode,cap-height,class,color,color-rendering,content,' +\n\t      'cx,cy,d,dx,dy,descent,display,dur,end,fill,fill-rule,font-family,font-size,font-stretch,' +\n\t      'font-style,font-variant,font-weight,from,fx,fy,g1,g2,glyph-name,gradientUnits,hanging,' +\n\t      'height,horiz-adv-x,horiz-origin-x,ideographic,k,keyPoints,keySplines,keyTimes,lang,' +\n\t      'marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mathematical,' +\n\t      'max,min,offset,opacity,orient,origin,overline-position,overline-thickness,panose-1,' +\n\t      'path,pathLength,points,preserveAspectRatio,r,refX,refY,repeatCount,repeatDur,' +\n\t      'requiredExtensions,requiredFeatures,restart,rotate,rx,ry,slope,stemh,stemv,stop-color,' +\n\t      'stop-opacity,strikethrough-position,strikethrough-thickness,stroke,stroke-dasharray,' +\n\t      'stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,' +\n\t      'stroke-width,systemLanguage,target,text-anchor,to,transform,type,u1,u2,underline-position,' +\n\t      'underline-thickness,unicode,unicode-range,units-per-em,values,version,viewBox,visibility,' +\n\t      'width,widths,x,x-height,x1,x2,xlink:actuate,xlink:arcrole,xlink:role,xlink:show,xlink:title,' +\n\t      'xlink:type,xml:base,xml:lang,xml:space,xmlns,xmlns:xlink,y,y1,y2,zoomAndPan', true);\n\t\n\t  var validAttrs = extend({},\n\t                                  uriAttrs,\n\t                                  svgAttrs,\n\t                                  htmlAttrs);\n\t\n\t  function toMap(str, lowercaseKeys) {\n\t    var obj = {}, items = str.split(','), i;\n\t    for (i = 0; i < items.length; i++) {\n\t      obj[lowercaseKeys ? lowercase(items[i]) : items[i]] = true;\n\t    }\n\t    return obj;\n\t  }\n\t\n\t  var inertBodyElement;\n\t  (function(window) {\n\t    var doc;\n\t    if (window.document && window.document.implementation) {\n\t      doc = window.document.implementation.createHTMLDocument(\"inert\");\n\t    } else {\n\t      throw $sanitizeMinErr('noinert', \"Can't create an inert html document\");\n\t    }\n\t    var docElement = doc.documentElement || doc.getDocumentElement();\n\t    var bodyElements = docElement.getElementsByTagName('body');\n\t\n\t    // usually there should be only one body element in the document, but IE doesn't have any, so we need to create one\n\t    if (bodyElements.length === 1) {\n\t      inertBodyElement = bodyElements[0];\n\t    } else {\n\t      var html = doc.createElement('html');\n\t      inertBodyElement = doc.createElement('body');\n\t      html.appendChild(inertBodyElement);\n\t      doc.appendChild(html);\n\t    }\n\t  })(window);\n\t\n\t  /**\n\t   * @example\n\t   * htmlParser(htmlString, {\n\t   *     start: function(tag, attrs) {},\n\t   *     end: function(tag) {},\n\t   *     chars: function(text) {},\n\t   *     comment: function(text) {}\n\t   * });\n\t   *\n\t   * @param {string} html string\n\t   * @param {object} handler\n\t   */\n\t  function htmlParserImpl(html, handler) {\n\t    if (html === null || html === undefined) {\n\t      html = '';\n\t    } else if (typeof html !== 'string') {\n\t      html = '' + html;\n\t    }\n\t    inertBodyElement.innerHTML = html;\n\t\n\t    //mXSS protection\n\t    var mXSSAttempts = 5;\n\t    do {\n\t      if (mXSSAttempts === 0) {\n\t        throw $sanitizeMinErr('uinput', \"Failed to sanitize html because the input is unstable\");\n\t      }\n\t      mXSSAttempts--;\n\t\n\t      // strip custom-namespaced attributes on IE<=11\n\t      if (window.document.documentMode) {\n\t        stripCustomNsAttrs(inertBodyElement);\n\t      }\n\t      html = inertBodyElement.innerHTML; //trigger mXSS\n\t      inertBodyElement.innerHTML = html;\n\t    } while (html !== inertBodyElement.innerHTML);\n\t\n\t    var node = inertBodyElement.firstChild;\n\t    while (node) {\n\t      switch (node.nodeType) {\n\t        case 1: // ELEMENT_NODE\n\t          handler.start(node.nodeName.toLowerCase(), attrToMap(node.attributes));\n\t          break;\n\t        case 3: // TEXT NODE\n\t          handler.chars(node.textContent);\n\t          break;\n\t      }\n\t\n\t      var nextNode;\n\t      if (!(nextNode = node.firstChild)) {\n\t      if (node.nodeType == 1) {\n\t          handler.end(node.nodeName.toLowerCase());\n\t        }\n\t        nextNode = node.nextSibling;\n\t        if (!nextNode) {\n\t          while (nextNode == null) {\n\t            node = node.parentNode;\n\t            if (node === inertBodyElement) break;\n\t            nextNode = node.nextSibling;\n\t          if (node.nodeType == 1) {\n\t              handler.end(node.nodeName.toLowerCase());\n\t            }\n\t          }\n\t        }\n\t      }\n\t      node = nextNode;\n\t    }\n\t\n\t    while (node = inertBodyElement.firstChild) {\n\t      inertBodyElement.removeChild(node);\n\t    }\n\t  }\n\t\n\t  function attrToMap(attrs) {\n\t    var map = {};\n\t    for (var i = 0, ii = attrs.length; i < ii; i++) {\n\t      var attr = attrs[i];\n\t      map[attr.name] = attr.value;\n\t    }\n\t    return map;\n\t  }\n\t\n\t\n\t  /**\n\t   * Escapes all potentially dangerous characters, so that the\n\t   * resulting string can be safely inserted into attribute or\n\t   * element text.\n\t   * @param value\n\t   * @returns {string} escaped text\n\t   */\n\t  function encodeEntities(value) {\n\t    return value.\n\t      replace(/&/g, '&amp;').\n\t      replace(SURROGATE_PAIR_REGEXP, function(value) {\n\t        var hi = value.charCodeAt(0);\n\t        var low = value.charCodeAt(1);\n\t        return '&#' + (((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000) + ';';\n\t      }).\n\t      replace(NON_ALPHANUMERIC_REGEXP, function(value) {\n\t        return '&#' + value.charCodeAt(0) + ';';\n\t      }).\n\t      replace(/</g, '&lt;').\n\t      replace(/>/g, '&gt;');\n\t  }\n\t\n\t  /**\n\t   * create an HTML/XML writer which writes to buffer\n\t   * @param {Array} buf use buf.join('') to get out sanitized html string\n\t   * @returns {object} in the form of {\n\t   *     start: function(tag, attrs) {},\n\t   *     end: function(tag) {},\n\t   *     chars: function(text) {},\n\t   *     comment: function(text) {}\n\t   * }\n\t   */\n\t  function htmlSanitizeWriterImpl(buf, uriValidator) {\n\t    var ignoreCurrentElement = false;\n\t    var out = bind(buf, buf.push);\n\t    return {\n\t      start: function(tag, attrs) {\n\t        tag = lowercase(tag);\n\t        if (!ignoreCurrentElement && blockedElements[tag]) {\n\t          ignoreCurrentElement = tag;\n\t        }\n\t        if (!ignoreCurrentElement && validElements[tag] === true) {\n\t          out('<');\n\t          out(tag);\n\t          forEach(attrs, function(value, key) {\n\t            var lkey = lowercase(key);\n\t            var isImage = (tag === 'img' && lkey === 'src') || (lkey === 'background');\n\t            if (validAttrs[lkey] === true &&\n\t              (uriAttrs[lkey] !== true || uriValidator(value, isImage))) {\n\t              out(' ');\n\t              out(key);\n\t              out('=\"');\n\t              out(encodeEntities(value));\n\t              out('\"');\n\t            }\n\t          });\n\t          out('>');\n\t        }\n\t      },\n\t      end: function(tag) {\n\t        tag = lowercase(tag);\n\t        if (!ignoreCurrentElement && validElements[tag] === true && voidElements[tag] !== true) {\n\t          out('</');\n\t          out(tag);\n\t          out('>');\n\t        }\n\t        if (tag == ignoreCurrentElement) {\n\t          ignoreCurrentElement = false;\n\t        }\n\t      },\n\t      chars: function(chars) {\n\t        if (!ignoreCurrentElement) {\n\t          out(encodeEntities(chars));\n\t        }\n\t      }\n\t    };\n\t  }\n\t\n\t\n\t  /**\n\t   * When IE9-11 comes across an unknown namespaced attribute e.g. 'xlink:foo' it adds 'xmlns:ns1' attribute to declare\n\t   * ns1 namespace and prefixes the attribute with 'ns1' (e.g. 'ns1:xlink:foo'). This is undesirable since we don't want\n\t   * to allow any of these custom attributes. This method strips them all.\n\t   *\n\t   * @param node Root element to process\n\t   */\n\t  function stripCustomNsAttrs(node) {\n\t    if (node.nodeType === window.Node.ELEMENT_NODE) {\n\t      var attrs = node.attributes;\n\t      for (var i = 0, l = attrs.length; i < l; i++) {\n\t        var attrNode = attrs[i];\n\t        var attrName = attrNode.name.toLowerCase();\n\t        if (attrName === 'xmlns:ns1' || attrName.lastIndexOf('ns1:', 0) === 0) {\n\t          node.removeAttributeNode(attrNode);\n\t          i--;\n\t          l--;\n\t        }\n\t      }\n\t    }\n\t\n\t    var nextNode = node.firstChild;\n\t    if (nextNode) {\n\t      stripCustomNsAttrs(nextNode);\n\t    }\n\t\n\t    nextNode = node.nextSibling;\n\t    if (nextNode) {\n\t      stripCustomNsAttrs(nextNode);\n\t    }\n\t  }\n\t}\n\t\n\tfunction sanitizeText(chars) {\n\t  var buf = [];\n\t  var writer = htmlSanitizeWriter(buf, noop);\n\t  writer.chars(chars);\n\t  return buf.join('');\n\t}\n\t\n\t\n\t// define ngSanitize module and register $sanitize service\n\tangular.module('ngSanitize', []).provider('$sanitize', $SanitizeProvider);\n\t\n\t/**\n\t * @ngdoc filter\n\t * @name linky\n\t * @kind function\n\t *\n\t * @description\n\t * Finds links in text input and turns them into html links. Supports `http/https/ftp/mailto` and\n\t * plain email address links.\n\t *\n\t * Requires the {@link ngSanitize `ngSanitize`} module to be installed.\n\t *\n\t * @param {string} text Input text.\n\t * @param {string} target Window (`_blank|_self|_parent|_top`) or named frame to open links in.\n\t * @param {object|function(url)} [attributes] Add custom attributes to the link element.\n\t *\n\t *    Can be one of:\n\t *\n\t *    - `object`: A map of attributes\n\t *    - `function`: Takes the url as a parameter and returns a map of attributes\n\t *\n\t *    If the map of attributes contains a value for `target`, it overrides the value of\n\t *    the target parameter.\n\t *\n\t *\n\t * @returns {string} Html-linkified and {@link $sanitize sanitized} text.\n\t *\n\t * @usage\n\t   <span ng-bind-html=\"linky_expression | linky\"></span>\n\t *\n\t * @example\n\t   <example module=\"linkyExample\" deps=\"angular-sanitize.js\">\n\t     <file name=\"index.html\">\n\t       <div ng-controller=\"ExampleController\">\n\t       Snippet: <textarea ng-model=\"snippet\" cols=\"60\" rows=\"3\"></textarea>\n\t       <table>\n\t         <tr>\n\t           <th>Filter</th>\n\t           <th>Source</th>\n\t           <th>Rendered</th>\n\t         </tr>\n\t         <tr id=\"linky-filter\">\n\t           <td>linky filter</td>\n\t           <td>\n\t             <pre>&lt;div ng-bind-html=\"snippet | linky\"&gt;<br>&lt;/div&gt;</pre>\n\t           </td>\n\t           <td>\n\t             <div ng-bind-html=\"snippet | linky\"></div>\n\t           </td>\n\t         </tr>\n\t         <tr id=\"linky-target\">\n\t          <td>linky target</td>\n\t          <td>\n\t            <pre>&lt;div ng-bind-html=\"snippetWithSingleURL | linky:'_blank'\"&gt;<br>&lt;/div&gt;</pre>\n\t          </td>\n\t          <td>\n\t            <div ng-bind-html=\"snippetWithSingleURL | linky:'_blank'\"></div>\n\t          </td>\n\t         </tr>\n\t         <tr id=\"linky-custom-attributes\">\n\t          <td>linky custom attributes</td>\n\t          <td>\n\t            <pre>&lt;div ng-bind-html=\"snippetWithSingleURL | linky:'_self':{rel: 'nofollow'}\"&gt;<br>&lt;/div&gt;</pre>\n\t          </td>\n\t          <td>\n\t            <div ng-bind-html=\"snippetWithSingleURL | linky:'_self':{rel: 'nofollow'}\"></div>\n\t          </td>\n\t         </tr>\n\t         <tr id=\"escaped-html\">\n\t           <td>no filter</td>\n\t           <td><pre>&lt;div ng-bind=\"snippet\"&gt;<br>&lt;/div&gt;</pre></td>\n\t           <td><div ng-bind=\"snippet\"></div></td>\n\t         </tr>\n\t       </table>\n\t     </file>\n\t     <file name=\"script.js\">\n\t       angular.module('linkyExample', ['ngSanitize'])\n\t         .controller('ExampleController', ['$scope', function($scope) {\n\t           $scope.snippet =\n\t             'Pretty text with some links:\\n'+\n\t             'http://angularjs.org/,\\n'+\n\t             'mailto:us@somewhere.org,\\n'+\n\t             'another@somewhere.org,\\n'+\n\t             'and one more: ftp://127.0.0.1/.';\n\t           $scope.snippetWithSingleURL = 'http://angularjs.org/';\n\t         }]);\n\t     </file>\n\t     <file name=\"protractor.js\" type=\"protractor\">\n\t       it('should linkify the snippet with urls', function() {\n\t         expect(element(by.id('linky-filter')).element(by.binding('snippet | linky')).getText()).\n\t             toBe('Pretty text with some links: http://angularjs.org/, us@somewhere.org, ' +\n\t                  'another@somewhere.org, and one more: ftp://127.0.0.1/.');\n\t         expect(element.all(by.css('#linky-filter a')).count()).toEqual(4);\n\t       });\n\t\n\t       it('should not linkify snippet without the linky filter', function() {\n\t         expect(element(by.id('escaped-html')).element(by.binding('snippet')).getText()).\n\t             toBe('Pretty text with some links: http://angularjs.org/, mailto:us@somewhere.org, ' +\n\t                  'another@somewhere.org, and one more: ftp://127.0.0.1/.');\n\t         expect(element.all(by.css('#escaped-html a')).count()).toEqual(0);\n\t       });\n\t\n\t       it('should update', function() {\n\t         element(by.model('snippet')).clear();\n\t         element(by.model('snippet')).sendKeys('new http://link.');\n\t         expect(element(by.id('linky-filter')).element(by.binding('snippet | linky')).getText()).\n\t             toBe('new http://link.');\n\t         expect(element.all(by.css('#linky-filter a')).count()).toEqual(1);\n\t         expect(element(by.id('escaped-html')).element(by.binding('snippet')).getText())\n\t             .toBe('new http://link.');\n\t       });\n\t\n\t       it('should work with the target property', function() {\n\t        expect(element(by.id('linky-target')).\n\t            element(by.binding(\"snippetWithSingleURL | linky:'_blank'\")).getText()).\n\t            toBe('http://angularjs.org/');\n\t        expect(element(by.css('#linky-target a')).getAttribute('target')).toEqual('_blank');\n\t       });\n\t\n\t       it('should optionally add custom attributes', function() {\n\t        expect(element(by.id('linky-custom-attributes')).\n\t            element(by.binding(\"snippetWithSingleURL | linky:'_self':{rel: 'nofollow'}\")).getText()).\n\t            toBe('http://angularjs.org/');\n\t        expect(element(by.css('#linky-custom-attributes a')).getAttribute('rel')).toEqual('nofollow');\n\t       });\n\t     </file>\n\t   </example>\n\t */\n\tangular.module('ngSanitize').filter('linky', ['$sanitize', function($sanitize) {\n\t  var LINKY_URL_REGEXP =\n\t        /((ftp|https?):\\/\\/|(www\\.)|(mailto:)?[A-Za-z0-9._%+-]+@)\\S*[^\\s.;,(){}<>\"\\u201d\\u2019]/i,\n\t      MAILTO_REGEXP = /^mailto:/i;\n\t\n\t  var linkyMinErr = angular.$$minErr('linky');\n\t  var isDefined = angular.isDefined;\n\t  var isFunction = angular.isFunction;\n\t  var isObject = angular.isObject;\n\t  var isString = angular.isString;\n\t\n\t  return function(text, target, attributes) {\n\t    if (text == null || text === '') return text;\n\t    if (!isString(text)) throw linkyMinErr('notstring', 'Expected string but received: {0}', text);\n\t\n\t    var attributesFn =\n\t      isFunction(attributes) ? attributes :\n\t      isObject(attributes) ? function getAttributesObject() {return attributes;} :\n\t      function getEmptyAttributesObject() {return {};};\n\t\n\t    var match;\n\t    var raw = text;\n\t    var html = [];\n\t    var url;\n\t    var i;\n\t    while ((match = raw.match(LINKY_URL_REGEXP))) {\n\t      // We can not end in these as they are sometimes found at the end of the sentence\n\t      url = match[0];\n\t      // if we did not match ftp/http/www/mailto then assume mailto\n\t      if (!match[2] && !match[4]) {\n\t        url = (match[3] ? 'http://' : 'mailto:') + url;\n\t      }\n\t      i = match.index;\n\t      addText(raw.substr(0, i));\n\t      addLink(url, match[0].replace(MAILTO_REGEXP, ''));\n\t      raw = raw.substring(i + match[0].length);\n\t    }\n\t    addText(raw);\n\t    return $sanitize(html.join(''));\n\t\n\t    function addText(text) {\n\t      if (!text) {\n\t        return;\n\t      }\n\t      html.push(sanitizeText(text));\n\t    }\n\t\n\t    function addLink(url, text) {\n\t      var key, linkAttributes = attributesFn(url);\n\t      html.push('<a ');\n\t\n\t      for (key in linkAttributes) {\n\t        html.push(key + '=\"' + linkAttributes[key] + '\" ');\n\t      }\n\t\n\t      if (isDefined(target) && !('target' in linkAttributes)) {\n\t        html.push('target=\"',\n\t                  target,\n\t                  '\" ');\n\t      }\n\t      html.push('href=\"',\n\t                url.replace(/\"/g, '&quot;'),\n\t                '\">');\n\t      addText(text);\n\t      html.push('</a>');\n\t    }\n\t  };\n\t}]);\n\t\n\t\n\t})(window, window.angular);\n\n\n/***/ },\n/* 9 */,\n/* 10 */,\n/* 11 */,\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _angularUiRouter = __webpack_require__(13);\n\t\n\tvar _angularUiRouter2 = _interopRequireDefault(_angularUiRouter);\n\t\n\t__webpack_require__(14);\n\t\n\tvar _oclazyload = __webpack_require__(15);\n\t\n\tvar _oclazyload2 = _interopRequireDefault(_oclazyload);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t$ProjectProvider.$inject = ['$futureStateProvider'];\n\tfunction $ProjectProvider($futureStateProvider) {\n\t  var _this = this;\n\t\n\t  /**\r\n\t   * @param {String} html 项目入口 html 模板\r\n\t   *\r\n\t   * @typedef {Object} ProjectInfo\r\n\t   * @prop {Array} scripts\r\n\t   * @prop {String} template\r\n\t   *\r\n\t   * @returns {ProjectInfo}\r\n\t   */\n\t  function getProjectInfo(html) {\n\t    var SCRIPT_TAG_REGEX = /<script\\s+((?!type=('|\")text\\/ng-template('|\")).)*>.*<\\/script>/gi;\n\t    var SCRIPT_SRC_REGEX = /.*\\ssrc=(\"|')(\\S+)\\1.*/;\n\t    var SCRIPT_SEQ_REGEX = /.*\\sseq=(\"|')(\\S+)\\1.*/;\n\t    var scripts = [];\n\t    var template = html.replace(SCRIPT_TAG_REGEX, function (match) {\n\t      var matchedScriptSeq = match.match(SCRIPT_SEQ_REGEX);\n\t      var matchedScriptSrc = match.match(SCRIPT_SRC_REGEX);\n\t      var seq = matchedScriptSeq && matchedScriptSeq[2] || 0;\n\t\n\t      scripts[seq] = scripts[seq] || [];\n\t\n\t      if (matchedScriptSrc && matchedScriptSrc[2]) {\n\t        scripts[seq].push(matchedScriptSrc[2]);\n\t      }\n\t\n\t      return '<!-- script replaced -->';\n\t    });\n\t\n\t    return {\n\t      scripts: scripts.filter(function (script) {\n\t        return !!script;\n\t      }),\n\t      template: template\n\t    };\n\t  }\n\t\n\t  stateFactory.$inject = ['$q', '$http', '$ocLazyLoad', '$log', 'futureState'];\n\t  function stateFactory($q, $http, $ocLazyLoad, $log, futureState) {\n\t\n\t    var loadScripts = function loadScripts(scripts) {\n\t      var errorHandle = function errorHandle(err) {\n\t        $log.error(err);\n\t        return $q.reject(err);\n\t      };\n\t      var promise = $ocLazyLoad.load(scripts.shift());\n\t      var nextGroup = void 0;\n\t\n\t      while (scripts.length) {\n\t        nextGroup = scripts.shift();\n\t        promise = promise.then(function () {\n\t          return $ocLazyLoad.load(nextGroup);\n\t        });\n\t      }\n\t\n\t      return promise.catch(errorHandle);\n\t    };\n\t\n\t    var deferred = $q.defer();\n\t\n\t    $http.get(futureState.templateUrl).then(function (response) {\n\t      var projectInfo = getProjectInfo(response.data);\n\t\n\t      var state = {\n\t        name: futureState.name,\n\t        url: futureState.url,\n\t        template: projectInfo.template\n\t      };\n\t\n\t      if (projectInfo.scripts.length) {\n\t        loadScripts(projectInfo.scripts).then(function () {\n\t          deferred.resolve(state);\n\t        });\n\t      } else {\n\t        deferred.resolve(state);\n\t      }\n\t    }).catch(function (err) {\n\t      console.error('Not found: ' + futureState.templateUrl, err);\n\t      deferred.reject(err);\n\t    });\n\t\n\t    return deferred.promise;\n\t  }\n\t\n\t  $futureStateProvider.stateFactory('project', stateFactory);\n\t\n\t  this.state = function (name, definition) {\n\t    $futureStateProvider.futureState({\n\t      type: 'project',\n\t      name: name,\n\t      url: definition.url,\n\t      templateUrl: definition.templateUrl\n\t    });\n\t\n\t    return _this;\n\t  };\n\t\n\t  this.$get = function () {};\n\t}\n\t\n\texports.default = angular.module('ccms.projectRouter', [_angularUiRouter2.default, 'ct.ui.router.extras', _oclazyload2.default]).provider('$project', $ProjectProvider).name;\n\n/***/ },\n/* 13 */,\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n\t * UI-Router Extras: Sticky states, Future States, Deep State Redirect, Transition promise\n\t * Monolithic build (all modules)\n\t * @version 0.1.3\n\t * @link http://christopherthielen.github.io/ui-router-extras/\n\t * @license MIT License, http://www.opensource.org/licenses/MIT\n\t */\n\t(function (root, factory) {\n\t    'use strict';\n\t\n\t    if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1)], __WEBPACK_AMD_DEFINE_RESULT__ = function (angular) {\n\t            factory(angular);\n\t        }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    } else if (typeof exports === 'object') {\n\t        factory(require('angular'));\n\t    } else {\n\t        factory(root.angular);\n\t    }\n\t}(this, function (angular, undefined) {\n\t    var mod_core = angular.module(\"ct.ui.router.extras.core\", [ \"ui.router\" ]);\n\t\n\tvar internalStates = {}, stateRegisteredCallbacks = [];\n\tmod_core.config([ '$stateProvider', '$injector', function ($stateProvider, $injector) {\n\t  // Decorate any state attribute in order to get access to the internal state representation.\n\t  $stateProvider.decorator('parent', function (state, parentFn) {\n\t    // Capture each internal UI-Router state representations as opposed to the user-defined state object.\n\t    // The internal state is, e.g., the state returned by $state.$current as opposed to $state.current\n\t    internalStates[state.self.name] = state;\n\t    // Add an accessor for the internal state from the user defined state\n\t    state.self.$$state = function () {\n\t      return internalStates[state.self.name];\n\t    };\n\t\n\t    angular.forEach(stateRegisteredCallbacks, function(callback) { callback(state); });\n\t    return parentFn(state);\n\t  });\n\t}]);\n\t\n\tvar DEBUG = false;\n\t\n\tvar forEach = angular.forEach;\n\tvar extend = angular.extend;\n\tvar isArray = angular.isArray;\n\t\n\tvar map = function (collection, callback) {\n\t  \"use strict\";\n\t  var result = [];\n\t  forEach(collection, function (item, index) {\n\t    result.push(callback(item, index));\n\t  });\n\t  return result;\n\t};\n\t\n\tvar keys = function (collection) {\n\t  \"use strict\";\n\t  return map(collection, function (collection, key) {\n\t    return key;\n\t  });\n\t};\n\t\n\tvar filter = function (collection, callback) {\n\t  \"use strict\";\n\t  var result = [];\n\t  forEach(collection, function (item, index) {\n\t    if (callback(item, index)) {\n\t      result.push(item);\n\t    }\n\t  });\n\t  return result;\n\t};\n\t\n\tvar filterObj = function (collection, callback) {\n\t  \"use strict\";\n\t  var result = {};\n\t  forEach(collection, function (item, index) {\n\t    if (callback(item, index)) {\n\t      result[index] = item;\n\t    }\n\t  });\n\t  return result;\n\t};\n\t\n\t// Duplicates code in UI-Router common.js\n\tfunction ancestors(first, second) {\n\t  var path = [];\n\t\n\t  for (var n in first.path) {\n\t    if (first.path[n] !== second.path[n]) break;\n\t    path.push(first.path[n]);\n\t  }\n\t  return path;\n\t}\n\t\n\t// Duplicates code in UI-Router common.js\n\tfunction objectKeys(object) {\n\t  if (Object.keys) {\n\t    return Object.keys(object);\n\t  }\n\t  var result = [];\n\t\n\t  angular.forEach(object, function (val, key) {\n\t    result.push(key);\n\t  });\n\t  return result;\n\t}\n\t\n\t/**\n\t * like objectKeys, but includes keys from prototype chain.\n\t * @param object the object whose prototypal keys will be returned\n\t * @param ignoreKeys an array of keys to ignore\n\t */\n\t// Duplicates code in UI-Router common.js\n\tfunction protoKeys(object, ignoreKeys) {\n\t  var result = [];\n\t  for (var key in object) {\n\t    if (!ignoreKeys || ignoreKeys.indexOf(key) === -1)\n\t      result.push(key);\n\t  }\n\t  return result;\n\t}\n\t\n\t// Duplicates code in UI-Router common.js\n\tfunction arraySearch(array, value) {\n\t  if (Array.prototype.indexOf) {\n\t    return array.indexOf(value, Number(arguments[2]) || 0);\n\t  }\n\t  var len = array.length >>> 0, from = Number(arguments[2]) || 0;\n\t  from = (from < 0) ? Math.ceil(from) : Math.floor(from);\n\t\n\t  if (from < 0) from += len;\n\t\n\t  for (; from < len; from++) {\n\t    if (from in array && array[from] === value) return from;\n\t  }\n\t  return -1;\n\t}\n\t\n\t// Duplicates code in UI-Router common.js\n\t// Added compatibility code  (isArray check) to support both 0.2.x and 0.3.x series of UI-Router.\n\tfunction inheritParams(currentParams, newParams, $current, $to) {\n\t  var parents = ancestors($current, $to), parentParams, inherited = {}, inheritList = [];\n\t\n\t  for (var i in parents) {\n\t    if (!parents[i].params) continue;\n\t    // This test allows compatibility with 0.2.x and 0.3.x (optional and object params)\n\t    parentParams = isArray(parents[i].params) ? parents[i].params : objectKeys(parents[i].params);\n\t    if (!parentParams.length) continue;\n\t\n\t    for (var j in parentParams) {\n\t      if (arraySearch(inheritList, parentParams[j]) >= 0) continue;\n\t      inheritList.push(parentParams[j]);\n\t      inherited[parentParams[j]] = currentParams[parentParams[j]];\n\t    }\n\t  }\n\t  return extend({}, inherited, newParams);\n\t}\n\t\n\tfunction inherit(parent, extra) {\n\t  return extend(new (extend(function () { }, {prototype: parent}))(), extra);\n\t}\n\t\n\tfunction onStateRegistered(callback) { stateRegisteredCallbacks.push(callback); }\n\t\n\tmod_core.provider(\"uirextras_core\", function() {\n\t  var core = {\n\t    internalStates: internalStates,\n\t    onStateRegistered: onStateRegistered,\n\t    forEach: forEach,\n\t    extend: extend,\n\t    isArray: isArray,\n\t    map: map,\n\t    keys: keys,\n\t    filter: filter,\n\t    filterObj: filterObj,\n\t    ancestors: ancestors,\n\t    objectKeys: objectKeys,\n\t    protoKeys: protoKeys,\n\t    arraySearch: arraySearch,\n\t    inheritParams: inheritParams,\n\t    inherit: inherit\n\t  };\n\t\n\t  angular.extend(this, core);\n\t\n\t  this.$get = function() {\n\t    return core;\n\t  };\n\t});\n\t\n\t\n\tvar ignoreDsr;\n\tfunction resetIgnoreDsr() {\n\t  ignoreDsr = undefined;\n\t}\n\t\n\t// Decorate $state.transitionTo to gain access to the last transition.options variable.\n\t// This is used to process the options.ignoreDsr option\n\tangular.module('ct.ui.router.extras.dsr', [ 'ct.ui.router.extras.core' ]).config([ \"$provide\", function ($provide) {\n\t  var $state_transitionTo;\n\t  $provide.decorator(\"$state\", ['$delegate', '$q', function ($state, $q) {\n\t    $state_transitionTo = $state.transitionTo;\n\t    $state.transitionTo = function (to, toParams, options) {\n\t      if (options && options.ignoreDsr) {\n\t        ignoreDsr = options.ignoreDsr;\n\t      }\n\t\n\t      return $state_transitionTo.apply($state, arguments).then(\n\t        function (result) {\n\t          resetIgnoreDsr();\n\t          return result;\n\t        },\n\t        function (err) {\n\t          resetIgnoreDsr();\n\t          return $q.reject(err);\n\t        }\n\t      );\n\t    };\n\t    return $state;\n\t  }]);\n\t}]);\n\t\n\tangular.module('ct.ui.router.extras.dsr').service(\"$deepStateRedirect\", [ '$rootScope', '$state', '$injector', function ($rootScope, $state, $injector) {\n\t  var lastSubstate = {};\n\t  var deepStateRedirectsByName = {};\n\t\n\t  var REDIRECT = \"Redirect\", ANCESTOR_REDIRECT = \"AncestorRedirect\";\n\t\n\t  function computeDeepStateStatus(state) {\n\t    var name = state.name;\n\t    if (deepStateRedirectsByName.hasOwnProperty(name))\n\t      return deepStateRedirectsByName[name];\n\t    recordDeepStateRedirectStatus(name);\n\t  }\n\t\n\t  function getConfig(state) {\n\t    var declaration = state.deepStateRedirect || state.dsr;\n\t    if (!declaration) return { dsr: false };\n\t    var dsrCfg = { dsr: true };\n\t\n\t    if (angular.isFunction(declaration)) {\n\t      dsrCfg.fn = declaration;\n\t    } else if (angular.isObject(declaration)) {\n\t      dsrCfg = angular.extend(dsrCfg, declaration);\n\t    }\n\t\n\t    if (angular.isString(dsrCfg['default'])) {\n\t      dsrCfg['default'] = { state: dsrCfg['default'] };\n\t    }\n\t\n\t    if (!dsrCfg.fn) {\n\t      dsrCfg.fn = [ '$dsr$', function($dsr$) {\n\t        return $dsr$.redirect.state != $dsr$.to.state;\n\t      } ];\n\t    }\n\t    return dsrCfg;\n\t  }\n\t\n\t  function recordDeepStateRedirectStatus(stateName) {\n\t    var state = $state.get(stateName);\n\t    if (!state) return false;\n\t    var cfg = getConfig(state);\n\t    if (cfg.dsr) {\n\t      deepStateRedirectsByName[state.name] = REDIRECT;\n\t      if (lastSubstate[stateName] === undefined)\n\t        lastSubstate[stateName] = {};\n\t    }\n\t\n\t    var parent = state.$$state && state.$$state().parent;\n\t    if (parent) {\n\t      var parentStatus = recordDeepStateRedirectStatus(parent.self.name);\n\t      if (parentStatus && deepStateRedirectsByName[state.name] === undefined) {\n\t        deepStateRedirectsByName[state.name] = ANCESTOR_REDIRECT;\n\t      }\n\t    }\n\t    return deepStateRedirectsByName[state.name] || false;\n\t  }\n\t\n\t  function getMatchParams(params, dsrParams) {\n\t    if (dsrParams === true) dsrParams = Object.keys(params);\n\t    if (dsrParams === null || dsrParams === undefined) dsrParams = [];\n\t\n\t    var matchParams = {};\n\t    angular.forEach(dsrParams.sort(), function(name) { matchParams[name] = params[name]; });\n\t    return matchParams;\n\t  }\n\t\n\t  function getParamsString(params, dsrParams) {\n\t    var matchParams = getMatchParams(params, dsrParams);\n\t    function safeString(input) { return !input ? input : input.toString(); }\n\t    var paramsToString = {};\n\t    angular.forEach(matchParams, function(val, name) { paramsToString[name] = safeString(val); });\n\t    return angular.toJson(paramsToString);\n\t  }\n\t\n\t  $rootScope.$on(\"$stateChangeStart\", function (event, toState, toParams, fromState, fromParams) {\n\t    var cfg = getConfig(toState);\n\t    if (ignoreDsr || (computeDeepStateStatus(toState) !== REDIRECT) && !cfg['default']) return;\n\t    // We're changing directly to one of the redirect (tab) states.\n\t    // Get the DSR key for this state by calculating the DSRParams option\n\t    var key = getParamsString(toParams, cfg.params);\n\t    var redirect = lastSubstate[toState.name][key] || cfg['default'];\n\t    if (!redirect) return;\n\t\n\t    // we have a last substate recorded\n\t    var $dsr$ = { redirect: { state: redirect.state, params: redirect.params}, to: { state: toState.name, params: toParams } };\n\t    var result = $injector.invoke(cfg.fn, toState, { $dsr$: $dsr$ });\n\t    if (!result) return;\n\t    if (result.state) redirect = result;\n\t    event.preventDefault();\n\t    var redirectParams = getMatchParams(toParams, cfg.params);\n\t    $state.go(redirect.state, angular.extend(redirectParams, redirect.params));\n\t  });\n\t\n\t  $rootScope.$on(\"$stateChangeSuccess\", function (event, toState, toParams, fromState, fromParams) {\n\t    var deepStateStatus = computeDeepStateStatus(toState);\n\t    if (deepStateStatus) {\n\t      var name = toState.name;\n\t      angular.forEach(lastSubstate, function (redirect, dsrState) {\n\t        // update Last-SubState&params for each DSR that this transition matches.\n\t        var cfg = getConfig($state.get(dsrState));\n\t        var key = getParamsString(toParams, cfg.params);\n\t        if (toState.$$state().includes[dsrState]) {\n\t          lastSubstate[dsrState][key] = { state: name, params: angular.copy(toParams) };\n\t        }\n\t      });\n\t    }\n\t  });\n\t\n\t  return {\n\t    getRedirect: function(dsrState, params) {\n\t      var state = $state.get(dsrState);\n\t      computeDeepStateStatus(state)\n\t      var cfg = getConfig(state);\n\t      var key = getParamsString(params, cfg.params);\n\t      var redirect = lastSubstate[state.name];\n\t      if (redirect && redirect[key]) {\n\t        redirect = redirect[key];\n\t      } else {\n\t        redirect = cfg['default'];\n\t      }\n\t      return redirect;\n\t    },\n\t    reset: function(stateOrName, params) {\n\t      if (!stateOrName) {\n\t        angular.forEach(lastSubstate, function(redirect, dsrState) { lastSubstate[dsrState] = {}; });\n\t      } else {\n\t        var state = $state.get(stateOrName);\n\t        if (!state) throw new Error(\"Unknown state: \" + stateOrName);\n\t        if (lastSubstate[state.name]) {\n\t          if (params) {\n\t            var key = getParamsString(params, getConfig(state).params);\n\t            delete lastSubstate[state.name][key];\n\t          } else {\n\t            lastSubstate[state.name] = {};\n\t          }\n\t        }\n\t      }\n\t    }\n\t  };\n\t}]);\n\t\n\tangular.module('ct.ui.router.extras.dsr').run(['$deepStateRedirect', function ($deepStateRedirect) {\n\t  // Make sure $deepStateRedirect is instantiated\n\t}]);\n\t\n\tangular.module(\"ct.ui.router.extras.sticky\", [ 'ct.ui.router.extras.core' ]);\n\t\n\tvar mod_sticky = angular.module(\"ct.ui.router.extras.sticky\");\n\t\n\t$StickyStateProvider.$inject = [ '$stateProvider', 'uirextras_coreProvider' ];\n\tfunction $StickyStateProvider($stateProvider, uirextras_coreProvider) {\n\t  var core = uirextras_coreProvider;\n\t  var inheritParams = core.inheritParams;\n\t  var objectKeys = core.objectKeys;\n\t  var protoKeys = core.protoKeys;\n\t  var forEach = core.forEach;\n\t  var map = core.map;\n\t\n\t  // Holds all the states which are inactivated.  Inactivated states can be either sticky states, or descendants of sticky states.\n\t  var inactiveStates = {}; // state.name -> (state)\n\t  var stickyStates = {}; // state.name -> true\n\t  var $state;\n\t  var DEBUG = false;\n\t\n\t  // Called by $stateProvider.registerState();\n\t  // registers a sticky state with $stickyStateProvider\n\t  this.registerStickyState = function (state) {\n\t    stickyStates[state.name] = state;\n\t    // console.log(\"Registered sticky state: \", state);\n\t  };\n\t\n\t  this.enableDebug = this.debugMode = function (enabled) {\n\t    if (angular.isDefined(enabled))\n\t      DEBUG = enabled;\n\t    return DEBUG;\n\t  };\n\t\n\t  this.$get = [  '$rootScope', '$state', '$stateParams', '$injector', '$log',\n\t    function ($rootScope, $state, $stateParams, $injector, $log) {\n\t      // Each inactive states is either a sticky state, or a child of a sticky state.\n\t      // This function finds the closest ancestor sticky state, then find that state's parent.\n\t      // Map all inactive states to their closest parent-to-sticky state.\n\t      function mapInactives() {\n\t        var mappedStates = {};\n\t        angular.forEach(inactiveStates, function (state, name) {\n\t          var stickyAncestors = getStickyStateStack(state);\n\t          for (var i = 0; i < stickyAncestors.length; i++) {\n\t            var parent = stickyAncestors[i].parent;\n\t            mappedStates[parent.name] = mappedStates[parent.name] || [];\n\t            mappedStates[parent.name].push(state);\n\t          }\n\t          if (mappedStates['']) {\n\t            // This is necessary to compute Transition.inactives when there are sticky states are children to root state.\n\t            mappedStates['__inactives'] = mappedStates[''];  // jshint ignore:line\n\t          }\n\t        });\n\t        return mappedStates;\n\t      }\n\t\n\t      function mapInactivesByImmediateParent() {\n\t        var inactivesByAllParents ={};\n\t        forEach(inactiveStates, function(state) {\n\t          forEach(state.path, function(ancestor) {\n\t            if (ancestor === state) return;\n\t            inactivesByAllParents[ancestor.name] = inactivesByAllParents[ancestor.name] || [];\n\t            inactivesByAllParents[ancestor.name].push(state);\n\t          });\n\t        });\n\t        return inactivesByAllParents;\n\t      }\n\t\n\t      // Given a state, returns all ancestor states which are sticky.\n\t      // Walks up the view's state's ancestry tree and locates each ancestor state which is marked as sticky.\n\t      // Returns an array populated with only those ancestor sticky states.\n\t      function getStickyStateStack(state) {\n\t        var stack = [];\n\t        if (!state) return stack;\n\t        do {\n\t          if (state.sticky) stack.push(state);\n\t          state = state.parent;\n\t        } while (state);\n\t        stack.reverse();\n\t        return stack;\n\t      }\n\t\n\t      // Returns a sticky transition type necessary to enter the state.\n\t      // Transition can be: reactivate, reload, or enter\n\t\n\t      // Note: if a state is being reactivated but params dont match, we treat\n\t      // it as a Exit/Enter, thus the special \"reload\" transition.\n\t      // If a parent inactivated state has \"reload\" transition type, then\n\t      // all descendant states must also be exit/entered, thus the first line of this function.\n\t      function getEnterTransition(state, stateParams, reloadStateTree, ancestorReloaded) {\n\t        if (ancestorReloaded) return \"reload\";\n\t        var inactiveState = inactiveStates[state.self.name];\n\t        if (!inactiveState) return \"enter\";\n\t        if (state.self === reloadStateTree) return \"reload\";\n\t        var paramsMatch = paramsEqualForState(state.ownParams, stateParams, inactiveState.locals.globals.$stateParams);\n\t        return paramsMatch ? \"reactivate\" : \"reload\";\n\t      }\n\t\n\t      // Given a state and (optional) stateParams, returns the inactivated state from the inactive sticky state registry.\n\t      function getInactivatedState(state, stateParams) {\n\t        var inactiveState = inactiveStates[state.name];\n\t        if (!inactiveState) return null;\n\t        if (!stateParams) return inactiveState;\n\t        var paramsMatch = paramsEqualForState(state.ownParams, stateParams, inactiveState.locals.globals.$stateParams);\n\t        return paramsMatch ? inactiveState : null;\n\t      }\n\t\n\t      function paramsEqualForState(ownParams, stateParams, stateParams2) {\n\t        if (typeof ownParams.$$equals === 'function')\n\t          return ownParams.$$equals(stateParams, stateParams2);\n\t        return equalForKeys(stateParams, stateParams2, ownParams);\n\t      }\n\t\n\t      // Duplicates logic in $state.transitionTo, primarily to find the pivot state (i.e., the \"keep\" value)\n\t      function equalForKeys(a, b, keys) {\n\t        if (!angular.isArray(keys) && angular.isObject(keys)) {\n\t          keys = protoKeys(keys, [\"$$keys\", \"$$values\", \"$$equals\", \"$$validates\", \"$$new\", \"$$parent\"]);\n\t        }\n\t        if (!keys) {\n\t          keys = [];\n\t          for (var n in a) keys.push(n); // Used instead of Object.keys() for IE8 compatibility\n\t        }\n\t\n\t        for (var i = 0; i < keys.length; i++) {\n\t          var k = keys[i];\n\t          if (a[k] != b[k]) return false; // Not '===', values aren't necessarily normalized\n\t        }\n\t        return true;\n\t      }\n\t\n\t      function calcTreeChanges(transition) {\n\t        var fromPath = transition.fromState.path;\n\t        var toPath = transition.toState.path;\n\t        var toParams = transition.toParams;\n\t        var keep = 0, state = toPath[keep];\n\t\n\t        if (transition.options && transition.options.inherit) {\n\t          toParams = transition.toParams =\n\t              inheritParams($stateParams, toParams || {}, $state.$current, transition.toState);\n\t        }\n\t\n\t        while (state && state === fromPath[keep] && paramsEqualForState(state.ownParams, toParams, transition.fromParams)) {\n\t          // We're \"keeping\" this state. bump keep var and get the next state in toPath for the next iteration.\n\t          state = toPath[++keep];\n\t        }\n\t\n\t        return {\n\t          keep: keep,\n\t          retained: fromPath.slice(0, keep),\n\t          exiting: fromPath.slice(keep),\n\t          entering: toPath.slice(keep)\n\t        };\n\t      }\n\t\n\t      function sortByStateDepth(a,b) {\n\t        return a.name.split(\".\").length - b.name.split(\".\").length;\n\t      }\n\t\n\t      var stickySupport = {\n\t        getInactiveStates: function () {\n\t          return map(inactiveStates, angular.identity).sort(sortByStateDepth);\n\t        },\n\t        getInactiveStatesByParent: function () {\n\t          return mapInactives();\n\t        },\n\t        // Main API for $stickyState, used by $state.\n\t        // Processes a potential transition, returns an object with the following attributes:\n\t        // {\n\t        //    keep: The number of states being \"kept\"\n\t        //    inactives: Array of all states which will be inactive if the transition is completed.\n\t        //    reactivatingStates: Array of all states which will be reactivated if the transition is completed.\n\t        //    orphans: Array of previously inactive states, which are being orphaned by the transition\n\t        //        Note: Transitioning directly to an inactive state with inactive children will reactivate the state, but exit all the inactive children.\n\t        //    enter: Enter transition type for all added states.  This is a parallel array to \"toStates\" array in $state.transitionTo.\n\t        //    exit: Exit transition type for all removed states.  This is a parallel array to \"fromStates\" array in $state.transitionTo.\n\t        // }\n\t        processTransition: function (transition) {\n\t          var treeChanges = calcTreeChanges(transition);\n\t          var currentInactives = stickySupport.getInactiveStates();\n\t          var futureInactives, exitingTypes, enteringTypes;\n\t          var keep = treeChanges.keep;\n\t\n\t\n\t          /////////////////////////////////////////\n\t          // helper functions\n\t          function notIn(array) { return function (elem) { return array.indexOf(elem) === -1; }; }\n\t          function flattenReduce(memo, list) { return memo.concat(list); }\n\t          function uniqReduce(memo, orphan) { if (notIn(memo)(orphan)) memo.push(orphan); return memo; }\n\t          function prop(attr) { return function(obj) { return obj[attr]; } }\n\t          function typeIs(type) { return function(obj) { return obj.type === type; } }\n\t          function isChildOf(state) { return function(other) { return other.parent === state; }; }\n\t          var notEntering = notIn(treeChanges.entering);\n\t          function notSticky(state) { return !state.sticky; }\n\t          ////////////////////////////////////\n\t\n\t\n\t          // Calculate the \"exit\" transition types for states being exited in fromPath\n\t          // Exit types will be either \"inactivate\" or \"exit\"\n\t          // Two things must be satisfied in order to inactivate the \"exiting\" states (instead of exit them):\n\t          // - The first element of the exiting path must be sticky\n\t          // - We must be entering any sibling state of the sticky (we can check this using entering.length)\n\t          var shouldInactivate = treeChanges.exiting[0] && treeChanges.exiting[0].sticky && treeChanges.entering.length > 0;\n\t          exitingTypes = treeChanges.exiting.map(function (state) {\n\t              var stateRentering = treeChanges.entering.indexOf(state) !== -1;\n\t              var type = shouldInactivate && !stateRentering ? \"inactivate\" : \"exit\";\n\t              return { type: type, state: state };\n\t          });\n\t\n\t\n\t          // Calculate the \"enter\" transition types for states being entered in toPath\n\t          // Enter types will be either \"enter\", \"reactivate\", or \"reload\" where:\n\t          //   enter: full resolve, no special logic\n\t          //   reactivate: use previous locals\n\t          //   reload: like 'enter', except exit the inactive state before entering it.\n\t          var reloaded = transition.options && !!transition.options.reload;\n\t          enteringTypes = treeChanges.entering.map(function(state) {\n\t            var type = getEnterTransition(state, transition.toParams, transition.reloadStateTree, reloaded);\n\t            reloaded = reloaded || type === 'reload';\n\t            return { type: type, state: state };\n\t          });\n\t\n\t          // Find all the \"orphaned\" states.  those states that are :\n\t          //  - are siblings of the entering states\n\t          //  - previously inactive\n\t          //  - are not being reactivated (entered)\n\t          //  - are not sticky\n\t          // unioned with:\n\t          //  - children of the toState\n\t          //  - previously inactive\n\t          //\n\t          // Given:\n\t          //   - states A (sticky: true), B, A.foo, A.bar\n\t          //   - A.foo is currently inactive\n\t          //   - B is currently active\n\t          // Orphan case 1)\n\t          //   - Transition to A.bar orphans the inactive state A.foo; it should be exited\n\t          // Orphan case 2)\n\t          //   - Transition directly to A orphans the inactive state A.foo; it should be exited\n\t          //\n\t          // Given:\n\t          //   - states A (sticky: true), B, A.foo (sticky), A.bar\n\t          //   - A.foo is currently inactive\n\t          //   - B is currently active\n\t          // Orphan case 3)\n\t          //   - Transition directly to A orphans the inactive sticky state A.foo; it should be exited\n\t          // Note: transition from B to A.bar does not orphan A.foo\n\t          // Note 2: each orphaned state might be the parent of a larger inactive subtree.\n\t          var orphanedRoots = treeChanges.entering\n\t              // For each entering state in the path, find all sibling states which are currently inactive\n\t              .map(function (entering) { return currentInactives.filter(isChildOf(entering.parent)); })\n\t              // Flatten nested arrays. Now we have an array of inactive states that are children of the ones being entered.\n\t              .reduce(flattenReduce, [])\n\t              // Consider \"orphaned\": only those children that are themselves not currently being entered\n\t              .filter(notEntering)\n\t              // Consider \"orphaned\": only those children that are not themselves sticky states.\n\t              .filter(notSticky)\n\t              // Finally, union that set with any inactive children of the \"to state\"\n\t              .concat(currentInactives.filter(isChildOf(transition.toState)));\n\t\n\t          var currentInactivesByParent = mapInactivesByImmediateParent();\n\t          var allOrphans = orphanedRoots\n\t              .map(function(root) { return currentInactivesByParent[root.name] })\n\t              .filter(angular.isDefined)\n\t              .reduce(flattenReduce, [])\n\t              .concat(orphanedRoots)\n\t              // Sort by depth to exit orphans in proper order\n\t              .sort(sortByStateDepth);\n\t\n\t          // Add them to the list of states being exited.\n\t          var exitOrOrphaned = exitingTypes\n\t              .filter(typeIs(\"exit\"))\n\t              .map(prop(\"state\"))\n\t              .concat(allOrphans);\n\t\n\t          // Now calculate the states that will be inactive if this transition succeeds.\n\t          // We have already pushed the transitionType == \"inactivate\" states to 'inactives'.\n\t          // Second, add all the existing inactive states\n\t          futureInactives = currentInactives\n\t              .filter(notIn(exitOrOrphaned))\n\t              .filter(notIn(treeChanges.entering))\n\t              .concat(exitingTypes.filter(typeIs(\"inactivate\")).map(prop(\"state\")))\n\t              .sort(sortByStateDepth);\n\t\n\t          return {\n\t            keep: keep,\n\t            enter: new Array(keep).concat(enteringTypes.map(prop(\"type\"))),\n\t            exit: new Array(keep).concat(exitingTypes.map(prop(\"type\"))),\n\t            inactives: futureInactives,\n\t            reactivatingStates: enteringTypes.filter(typeIs(\"reactivate\")).map(prop(\"state\")),\n\t            orphans: allOrphans\n\t          };\n\t        },\n\t\n\t        // Adds a state to the inactivated sticky state registry.\n\t        stateInactivated: function (state) {\n\t          // Keep locals around.\n\t          inactiveStates[state.self.name] = state;\n\t          // Notify states they are being Inactivated (i.e., a different\n\t          // sticky state tree is now active).\n\t          state.self.status = 'inactive';\n\t          if (state.self.onInactivate)\n\t            $injector.invoke(state.self.onInactivate, state.self, state.locals.globals);\n\t        },\n\t\n\t        // Removes a previously inactivated state from the inactive sticky state registry\n\t        stateReactivated: function (state) {\n\t          if (inactiveStates[state.self.name]) {\n\t            delete inactiveStates[state.self.name];\n\t          }\n\t          state.self.status = 'entered';\n\t//        if (state.locals == null || state.locals.globals == null) debugger;\n\t          if (state.self.onReactivate)\n\t            $injector.invoke(state.self.onReactivate, state.self, state.locals.globals);\n\t        },\n\t\n\t        // Exits all inactivated descendant substates when the ancestor state is exited.\n\t        // When transitionTo is exiting a state, this function is called with the state being exited.  It checks the\n\t        // registry of inactivated states for descendants of the exited state and also exits those descendants.  It then\n\t        // removes the locals and de-registers the state from the inactivated registry.\n\t        stateExiting: function (exiting, exitQueue, onExit) {\n\t          var exitingNames = {};\n\t          angular.forEach(exitQueue, function (state) {\n\t            exitingNames[state.self.name] = true;\n\t          });\n\t\n\t          angular.forEach(inactiveStates, function (inactiveExiting, name) {\n\t            // TODO: Might need to run the inactivations in the proper depth-first order?\n\t            if (!exitingNames[name] && inactiveExiting.includes[exiting.name]) {\n\t              if (DEBUG) $log.debug(\"Exiting \" + name + \" because it's a substate of \" + exiting.name + \" and wasn't found in \", exitingNames);\n\t              if (inactiveExiting.self.onExit)\n\t                $injector.invoke(inactiveExiting.self.onExit, inactiveExiting.self, inactiveExiting.locals.globals);\n\t              angular.forEach(inactiveExiting.locals, function(localval, key) {\n\t                delete inactivePseudoState.locals[key];\n\t              });\n\t              inactiveExiting.locals = null;\n\t              inactiveExiting.self.status = 'exited';\n\t              delete inactiveStates[name];\n\t            }\n\t          });\n\t\n\t          if (onExit)\n\t            $injector.invoke(onExit, exiting.self, exiting.locals.globals);\n\t          exiting.locals = null;\n\t          exiting.self.status = 'exited';\n\t          delete inactiveStates[exiting.self.name];\n\t        },\n\t\n\t        // Removes a previously inactivated state from the inactive sticky state registry\n\t        stateEntering: function (entering, params, onEnter, updateParams) {\n\t          var inactivatedState = getInactivatedState(entering);\n\t          if (inactivatedState && (updateParams || !getInactivatedState(entering, params))) {\n\t            var savedLocals = entering.locals;\n\t            this.stateExiting(inactivatedState);\n\t            entering.locals = savedLocals;\n\t          }\n\t          entering.self.status = 'entered';\n\t\n\t          if (onEnter)\n\t            $injector.invoke(onEnter, entering.self, entering.locals.globals);\n\t        },\n\t        reset: function reset(inactiveState, params) {\n\t          function resetOne(state) { stickySupport.reset(state); }\n\t          if (inactiveState === \"*\") {\n\t            angular.forEach(stickySupport.getInactiveStates(), resetOne);\n\t            return true;\n\t          }\n\t          var state = $state.get(inactiveState);\n\t          if (!state) return false;\n\t          var exiting = getInactivatedState(state, params);\n\t          if (!exiting) return false;\n\t          stickySupport.stateExiting(exiting);\n\t          $rootScope.$broadcast(\"$viewContentLoading\");\n\t          return true;\n\t        }\n\t      };\n\t\n\t      return stickySupport;\n\t    }];\n\t}\n\t\n\tmod_sticky.provider(\"$stickyState\", $StickyStateProvider);\n\t\n\t/**\n\t * Sticky States makes entire state trees \"sticky\". Sticky state trees are retained until their parent state is\n\t * exited. This can be useful to allow multiple modules, peers to each other, each module having its own independent\n\t * state tree.  The peer modules can be activated and inactivated without any loss of their internal context, including\n\t * DOM content such as unvalidated/partially filled in forms, and even scroll position.\n\t *\n\t * DOM content is retained by declaring a named ui-view in the parent state, and filling it in with a named view from the\n\t * sticky state.\n\t *\n\t * Technical overview:\n\t *\n\t * ---PATHS---\n\t * UI-Router uses state paths to manage entering and exiting of individual states.  Each state \"A.B.C.X\" has its own path, starting\n\t * from the root state (\"\") and ending at the state \"X\".  The path is composed the final state \"X\"'s ancestors, e.g.,\n\t * [ \"\", \"A\", \"B\", \"C\", \"X\" ].\n\t *\n\t * When a transition is processed, the previous path (fromState.path) is compared with the requested destination path\n\t * (toState.path).  All states that the from and to paths have in common are \"kept\" during the transition.  The last\n\t * \"kept\" element in the path is the \"pivot\".\n\t *\n\t * ---VIEWS---\n\t * A View in UI-Router consists of a controller and a template.  Each view belongs to one state, and a state can have many\n\t * views.  Each view plugs into a ui-view element in the DOM of one of the parent state's view(s).\n\t *\n\t * View context is managed in UI-Router using a 'state locals' concept. When a state's views are fully loaded, those views\n\t * are placed on the states 'locals' object.  Each locals object prototypally inherits from its parent state's locals object.\n\t * This means that state \"A.B.C.X\"'s locals object also has all of state \"A.B.C\"'s locals as well as those from \"A.B\" and \"A\".\n\t * The root state (\"\") defines no views, but it is included in the protypal inheritance chain.\n\t *\n\t * The locals object is used by the ui-view directive to load the template, render the content, create the child scope,\n\t * initialize the controller, etc.  The ui-view directives caches the locals in a closure variable.  If the locals are\n\t * identical (===), then the ui-view directive exits early, and does no rendering.\n\t *\n\t * In stock UI-Router, when a state is exited, that state's locals object is deleted and those views are cleaned up by\n\t * the ui-view directive shortly.\n\t *\n\t * ---Sticky States---\n\t * UI-Router Extras keeps views for inactive states live, even when UI-Router thinks it has exited them.  It does this\n\t * by creating a pseudo state called \"__inactives\" that is the parent of the root state.  It also then defines a locals\n\t * object on the \"__inactives\" state, which the root state protoypally inherits from.  By doing this, views for inactive\n\t * states are accessible through locals object's protoypal inheritance chain from any state in the system.\n\t *\n\t * ---Transitions---\n\t * UI-Router Extras decorates the $state.transitionTo function.  While a transition is in progress, the toState and\n\t * fromState internal state representations are modified in order to coerce stock UI-Router's transitionTo() into performing\n\t * the appropriate operations.  When the transition promise is completed, the original toState and fromState values are\n\t * restored.\n\t *\n\t * Stock UI-Router's $state.transitionTo function uses toState.path and fromState.path to manage entering and exiting\n\t * states.  UI-Router Extras takes advantage of those internal implementation details and prepares a toState.path and\n\t * fromState.path which coerces UI-Router into entering and exiting the correct states, or more importantly, not entering\n\t * and not exiting inactive or sticky states.  It also replaces state.self.onEnter and state.self.onExit for elements in\n\t * the paths when they are being inactivated or reactivated.\n\t */\n\t\n\t\n\t\n\t// ------------------------ Sticky State module-level variables -----------------------------------------------\n\tvar _StickyState; // internal reference to $stickyStateProvider\n\tvar internalStates = {}; // Map { statename -> InternalStateObj } holds internal representation of all states\n\tvar root, // Root state, internal representation\n\t  pendingTransitions = [], // One transition may supersede another.  This holds references to all pending transitions\n\t  pendingRestore, // The restore function from the superseded transition\n\t  inactivePseudoState, // This pseudo state holds all the inactive states' locals (resolved state data, such as views etc)\n\t  reactivatingLocals = { }, // This is a prent locals to the inactivePseudoState locals, used to hold locals for states being reactivated\n\t  versionHeuristics = { // Heuristics used to guess the current UI-Router Version\n\t    hasParamSet: false\n\t  };\n\t\n\t// Creates a blank surrogate state\n\tfunction SurrogateState(type) {\n\t  return {\n\t    resolve: { },\n\t    locals: {\n\t      globals: root && root.locals && root.locals.globals\n\t    },\n\t    views: { },\n\t    self: { },\n\t    params: { },\n\t    ownParams: ( versionHeuristics.hasParamSet ? { $$equals: function() { return true; } } : []),\n\t    surrogateType: type\n\t  };\n\t}\n\t\n\t// ------------------------ Sticky State registration and initialization code ----------------------------------\n\t// Grab a copy of the $stickyState service for use by the transition management code\n\tangular.module(\"ct.ui.router.extras.sticky\").run([\"$stickyState\", function ($stickyState) {\n\t  _StickyState = $stickyState;\n\t}]);\n\t\n\tangular.module(\"ct.ui.router.extras.sticky\").config(\n\t  [ \"$provide\", \"$stateProvider\", '$stickyStateProvider', '$urlMatcherFactoryProvider', 'uirextras_coreProvider',\n\t    function ($provide, $stateProvider, $stickyStateProvider, $urlMatcherFactoryProvider, uirextras_coreProvider) {\n\t      var core = uirextras_coreProvider;\n\t      var internalStates = core.internalStates;\n\t      var inherit = core.inherit;\n\t      var inheritParams = core.inheritParams;\n\t      var forEach = core.forEach;\n\t      var map = core.map;\n\t      var filterObj = core.filterObj;\n\t\n\t      versionHeuristics.hasParamSet = !!$urlMatcherFactoryProvider.ParamSet;\n\t      // inactivePseudoState (__inactives) holds all the inactive locals which includes resolved states data, i.e., views, scope, etc\n\t      inactivePseudoState = angular.extend(new SurrogateState(\"__inactives\"), { self: {  name: '__inactives'  } });\n\t      // Reset other module scoped variables.  This is to primarily to flush any previous state during karma runs.\n\t      root = pendingRestore = undefined;\n\t      pendingTransitions = [];\n\t\n\t      uirextras_coreProvider.onStateRegistered(function(state) {\n\t        // Register the ones marked as \"sticky\"\n\t        if (state.self.sticky === true) {\n\t          $stickyStateProvider.registerStickyState(state.self);\n\t        }\n\t      });\n\t\n\t      var $state_transitionTo; // internal reference to the real $state.transitionTo function\n\t      // Decorate the $state service, so we can decorate the $state.transitionTo() function with sticky state stuff.\n\t      $provide.decorator(\"$state\", ['$delegate', '$log', '$q', function ($state, $log, $q) {\n\t        // Note: this code gets run only on the first state that is decorated\n\t        root = $state.$current;\n\t        internalStates[\"\"] = root;\n\t        root.parent = inactivePseudoState; // Make inactivePsuedoState the parent of root.  \"wat\"\n\t        inactivePseudoState.parent = undefined; // Make inactivePsuedoState the real root.\n\t        // Add another locals bucket, as a parent to inactivatePseudoState locals.\n\t        // This is for temporary storage of locals of states being reactivated while a transition is pending\n\t        // This is necessary in some cases where $viewContentLoading is triggered before the $state.$current is updated to the toState.\n\t        inactivePseudoState.locals = inherit(reactivatingLocals, inactivePseudoState.locals);\n\t        root.locals = inherit(inactivePseudoState.locals, root.locals); // make root locals extend the __inactives locals.\n\t        delete inactivePseudoState.locals.globals;\n\t\n\t        // Hold on to the real $state.transitionTo in a module-scope variable.\n\t        $state_transitionTo = $state.transitionTo;\n\t\n\t        // ------------------------ Decorated transitionTo implementation begins here ---------------------------\n\t        $state.transitionTo = function (to, toParams, options) {\n\t          var DEBUG = $stickyStateProvider.debugMode();\n\t          // TODO: Move this to module.run?\n\t          // TODO: I'd rather have root.locals prototypally inherit from inactivePseudoState.locals\n\t          // Link root.locals and inactives.locals.  Do this at runtime, after root.locals has been set.\n\t          if (!inactivePseudoState.locals)\n\t            inactivePseudoState.locals = root.locals;\n\t          var idx = pendingTransitions.length;\n\t          if (pendingRestore) {\n\t            pendingRestore();\n\t            if (DEBUG) {\n\t              $log.debug(\"Restored paths from pending transition\");\n\t            }\n\t          }\n\t\n\t          var fromState = $state.$current, fromParams = $state.params;\n\t          var rel = options && options.relative || $state.$current; // Not sure if/when $state.$current is appropriate here.\n\t          var toStateSelf = $state.get(to, rel); // exposes findState relative path functionality, returns state.self\n\t          var savedToStatePath, savedFromStatePath, stickyTransitions;\n\t          var reactivated = [], exited = [], terminalReactivatedState;\n\t          toParams = toParams || {};\n\t          arguments[1] = toParams;\n\t\n\t          var noop = function () {\n\t          };\n\t          // Sticky states works by modifying the internal state objects of toState and fromState, especially their .path(s).\n\t          // The restore() function is a closure scoped function that restores those states' definitions to their original values.\n\t          var restore = function () {\n\t            if (savedToStatePath) {\n\t              toState.path = savedToStatePath;\n\t              savedToStatePath = null;\n\t            }\n\t\n\t            if (savedFromStatePath) {\n\t              fromState.path = savedFromStatePath;\n\t              savedFromStatePath = null;\n\t            }\n\t\n\t            angular.forEach(restore.restoreFunctions, function (restoreFunction) {\n\t              restoreFunction();\n\t            });\n\t            // Restore is done, now set the restore function to noop in case it gets called again.\n\t            restore = noop;\n\t            // pendingRestore keeps track of a transition that is in progress.  It allows the decorated transitionTo\n\t            // method to be re-entrant (for example, when superceding a transition, i.e., redirect).  The decorated\n\t            // transitionTo checks right away if there is a pending transition in progress and restores the paths\n\t            // if so using pendingRestore.\n\t            pendingRestore = null;\n\t            pendingTransitions.splice(idx, 1); // Remove this transition from the list\n\t          };\n\t\n\t          // All decorated transitions have their toState.path and fromState.path replaced.  Surrogate states also make\n\t          // additional changes to the states definition before handing the transition off to UI-Router. In particular,\n\t          // certain types of surrogate states modify the state.self object's onEnter or onExit callbacks.\n\t          // Those surrogate states must then register additional restore steps using restore.addRestoreFunction(fn)\n\t          restore.restoreFunctions = [];\n\t          restore.addRestoreFunction = function addRestoreFunction(fn) {\n\t            this.restoreFunctions.push(fn);\n\t          };\n\t\n\t\n\t          // --------------------- Surrogate State Functions ------------------------\n\t          // During a transition, the .path arrays in toState and fromState are replaced.  Individual path elements\n\t          // (states) which aren't being \"kept\" are replaced with surrogate elements (states).  This section of the code\n\t          // has factory functions for all the different types of surrogate states.\n\t\n\t\n\t          function stateReactivatedSurrogatePhase1(state) {\n\t            var surrogate = angular.extend(new SurrogateState(\"reactivate_phase1\"), { locals: state.locals });\n\t            surrogate.self = angular.extend({}, state.self);\n\t            return surrogate;\n\t          }\n\t\n\t          function stateReactivatedSurrogatePhase2(state) {\n\t            var surrogate = angular.extend(new SurrogateState(\"reactivate_phase2\"), state);\n\t            var oldOnEnter = surrogate.self.onEnter;\n\t            surrogate.resolve = {}; // Don't re-resolve when reactivating states (fixes issue #22)\n\t            // TODO: Not 100% sure if this is necessary.  I think resolveState will load the views if I don't do this.\n\t            surrogate.views = {}; // Don't re-activate controllers when reactivating states (fixes issue #22)\n\t            surrogate.self.onEnter = function () {\n\t              // ui-router sets locals on the surrogate to a blank locals (because we gave it nothing to resolve)\n\t              // Re-set it back to the already loaded state.locals here.\n\t              surrogate.locals = state.locals;\n\t              _StickyState.stateReactivated(state);\n\t            };\n\t            restore.addRestoreFunction(function () {\n\t              state.self.onEnter = oldOnEnter;\n\t            });\n\t            return surrogate;\n\t          }\n\t\n\t          function stateInactivatedSurrogate(state) {\n\t            var surrogate = new SurrogateState(\"inactivate\");\n\t            surrogate.self = state.self;\n\t            var oldOnExit = state.self.onExit;\n\t            surrogate.self.onExit = function () {\n\t              _StickyState.stateInactivated(state);\n\t            };\n\t            restore.addRestoreFunction(function () {\n\t              state.self.onExit = oldOnExit;\n\t            });\n\t            return surrogate;\n\t          }\n\t\n\t          function stateEnteredSurrogate(state, toParams) {\n\t            var oldOnEnter = state.self.onEnter;\n\t            state.self.onEnter = function () {\n\t              _StickyState.stateEntering(state, toParams, oldOnEnter);\n\t            };\n\t            restore.addRestoreFunction(function () {\n\t              state.self.onEnter = oldOnEnter;\n\t            });\n\t\n\t            return state;\n\t          }\n\t\n\t          // TODO: This may be completely unnecessary now that we're using $$uirouterextrasreload temp param\n\t          function stateUpdateParamsSurrogate(state, toParams) {\n\t            var oldOnEnter = state.self.onEnter;\n\t            state.self.onEnter = function () {\n\t              _StickyState.stateEntering(state, toParams, oldOnEnter, true);\n\t            };\n\t            restore.addRestoreFunction(function () {\n\t              state.self.onEnter = oldOnEnter;\n\t            });\n\t\n\t            return state;\n\t          }\n\t\n\t          function stateExitedSurrogate(state) {\n\t            var oldOnExit = state.self.onExit;\n\t            state.self.onExit = function () {\n\t              _StickyState.stateExiting(state, exited, oldOnExit);\n\t            };\n\t            restore.addRestoreFunction(function () {\n\t              state.self.onExit = oldOnExit;\n\t            });\n\t\n\t            return state;\n\t          }\n\t\n\t\n\t          // --------------------- decorated .transitionTo() logic starts here ------------------------\n\t          if (toStateSelf) {\n\t            var toState = internalStates[toStateSelf.name]; // have the state, now grab the internal state representation\n\t            if (toState) {\n\t              // Save the toState and fromState paths to be restored using restore()\n\t              savedToStatePath = toState.path;\n\t              savedFromStatePath = fromState.path;\n\t\n\t              // Try to resolve options.reload to a state.  If so, we'll reload only up to the given state.\n\t              var reload = options && options.reload || false;\n\t              var reloadStateTree = reload && (reload === true ? savedToStatePath[0].self : $state.get(reload, rel));\n\t              // If options.reload is a string or a state, we want to handle reload ourselves and not\n\t              // let ui-router reload the entire toPath.\n\t              if (options && reload && reload !== true)\n\t                delete options.reload;\n\t\n\t              var currentTransition = {\n\t                toState: toState,\n\t                toParams: toParams || {},\n\t                fromState: fromState,\n\t                fromParams: fromParams || {},\n\t                options: options,\n\t                reloadStateTree: reloadStateTree\n\t              };\n\t\n\t              pendingTransitions.push(currentTransition); // TODO: See if a list of pending transitions is necessary.\n\t              pendingRestore = restore;\n\t\n\t              // If we're reloading from a state and below, temporarily add a param to the top of the state tree\n\t              // being reloaded, and add a param value to the transition.  This will cause the \"has params changed\n\t              // for state\" check to return true, and the states will be reloaded.\n\t              if (reloadStateTree) {\n\t                currentTransition.toParams.$$uirouterextrasreload = Math.random();\n\t                var params = reloadStateTree.$$state().params;\n\t                var ownParams = reloadStateTree.$$state().ownParams;\n\t\n\t                if (versionHeuristics.hasParamSet) {\n\t                  var tempParam = new $urlMatcherFactoryProvider.Param('$$uirouterextrasreload');\n\t                  params.$$uirouterextrasreload = ownParams.$$uirouterextrasreload = tempParam;\n\t                  restore.restoreFunctions.push(function() {\n\t                    delete params.$$uirouterextrasreload;\n\t                    delete ownParams.$$uirouterextrasreload;\n\t                  });\n\t                } else {\n\t                  params.push('$$uirouterextrasreload');\n\t                  ownParams.push('$$uirouterextrasreload');\n\t                  restore.restoreFunctions.push(function() {\n\t                    params.length = params.length -1;\n\t                    ownParams.length = ownParams.length -1;\n\t                  });\n\t                }\n\t              }\n\t\n\t              // $StickyStateProvider.processTransition analyzes the states involved in the pending transition.  It\n\t              // returns an object that tells us:\n\t              // 1) if we're involved in a sticky-type transition\n\t              // 2) what types of exit transitions will occur for each \"exited\" path element\n\t              // 3) what types of enter transitions will occur for each \"entered\" path element\n\t              // 4) which states will be inactive if the transition succeeds.\n\t              stickyTransitions = _StickyState.processTransition(currentTransition);\n\t\n\t              if (DEBUG) debugTransition($log, currentTransition, stickyTransitions);\n\t\n\t              // Begin processing of surrogate to and from paths.\n\t              var surrogateToPath = toState.path.slice(0, stickyTransitions.keep);\n\t              var surrogateFromPath = fromState.path.slice(0, stickyTransitions.keep);\n\t\n\t              // Clear out and reload inactivePseudoState.locals each time transitionTo is called\n\t              angular.forEach(inactivePseudoState.locals, function (local, name) {\n\t                if (name.indexOf(\"@\") != -1) delete inactivePseudoState.locals[name];\n\t              });\n\t\n\t              var saveViewsToLocals = function (targetObj) {\n\t                return function(view, name) {\n\t                  if (name.indexOf(\"@\") !== -1) { // Only grab this state's \"view\" locals\n\t                    targetObj[name] = view; // Add all inactive views not already included.\n\t                  }\n\t                }\n\t              };\n\t\n\t              // For each state that will be inactive when the transition is complete, place its view-locals on the\n\t              // __inactives pseudostate's .locals.  This allows the ui-view directive to access them and\n\t              // render the inactive views.\n\t              forEach(stickyTransitions.inactives, function(state) {\n\t                forEach(state.locals, saveViewsToLocals(inactivePseudoState.locals))\n\t              });\n\t\n\t              // For each state that will be reactivated during the transition, place its view-locals on a separate\n\t              // locals object (prototypal parent of __inactives.locals, and remove them when the transition is complete.\n\t              // This is necessary when we a transition will reactivate one state, but enter a second.\n\t              // Gory details:\n\t              //   - the entering of a new state causes $view.load() to fire $viewContentLoading while the transition is\n\t              //     still in process\n\t              //   - all ui-view(s) check if they should re-render themselves in response to this event.\n\t              //   - ui-view checks if previousLocals is equal to currentLocals\n\t              //     - it uses $state.$current.locals[myViewName] for previousLocals\n\t              //   - Because the transition is not completed, $state.$current is set to the from state, and\n\t              //     the ui-view for a reactivated state cannot find its previous locals.\n\t              forEach(stickyTransitions.reactivatingStates, function(state) {\n\t                forEach(state.locals, saveViewsToLocals(reactivatingLocals));\n\t              });\n\t\n\t              // When the transition is complete, remove the copies of the view locals from reactivatingLocals.\n\t              restore.addRestoreFunction(function clearReactivatingLocals() {\n\t                forEach(reactivatingLocals, function (val, viewname) {\n\t                  delete reactivatingLocals[viewname];\n\t                })\n\t              });\n\t\n\t              // Find all the states the transition will be entering.  For each entered state, check entered-state-transition-type\n\t              // Depending on the entered-state transition type, place the proper surrogate state on the surrogate toPath.\n\t              angular.forEach(stickyTransitions.enter, function (value, idx) {\n\t                var surrogate;\n\t                var enteringState = toState.path[idx];\n\t                if (value === \"reactivate\") {\n\t                  // Reactivated states require TWO surrogates.  The \"phase 1 reactivated surrogates\" are added to both\n\t                  // to.path and from.path, and as such, are considered to be \"kept\" by UI-Router.\n\t                  // This is required to get UI-Router to add the surrogate locals to the protoypal locals object\n\t                  surrogate = stateReactivatedSurrogatePhase1(enteringState);\n\t                  surrogateToPath.push(surrogate);\n\t                  surrogateFromPath.push(surrogate);  // so toPath[i] === fromPath[i]\n\t\n\t                  // The \"phase 2 reactivated surrogate\" is added to the END of the .path, after all the phase 1\n\t                  // surrogates have been added.\n\t                  reactivated.push(stateReactivatedSurrogatePhase2(enteringState));\n\t                  terminalReactivatedState = enteringState;\n\t                } else if (value === \"reload\") {\n\t                  // If the state params have been changed, we need to exit any inactive states and re-enter them.\n\t                  surrogateToPath.push(stateUpdateParamsSurrogate(enteringState));\n\t                  terminalReactivatedState = enteringState;\n\t                } else if (value === \"enter\") {\n\t                  // Standard enter transition.  We still wrap it in a surrogate.\n\t                  surrogateToPath.push(stateEnteredSurrogate(enteringState));\n\t                }\n\t              });\n\t\n\t              // Find all the states the transition will be exiting.  For each exited state, check the exited-state-transition-type.\n\t              // Depending on the exited-state transition type, place a surrogate state on the surrogate fromPath.\n\t              angular.forEach(stickyTransitions.exit, function (value, idx) {\n\t                var exiting = fromState.path[idx];\n\t                if (value === \"inactivate\") {\n\t                  surrogateFromPath.push(stateInactivatedSurrogate(exiting));\n\t                  exited.push(exiting);\n\t                } else if (value === \"exit\") {\n\t                  surrogateFromPath.push(stateExitedSurrogate(exiting));\n\t                  exited.push(exiting);\n\t                }\n\t              });\n\t\n\t              // Add surrogate states for reactivated to ToPath again (phase 2), this time without a matching FromPath entry\n\t              // This is to get ui-router to call the surrogate's onEnter callback.\n\t              if (reactivated.length) {\n\t                angular.forEach(reactivated, function (surrogate) {\n\t                  surrogateToPath.push(surrogate);\n\t                });\n\t              }\n\t\n\t              // We may transition directly to an inactivated state, reactivating it.  In this case, we should\n\t              // exit all of that state's inactivated children.\n\t              var orphans = stickyTransitions.orphans;\n\t              // Add surrogate exited states for all orphaned descendants of the Deepest Reactivated State\n\t              surrogateFromPath = surrogateFromPath.concat(map(orphans, function (exiting) {\n\t                return stateExitedSurrogate(exiting);\n\t              }));\n\t              exited = exited.concat(orphans);\n\t\n\t              // Replace the .path variables.  toState.path and fromState.path are now ready for a sticky transition.\n\t              fromState.path = surrogateFromPath;\n\t              toState.path = surrogateToPath;\n\t\n\t              var pathMessage = function (state) {\n\t                return (state.surrogateType ? state.surrogateType + \":\" : \"\") + state.self.name;\n\t              };\n\t              if (DEBUG) $log.debug(\"SurrogateFromPath: \", map(surrogateFromPath, pathMessage));\n\t              if (DEBUG) $log.debug(\"SurrogateToPath:   \", map(surrogateToPath, pathMessage));\n\t            }\n\t          }\n\t\n\t          // toState and fromState are all set up; now run stock UI-Router's $state.transitionTo().\n\t          var transitionPromise = $state_transitionTo.apply($state, arguments);\n\t\n\t          // Add post-transition promise handlers, then return the promise to the original caller.\n\t          return transitionPromise.then(function transitionSuccess(state) {\n\t            // First, restore toState and fromState to their original values.\n\t            restore();\n\t            if (DEBUG)  debugViewsAfterSuccess($log, internalStates[state.name], $state);\n\t\n\t            state.status = 'active';  // TODO: This status is used in statevis.js, and almost certainly belongs elsewhere.\n\t\n\t            return state;\n\t          }, function transitionFailed(err) {\n\t            restore();\n\t            if (DEBUG &&\n\t              err.message !== \"transition prevented\" &&\n\t              err.message !== \"transition aborted\" &&\n\t              err.message !== \"transition superseded\") {\n\t              $log.debug(\"transition failed\", err);\n\t              $log.debug(err.stack);\n\t            }\n\t            return $q.reject(err);\n\t          });\n\t        };\n\t        return $state;\n\t      }]);\n\t\n\t\n\t\n\t      function debugTransition($log, currentTransition, stickyTransition) {\n\t        function message(path, index, state) {\n\t          return (path[index] ? path[index].toUpperCase() + \": \" + state.self.name : \"(\" + state.self.name + \")\");\n\t        }\n\t\n\t        var inactiveLogVar = map(stickyTransition.inactives, function (state) {\n\t          return state.self.name;\n\t        });\n\t        var enterLogVar = map(currentTransition.toState.path, function (state, index) {\n\t          return message(stickyTransition.enter, index, state);\n\t        });\n\t        var exitLogVar = map(currentTransition.fromState.path, function (state, index) {\n\t          return message(stickyTransition.exit, index, state);\n\t        });\n\t\n\t        var transitionMessage = currentTransition.fromState.self.name + \": \" +\n\t          angular.toJson(currentTransition.fromParams) + \": \" +\n\t          \" -> \" +\n\t          currentTransition.toState.self.name + \": \" +\n\t          angular.toJson(currentTransition.toParams);\n\t\n\t        $log.debug(\"------------------------------------------------------\");\n\t        $log.debug(\"   Current transition: \", transitionMessage);\n\t        $log.debug(\"Before transition, inactives are:   : \", map(_StickyState.getInactiveStates(), function (s) {\n\t          return s.self.name;\n\t        }));\n\t        $log.debug(\"After transition,  inactives will be: \", inactiveLogVar);\n\t        $log.debug(\"Transition will exit:  \", exitLogVar);\n\t        $log.debug(\"Transition will enter: \", enterLogVar);\n\t      }\n\t\n\t      function debugViewsAfterSuccess($log, currentState, $state) {\n\t        $log.debug(\"Current state: \" + currentState.self.name + \", inactive states: \", map(_StickyState.getInactiveStates(), function (s) {\n\t          return s.self.name;\n\t        }));\n\t\n\t        var statesOnly = function (local, name) {\n\t          return name != 'globals' && name != 'resolve';\n\t        };\n\t\n\t        var viewsForState = function (state) {\n\t          var viewLocals = filterObj(state.locals, statesOnly);\n\t\n\t          if (!Object.keys(viewLocals).length) {\n\t            viewLocals[''] = { $$state: { name: null } };\n\t          }\n\t\n\t          return map(viewLocals, function(local, name) {\n\t            return {\n\t              localsFor: state.self.name ? state.self.name : \"(root)\",\n\t              uiViewName: name || null,\n\t              filledByState: local.$$state.name\n\t            };\n\t          });\n\t        };\n\t\n\t        var viewsByState = viewsForState(currentState);\n\t        var parent = currentState.parent;\n\t        while (parent && parent !== currentState) {\n\t          viewsByState = viewsByState.concat(viewsForState(parent));\n\t          currentState = parent;\n\t          parent = currentState.parent;\n\t        }\n\t\n\t        $log.debug(\"Views active on each state:\");\n\t        console.table(viewsByState.reverse());\n\t      }\n\t    }\n\t  ]\n\t);\n\t\n\t(function(angular, undefined) {\n\t  var app = angular.module('ct.ui.router.extras.future', [ 'ct.ui.router.extras.core' ]);\n\t\n\t  _futureStateProvider.$inject = [ '$stateProvider', '$urlRouterProvider', '$urlMatcherFactoryProvider', 'uirextras_coreProvider' ];\n\t  function _futureStateProvider($stateProvider, $urlRouterProvider, $urlMatcherFactory, uirextras_coreProvider) {\n\t    var core = uirextras_coreProvider;\n\t    var internalStates = core.internalStates;\n\t    var stateFactories = {}, futureStates = {};\n\t    var lazyloadInProgress = false, resolveFunctions = [], initPromise, initDone = false;\n\t    var provider = this;\n\t\n\t    // This function registers a promiseFn, to be resolved before the url/state matching code\n\t    // will reject a route.  The promiseFn is injected/executed using the runtime $injector.\n\t    // The function should return a promise.\n\t    // When all registered promises are resolved, then the route is re-sync'ed.\n\t\n\t    // Example: function($http) {\n\t    //  return $http.get('//server.com/api/DynamicFutureStates').then(function(data) {\n\t    //    angular.forEach(data.futureStates, function(fstate) { $futureStateProvider.futureState(fstate); });\n\t    //  };\n\t    // }\n\t    this.addResolve = function (promiseFn) {\n\t      resolveFunctions.push(promiseFn);\n\t    };\n\t\n\t    // Register a state factory function for a particular future-state type.  This factory, given a future-state object,\n\t    // should create a ui-router state.\n\t    // The factory function is injected/executed using the runtime $injector.  The future-state is injected as 'futureState'.\n\t\n\t    // Example:\n\t    //    $futureStateProvider.stateFactory('test', function(futureState) {\n\t    //      return {\n\t    //        name: futureState.stateName,\n\t    //        url: futureState.urlFragment,\n\t    //        template: '<h3>Future State Template</h3>',\n\t    //        controller: function() {\n\t    //          console.log(\"Entered state \" + futureState.stateName);\n\t    //        }\n\t    //      }\n\t    //    });\n\t    this.stateFactory = function (futureStateType, factory) {\n\t      stateFactories[futureStateType] = factory;\n\t    };\n\t\n\t    this.futureState = function (futureState) {\n\t      if (futureState.stateName)  // backwards compat for now\n\t        futureState.name = futureState.stateName;\n\t      if (futureState.urlPrefix)  // backwards compat for now\n\t        futureState.url = \"^\" + futureState.urlPrefix;\n\t\n\t      futureStates[futureState.name] = futureState;\n\t      var parentMatcher,  parentName = futureState.name.split(/\\./).slice(0, -1).join(\".\"),\n\t        realParent = findState(futureState.parent || parentName);\n\t      if (realParent) {\n\t        parentMatcher = realParent.url || realParent.navigable && realParent.navigable.url;\n\t      } else if (parentName === \"\") {\n\t        parentMatcher = $urlMatcherFactory.compile(\"\");\n\t      } else {\n\t        var futureParent = findState((futureState.parent || parentName), true);\n\t        if (!futureParent) throw new Error(\"Couldn't determine parent state of future state. FutureState:\" + angular.toJson(futureState));\n\t        var pattern;\n\t        if (futureParent.urlMatcher) {\n\t          pattern = futureParent.urlMatcher.source.replace(/\\*rest$/, \"\");\n\t        }\n\t        else {\n\t          // if the futureParent doesn't have a urlMatcher, then we are still\n\t          // starting from the beginning of the path\n\t          pattern = \"\";\n\t        }\n\t        parentMatcher = $urlMatcherFactory.compile(pattern);\n\t        futureState.parentFutureState = futureParent;\n\t      }\n\t      if (futureState.url) {\n\t        futureState.urlMatcher = futureState.url.charAt(0) === \"^\" ?\n\t          $urlMatcherFactory.compile(futureState.url.substring(1) + \"*rest\") :\n\t          parentMatcher.concat(futureState.url + \"*rest\");\n\t      }\n\t    };\n\t\n\t    this.get = function () {\n\t      return angular.extend({}, futureStates);\n\t    };\n\t\n\t    function findState(stateOrName, findFutureState) {\n\t      var statename = angular.isObject(stateOrName) ? stateOrName.name : stateOrName;\n\t      return !findFutureState ? internalStates[statename] : futureStates[statename];\n\t    }\n\t\n\t    /* options is an object with at least a name or url attribute */\n\t    function findFutureState($state, options) {\n\t      if (options.name) {\n\t        var nameComponents = options.name.split(/\\./);\n\t        if (options.name.charAt(0) === '.')\n\t          nameComponents[0] = $state.current.name;\n\t        while (nameComponents.length) {\n\t          var stateName = nameComponents.join(\".\");\n\t          if ($state.get(stateName, { relative: $state.current }))\n\t            return null; // State is already defined; nothing to do\n\t          if (futureStates[stateName])\n\t            return futureStates[stateName];\n\t          nameComponents.pop();\n\t        }\n\t      }\n\t\n\t      if (options.url) {\n\t        var matches = [];\n\t        for(var future in futureStates) {\n\t          var matcher = futureStates[future].urlMatcher;\n\t          if (matcher && matcher.exec(options.url)) {\n\t            matches.push(futureStates[future]);\n\t          }\n\t        }\n\t        // Find most specific by ignoring matching parents from matches\n\t        var copy = matches.slice(0);\n\t        for (var i = matches.length - 1; i >= 0; i--) {\n\t          for (var j = 0; j < copy.length; j++) {\n\t            if (matches[i] === copy[j].parentFutureState) matches.splice(i, 1);\n\t          }\n\t        }\n\t        return matches[0];\n\t      }\n\t    }\n\t\n\t    function lazyLoadState($injector, futureState) {\n\t      lazyloadInProgress = true;\n\t      var $q = $injector.get(\"$q\");\n\t      if (!futureState) {\n\t        var deferred = $q.defer();\n\t        deferred.reject(\"No lazyState passed in \" + futureState);\n\t        return deferred.promise;\n\t      }\n\t\n\t      var parentPromises = $q.when([]), parentFuture = futureState.parentFutureState;\n\t      if (parentFuture && futureStates[parentFuture.name]) {\n\t        parentPromises = lazyLoadState($injector, futureStates[parentFuture.name]);\n\t      }\n\t\n\t      var type = futureState.type;\n\t      var factory = stateFactories[type];\n\t      if (!factory) throw Error(\"No state factory for futureState.type: \" + (futureState && futureState.type));\n\t\n\t      var failedLoadPolicy = factory.$options && factory.$options.failedLazyLoadPolicy || \"remove\";\n\t      function deregisterFutureState() { delete(futureStates[futureState.name]); }\n\t      function errorHandler(err) {\n\t        if (failedLoadPolicy === \"remove\") deregisterFutureState();\n\t        return $q.reject(err);\n\t      }\n\t\n\t      return parentPromises.then(function(array) {\n\t        var factoryPromise = $injector.invoke(factory, factory, { futureState: futureState });\n\t\n\t        return factoryPromise.then(function(fullState) {\n\t          deregisterFutureState(); // Success; remove future state\n\t          if (fullState) { array.push(fullState); } // Pass a chain of realized states back\n\t          return array;\n\t        });\n\t      }).catch(errorHandler)\n\t    }\n\t\n\t    var otherwiseFunc = [ '$log', '$location',\n\t      function otherwiseFunc($log, $location) {\n\t        //$log.debug(\"Unable to map \" + $location.path());\n\t      }];\n\t\n\t    function futureState_otherwise($injector, $location) {\n\t      var resyncing = false;\n\t\n\t      var lazyLoadMissingState =\n\t        ['$rootScope', '$urlRouter', '$state',\n\t          function lazyLoadMissingState($rootScope, $urlRouter, $state) {\n\t            function resync() {\n\t              resyncing = true; $urlRouter.sync(); resyncing = false;\n\t            }\n\t            if (!initDone) {\n\t              // Asynchronously load state definitions, then resync URL\n\t              initPromise().then(resync);\n\t              initDone = true;\n\t              return;\n\t            }\n\t\n\t            var futureState = findFutureState($state, { url: $location.path() });\n\t            if (!futureState) {\n\t              return $injector.invoke(otherwiseFunc);\n\t            }\n\t\n\t            // Config loaded.  Asynchronously lazy-load state definition from URL fragment, if mapped.\n\t            lazyLoadState($injector, futureState).then(function lazyLoadedStateCallback(states) {\n\t              states.forEach(function (state) {\n\t                if (state && (!$state.get(state) || (state.name && !$state.get(state.name))))\n\t                  $stateProvider.state(state);\n\t              });\n\t              lazyloadInProgress = false;\n\t              resync();\n\t            }, function lazyLoadStateAborted() {\n\t              lazyloadInProgress = false;\n\t              resync();\n\t            });\n\t          }];\n\t      if (lazyloadInProgress) return;\n\t\n\t      var nextFn = resyncing ? otherwiseFunc : lazyLoadMissingState;\n\t      return $injector.invoke(nextFn);\n\t    }\n\t\n\t    $urlRouterProvider.otherwise(futureState_otherwise);\n\t\n\t    $urlRouterProvider.otherwise = function(rule) {\n\t      if (angular.isString(rule)) {\n\t        var redirect = rule;\n\t        rule = function () { return redirect; };\n\t      }\n\t      else if (!angular.isFunction(rule)) throw new Error(\"'rule' must be a function\");\n\t      otherwiseFunc = ['$injector', '$location', rule];\n\t      return $urlRouterProvider;\n\t    };\n\t\n\t    var serviceObject = {\n\t      getResolvePromise: function () {\n\t        return initPromise();\n\t      }\n\t    };\n\t\n\t    // Used in .run() block to init\n\t    this.$get = [ '$injector', '$state', '$q', '$rootScope', '$urlRouter', '$timeout', '$log',\n\t      function futureStateProvider_get($injector, $state, $q, $rootScope, $urlRouter, $timeout, $log) {\n\t        function init() {\n\t          $rootScope.$on(\"$stateNotFound\", function futureState_notFound(event, unfoundState, fromState, fromParams) {\n\t            if (lazyloadInProgress) return;\n\t            //$log.debug(\"event, unfoundState, fromState, fromParams\", event, unfoundState, fromState, fromParams);\n\t\n\t            var futureState = findFutureState($state, { name: unfoundState.to });\n\t            if (!futureState) return;\n\t\n\t            event.preventDefault();\n\t            var promise = lazyLoadState($injector, futureState);\n\t            promise.then(function (states) {\n\t              states.forEach(function (state) {\n\t                if (state && (!$state.get(state) || (state.name && !$state.get(state.name))))\n\t                  $stateProvider.state(state);\n\t              });\n\t              $state.go(unfoundState.to, unfoundState.toParams, unfoundState.options);\n\t              lazyloadInProgress = false;\n\t            }, function (error) {\n\t              console.log(\"failed to lazy load state \", error);\n\t              if (fromState.name) $state.go(fromState, fromParams);\n\t              lazyloadInProgress = false;\n\t            });\n\t          });\n\t\n\t          // Do this better.  Want to load remote config once, before everything else\n\t          if (!initPromise) {\n\t            var promises = [];\n\t            angular.forEach(resolveFunctions, function (promiseFn) {\n\t              promises.push($injector.invoke(promiseFn));\n\t            });\n\t            initPromise = function () {\n\t              return $q.all(promises);\n\t            };\n\t          }\n\t\n\t          // TODO: analyze this. I'm calling $urlRouter.sync() in two places for retry-initial-transition.\n\t          // TODO: I should only need to do this once.  Pick the better place and remove the extra resync.\n\t          initPromise().then(function retryInitialState() {\n\t            $timeout(function () {\n\t              if ($state.transition) {\n\t                $state.transition.then(retryInitialState, retryInitialState);\n\t              } else {\n\t                $urlRouter.sync();\n\t              }\n\t            });\n\t          });\n\t        }\n\t\n\t        init();\n\t\n\t        serviceObject.state = $stateProvider.state;\n\t        serviceObject.futureState = provider.futureState;\n\t        serviceObject.get = provider.get;\n\t\n\t        return serviceObject;\n\t      }\n\t    ];\n\t  }\n\t\n\t  app.provider('$futureState', _futureStateProvider);\n\t\n\t  var statesAddedQueue = {\n\t    state: function(state) {\n\t      if (statesAddedQueue.$rootScope)\n\t        statesAddedQueue.$rootScope.$broadcast(\"$stateAdded\", state);\n\t    },\n\t    itsNowRuntimeOhWhatAHappyDay: function($rootScope) {\n\t      statesAddedQueue.$rootScope = $rootScope;\n\t    },\n\t    $rootScope: undefined\n\t  };\n\t\n\t  app.config([ '$stateProvider', function($stateProvider) {\n\t    // decorate $stateProvider.state so we can broadcast when a real state was added\n\t    var realStateFn = $stateProvider.state;\n\t    $stateProvider.state = function state_announce() {\n\t      var val = realStateFn.apply($stateProvider, arguments);\n\t\n\t      var state = angular.isObject(arguments[0]) ? arguments[0] : arguments[1];\n\t      statesAddedQueue.state(state);\n\t      return val;\n\t    };\n\t  }]);\n\t\n\t  // inject $futureState so the service gets initialized via $get();\n\t  app.run(['$futureState', function ($futureState, $rootScope) {\n\t    statesAddedQueue.itsNowRuntimeOhWhatAHappyDay($rootScope);\n\t  } ]);\n\t\n\t})(angular);\n\t\n\tangular.module('ct.ui.router.extras.previous', [ 'ct.ui.router.extras.core', 'ct.ui.router.extras.transition' ]).service(\"$previousState\",\n\t  [ '$rootScope', '$state', '$q',\n\t    function ($rootScope, $state, $q) {\n\t      var previous = null, lastPrevious = null, memos = {};\n\t\n\t      $rootScope.$on(\"$transitionStart\", function(evt, $transition$) {\n\t        var from = $transition$.from;\n\t        // Check if the fromState is navigable before tracking it.\n\t        // Root state doesn't get decorated with $$state().  Doh.\n\t        var fromState = from.state && from.state.$$state && from.state.$$state();\n\t        function commit() { lastPrevious = null; }\n\t        function revert() { previous = lastPrevious; }\n\t        if (fromState) {\n\t          lastPrevious = previous;\n\t          previous = $transition$.from;\n\t\n\t          $transition$.promise.then(commit)['catch'](revert);\n\t        }\n\t      });\n\t\n\t      var $previousState = {\n\t        get: function (memoName) {\n\t          return memoName ? memos[memoName] : previous;\n\t        },\n\t        set: function (memoName, previousState, previousParams) {\n\t          memos[memoName] = { state: $state.get(previousState), params: previousParams };\n\t        },\n\t        go: function (memoName, options) {\n\t          var to = $previousState.get(memoName);\n\t          if (!to) {\n\t            return $q.reject(new Error('no previous state ' + (memoName ? 'for memo: ' + memoName : '')));\n\t          }\n\t          return $state.go(to.state, to.params, options);\n\t        },\n\t        memo: function (memoName, defaultStateName, defaultStateParams) {\n\t          memos[memoName] = previous || { state: $state.get(defaultStateName), params: defaultStateParams };\n\t        },\n\t        forget: function (memoName) {\n\t          if (memoName) {\n\t            delete memos[memoName];\n\t          } else {\n\t            previous = undefined;\n\t          }\n\t        }\n\t      };\n\t\n\t      return $previousState;\n\t    }\n\t  ]\n\t);\n\t\n\tangular.module('ct.ui.router.extras.previous').run(['$previousState', function ($previousState) {\n\t  // Inject $previousState so it can register $rootScope events\n\t}]);\n\t\n\t\n\tangular.module(\"ct.ui.router.extras.transition\", [ 'ct.ui.router.extras.core' ]).config( [ \"$provide\",  function ($provide) {\n\t      // Decorate the $state service, so we can replace $state.transitionTo()\n\t      $provide.decorator(\"$state\", ['$delegate', '$rootScope', '$q', '$injector',\n\t        function ($state, $rootScope, $q, $injector) {\n\t          // Keep an internal reference to the real $state.transitionTo function\n\t          var $state_transitionTo = $state.transitionTo;\n\t          // $state.transitionTo can be re-entered.  Keep track of re-entrant stack\n\t          var transitionDepth = -1;\n\t          var tDataStack = [];\n\t          var restoreFnStack = [];\n\t\n\t          // This function decorates the $injector, adding { $transition$: tData } to invoke() and instantiate() locals.\n\t          // It returns a function that restores $injector to its previous state.\n\t          function decorateInjector(tData) {\n\t            var oldinvoke = $injector.invoke;\n\t            var oldinstantiate = $injector.instantiate;\n\t            $injector.invoke = function (fn, self, locals) {\n\t              return oldinvoke(fn, self, angular.extend({$transition$: tData}, locals));\n\t            };\n\t            $injector.instantiate = function (fn, locals) {\n\t              return oldinstantiate(fn, angular.extend({$transition$: tData}, locals));\n\t            };\n\t\n\t            return function restoreItems() {\n\t              $injector.invoke = oldinvoke;\n\t              $injector.instantiate = oldinstantiate;\n\t            };\n\t          }\n\t\n\t          function popStack() {\n\t            restoreFnStack.pop()();\n\t            tDataStack.pop();\n\t            transitionDepth--;\n\t          }\n\t\n\t          // This promise callback (for when the real transitionTo is successful) runs the restore function for the\n\t          // current stack level, then broadcasts the $transitionSuccess event.\n\t          function transitionSuccess(deferred, tSuccess) {\n\t            return function successFn(data) {\n\t              popStack();\n\t              $rootScope.$broadcast(\"$transitionSuccess\", tSuccess);\n\t              deferred.resolve(data); // $transition$ deferred\n\t              return data;\n\t            };\n\t          }\n\t\n\t          // This promise callback (for when the real transitionTo fails) runs the restore function for the\n\t          // current stack level, then broadcasts the $transitionError event.\n\t          function transitionFailure(deferred, tFail) {\n\t            return function failureFn(error) {\n\t              popStack();\n\t              $rootScope.$broadcast(\"$transitionError\", tFail, error);\n\t              deferred.reject(error);  // $transition$ deferred\n\t              return $q.reject(error);\n\t            };\n\t          }\n\t\n\t          // Decorate $state.transitionTo.\n\t          $state.transitionTo = function (to, toParams, options) {\n\t            // Create a deferred/promise which can be used earlier than UI-Router's transition promise.\n\t            var deferred = $q.defer();\n\t            // Place the promise in a transition data, and place it on the stack to be used in $stateChangeStart\n\t            var tData = tDataStack[++transitionDepth] = {\n\t              promise: deferred.promise\n\t            };\n\t            // placeholder restoreFn in case transitionTo doesn't reach $stateChangeStart (state not found, etc)\n\t            restoreFnStack[transitionDepth] = function() { };\n\t            // Invoke the real $state.transitionTo\n\t            var tPromise = $state_transitionTo.apply($state, arguments);\n\t\n\t            // insert our promise callbacks into the chain.\n\t            return tPromise.then(transitionSuccess(deferred, tData), transitionFailure(deferred, tData));\n\t          };\n\t\n\t          // This event is handled synchronously in transitionTo call stack\n\t          $rootScope.$on(\"$stateChangeStart\", function (evt, toState, toParams, fromState, fromParams) {\n\t              if (transitionDepth >= tDataStack.length) return;\n\t              var depth = transitionDepth;\n\t              // To/From is now normalized by ui-router.  Add this information to the transition data object.\n\t              var tData = angular.extend(tDataStack[depth], {\n\t                to: { state: toState, params: toParams },\n\t                from: { state: fromState, params: fromParams }\n\t              });\n\t\n\t              var restoreFn = decorateInjector(tData);\n\t              restoreFnStack[depth] = restoreFn;\n\t              $rootScope.$broadcast(\"$transitionStart\", tData);\n\t            }\n\t          );\n\t\n\t          return $state;\n\t        }]);\n\t    }\n\t  ]\n\t);\n\t\n\t// statevis requires d3.\n\t(function () {\n\t  \"use strict\";\n\t  var app = angular.module(\"ct.ui.router.extras.statevis\", [ 'ct.ui.router.extras.core', 'ct.ui.router.extras.sticky'  ]);\n\t\n\t  app.directive('stateVis', [ '$state', '$timeout', '$interval', stateVisDirective ]);\n\t\n\t  /**\n\t   * This directive gets all the current states using $state.get() and displays them in a tree using D3 lib.\n\t   * It then listens for state events and updates the tree.\n\t   *\n\t   * Usage:\n\t   * <state-vis height=\"1000px\" width=\"1000px\"></state-vis>\n\t   */\n\t  function stateVisDirective($state, $timeout, $interval) {\n\t    return {\n\t      scope: {\n\t        width: '@',\n\t        height: '@'\n\t      },\n\t      restrict: 'AE',\n\t      template: '<svg></svg>',\n\t      link: function (_scope, _elem, _attrs) {\n\t        var stateMap = {};\n\t        var width = _scope.width || 400,\n\t          height = _scope.height || 400;\n\t\n\t        var tree = d3.layout.tree()\n\t            .size([width - 20, height - 20])\n\t            .separation(function (a, b) {\n\t              return a.parent == b.parent ? 10 : 25;\n\t            });\n\t\n\t        var root = $state.get().filter(function (state) { return state.name === \"\"; })[0];\n\t        var nodes = tree(root);\n\t\n\t        root.parent = root;\n\t        root.px = root.x = width / 2;\n\t        root.py = root.y = height / 2;\n\t\n\t        var activeNode = { };\n\t        activeNode.px = activeNode.x = root.px;\n\t        activeNode.py = activeNode.y = root.py;\n\t\n\t        var diagonal = d3.svg.diagonal();\n\t\n\t        var svg = d3.select(_elem.find(\"svg\")[0])\n\t          .attr(\"width\", width)\n\t          .attr(\"height\", height)\n\t          .append(\"g\")\n\t          .attr(\"transform\", \"translate(10, 10)\");\n\t\n\t        var node = svg.selectAll(\".node\"),\n\t          link = svg.selectAll(\".link\"),\n\t          active = svg.selectAll(\".active\")\n\t          ;\n\t\n\t        var updateInterval = 200,\n\t          transLength = 200,\n\t          timer = setInterval(update, updateInterval);\n\t\n\t        function addStates(data) {\n\t          // *********** Convert flat data into a nice tree ***************\n\t          data = data.map(function (node) {\n\t            return node.name === \"\" ? root : angular.copy(node);\n\t          });\n\t          angular.extend(stateMap, data.reduce(function (map, node) {\n\t            map[node.name] = node;\n\t            return map;\n\t          }, {}));\n\t\n\t          data.forEach(function (node) {\n\t            // add to parent\n\t            var parentName = node.name.split(/\\./).slice(0, -1).join(\".\");\n\t            var parent = node.name != parentName && stateMap[parentName];\n\t            if (parent) {\n\t              (parent.children || (parent.children = [])).push(node); // create child array if it doesn't exist\n\t              node.px = parent.px;\n\t              node.py = parent.py;\n\t              nodes.push(node);\n\t            }\n\t          });\n\t        }\n\t\n\t        $interval(function () {\n\t          _scope.states = $state.get();\n\t          angular.forEach(nodes, function (n) {\n\t            var s = $state.get(n.name);\n\t            if (s) {\n\t              n.status = s.status || 'exited';\n\t            }\n\t          });\n\t//          _scope.futureStates = $futureState.get();\n\t        }, 250);\n\t\n\t        _scope.$watchCollection(\"states\", function (newval, oldval) {\n\t          var oldstates = (oldval || []).map(function (s) { return s.name; });\n\t          addStates((newval || []).filter(function(state) { return oldstates.indexOf(state.name) == -1; } ));\n\t//          addStates(_.reject(newval, function (state) { return _.contains(oldstates, state.name); }));\n\t        });\n\t\n\t//        addStates($state.get());\n\t        update(updateInterval);\n\t\n\t        function update() {\n\t          // Recompute the layout and data join.\n\t          node = node.data(tree.nodes(root), function (d) { return d.name; });\n\t          link = link.data(tree.links(nodes), function (d) { return d.target.name; });\n\t          active = active.data(activeNode);\n\t\n\t          nodes.forEach(function (d) { d.y = d.depth * 70; });\n\t\n\t          // Add entering nodes in the parent’s old position.\n\t          var nodeEnter = node.enter();\n\t\n\t          function stateName(node) {\n\t            var name = node.name.split(\".\").pop();\n\t            if (node.sticky) { name += \" (STICKY)\"; }\n\t            if (node.deepStateRedirect) { name += \" (DSR)\"; }\n\t            return name;\n\t          }\n\t\n\t          active.enter()\n\t            .append(\"circle\")\n\t            .attr(\"class\", \"active\")\n\t            .attr(\"r\", 13)\n\t            .attr(\"cx\", function (d) { return d.parent.px || 100; })\n\t            .attr(\"cy\", function (d) { return d.parent.py || 100; })\n\t          ;\n\t\n\t          nodeEnter.append(\"circle\")\n\t            .attr(\"class\", \"node\")\n\t            .attr(\"r\", 9)\n\t            .attr(\"cx\", function (d) { return d.parent.px; })\n\t            .attr(\"cy\", function (d) { return d.parent.py; });\n\t\n\t          nodeEnter.append(\"text\")\n\t            .attr(\"class\", \"label\")\n\t            .attr(\"x\", function (d) { return d.parent.px; })\n\t            .attr(\"y\", function (d) { return d.parent.py; })\n\t            .attr(\"text-anchor\", function (d) { return \"middle\"; })\n\t            .text(stateName)\n\t            .style(\"fill-opacity\", 1);\n\t\n\t\n\t          // Add entering links in the parent’s old position.\n\t          link.enter().insert(\"path\", \".node\")\n\t            .attr(\"class\", \"link\")\n\t            .attr(\"d\", function (d) {\n\t              var o = {x: d.source.px, y: d.source.py};\n\t              return diagonal({source: o, target: o});\n\t            });\n\t\n\t          // Transition nodes and links to their new positions.\n\t          var t = svg.transition()\n\t            .duration(transLength);\n\t\n\t          t.selectAll(\".link\")\n\t            .attr(\"d\", diagonal);\n\t\n\t          /* jshint -W093 */\n\t          var circleColors = { entered: '#AF0', exited: '#777', active: '#0f0', inactive: '#55F', future: '#009' };\n\t          t.selectAll(\".node\")\n\t            .attr(\"cx\", function (d) { return d.px = d.x; })\n\t            .attr(\"cy\", function (d) { return d.py = d.y; })\n\t            .attr(\"r\", function (d) { return d.status === 'active' ? 15 : 10; })\n\t            .style(\"fill\", function (d) { return circleColors[d.status] || \"#FFF\"; });\n\t\n\t          t.selectAll(\".label\")\n\t            .attr(\"x\", function (d) { return d.px = d.x; })\n\t            .attr(\"y\", function (d) { return d.py = d.y - 15; })\n\t            .attr(\"transform\", function (d) { return \"rotate(-25 \" + d.x + \" \" + d.y + \")\"; })\n\t          ;\n\t\n\t          t.selectAll(\".active\")\n\t            .attr(\"x\", function (d) { return d.px = d.x; })\n\t            .attr(\"y\", function (d) { return d.py = d.y - 15; });\n\t        }\n\t      }\n\t    };\n\t  }\n\t})();\n\t\n\t\n\tangular.module(\"ct.ui.router.extras\",\n\t  [\n\t    'ct.ui.router.extras.core',\n\t    'ct.ui.router.extras.dsr',\n\t    'ct.ui.router.extras.future',\n\t    'ct.ui.router.extras.previous',\n\t    'ct.ui.router.extras.statevis',\n\t    'ct.ui.router.extras.sticky',\n\t    'ct.ui.router.extras.transition'\n\t  ]);\n\t\n\t\n\t}));\n\n/***/ },\n/* 15 */\n/***/ function(module, exports) {\n\n\t/**\n\t * oclazyload - Load modules on demand (lazy load) with angularJS\n\t * @version v1.0.9\n\t * @link https://github.com/ocombe/ocLazyLoad\n\t * @license MIT\n\t * @author Olivier Combe <olivier.combe@gmail.com>\n\t */\n\t(function (angular, window) {\n\t    'use strict';\n\t\n\t    var regModules = ['ng', 'oc.lazyLoad'],\n\t        regInvokes = {},\n\t        regConfigs = [],\n\t        modulesToLoad = [],\n\t        // modules to load from angular.module or other sources\n\t    realModules = [],\n\t        // real modules called from angular.module\n\t    recordDeclarations = [],\n\t        broadcast = angular.noop,\n\t        runBlocks = {},\n\t        justLoaded = [];\n\t\n\t    var ocLazyLoad = angular.module('oc.lazyLoad', ['ng']);\n\t\n\t    ocLazyLoad.provider('$ocLazyLoad', [\"$controllerProvider\", \"$provide\", \"$compileProvider\", \"$filterProvider\", \"$injector\", \"$animateProvider\", function ($controllerProvider, $provide, $compileProvider, $filterProvider, $injector, $animateProvider) {\n\t        var modules = {},\n\t            providers = {\n\t            $controllerProvider: $controllerProvider,\n\t            $compileProvider: $compileProvider,\n\t            $filterProvider: $filterProvider,\n\t            $provide: $provide, // other things (constant, decorator, provider, factory, service)\n\t            $injector: $injector,\n\t            $animateProvider: $animateProvider\n\t        },\n\t            debug = false,\n\t            events = false,\n\t            moduleCache = [],\n\t            modulePromises = {};\n\t\n\t        moduleCache.push = function (value) {\n\t            if (this.indexOf(value) === -1) {\n\t                Array.prototype.push.apply(this, arguments);\n\t            }\n\t        };\n\t\n\t        this.config = function (config) {\n\t            // If we want to define modules configs\n\t            if (angular.isDefined(config.modules)) {\n\t                if (angular.isArray(config.modules)) {\n\t                    angular.forEach(config.modules, function (moduleConfig) {\n\t                        modules[moduleConfig.name] = moduleConfig;\n\t                    });\n\t                } else {\n\t                    modules[config.modules.name] = config.modules;\n\t                }\n\t            }\n\t\n\t            if (angular.isDefined(config.debug)) {\n\t                debug = config.debug;\n\t            }\n\t\n\t            if (angular.isDefined(config.events)) {\n\t                events = config.events;\n\t            }\n\t        };\n\t\n\t        /**\n\t         * Get the list of existing registered modules\n\t         * @param element\n\t         */\n\t        this._init = function _init(element) {\n\t            // this is probably useless now because we override angular.bootstrap\n\t            if (modulesToLoad.length === 0) {\n\t                var elements = [element],\n\t                    names = ['ng:app', 'ng-app', 'x-ng-app', 'data-ng-app'],\n\t                    NG_APP_CLASS_REGEXP = /\\sng[:\\-]app(:\\s*([\\w\\d_]+);?)?\\s/,\n\t                    append = function append(elm) {\n\t                    return elm && elements.push(elm);\n\t                };\n\t\n\t                angular.forEach(names, function (name) {\n\t                    names[name] = true;\n\t                    append(document.getElementById(name));\n\t                    name = name.replace(':', '\\\\:');\n\t                    if (typeof element[0] !== 'undefined' && element[0].querySelectorAll) {\n\t                        angular.forEach(element[0].querySelectorAll('.' + name), append);\n\t                        angular.forEach(element[0].querySelectorAll('.' + name + '\\\\:'), append);\n\t                        angular.forEach(element[0].querySelectorAll('[' + name + ']'), append);\n\t                    }\n\t                });\n\t\n\t                angular.forEach(elements, function (elm) {\n\t                    if (modulesToLoad.length === 0) {\n\t                        var className = ' ' + element.className + ' ';\n\t                        var match = NG_APP_CLASS_REGEXP.exec(className);\n\t                        if (match) {\n\t                            modulesToLoad.push((match[2] || '').replace(/\\s+/g, ','));\n\t                        } else {\n\t                            angular.forEach(elm.attributes, function (attr) {\n\t                                if (modulesToLoad.length === 0 && names[attr.name]) {\n\t                                    modulesToLoad.push(attr.value);\n\t                                }\n\t                            });\n\t                        }\n\t                    }\n\t                });\n\t            }\n\t\n\t            if (modulesToLoad.length === 0 && !((window.jasmine || window.mocha) && angular.isDefined(angular.mock))) {\n\t                console.error('No module found during bootstrap, unable to init ocLazyLoad. You should always use the ng-app directive or angular.boostrap when you use ocLazyLoad.');\n\t            }\n\t\n\t            var addReg = function addReg(moduleName) {\n\t                if (regModules.indexOf(moduleName) === -1) {\n\t                    // register existing modules\n\t                    regModules.push(moduleName);\n\t                    var mainModule = angular.module(moduleName);\n\t\n\t                    // register existing components (directives, services, ...)\n\t                    _invokeQueue(null, mainModule._invokeQueue, moduleName);\n\t                    _invokeQueue(null, mainModule._configBlocks, moduleName); // angular 1.3+\n\t\n\t                    angular.forEach(mainModule.requires, addReg);\n\t                }\n\t            };\n\t\n\t            angular.forEach(modulesToLoad, function (moduleName) {\n\t                addReg(moduleName);\n\t            });\n\t\n\t            modulesToLoad = []; // reset for next bootstrap\n\t            recordDeclarations.pop(); // wait for the next lazy load\n\t        };\n\t\n\t        /**\n\t         * Like JSON.stringify but that doesn't throw on circular references\n\t         * @param obj\n\t         */\n\t        var stringify = function stringify(obj) {\n\t            try {\n\t                return JSON.stringify(obj);\n\t            } catch (e) {\n\t                var cache = [];\n\t                return JSON.stringify(obj, function (key, value) {\n\t                    if (angular.isObject(value) && value !== null) {\n\t                        if (cache.indexOf(value) !== -1) {\n\t                            // Circular reference found, discard key\n\t                            return;\n\t                        }\n\t                        // Store value in our collection\n\t                        cache.push(value);\n\t                    }\n\t                    return value;\n\t                });\n\t            }\n\t        };\n\t\n\t        var hashCode = function hashCode(str) {\n\t            var hash = 0,\n\t                i,\n\t                chr,\n\t                len;\n\t            if (str.length == 0) {\n\t                return hash;\n\t            }\n\t            for (i = 0, len = str.length; i < len; i++) {\n\t                chr = str.charCodeAt(i);\n\t                hash = (hash << 5) - hash + chr;\n\t                hash |= 0; // Convert to 32bit integer\n\t            }\n\t            return hash;\n\t        };\n\t\n\t        function _register(providers, registerModules, params) {\n\t            if (registerModules) {\n\t                var k,\n\t                    moduleName,\n\t                    moduleFn,\n\t                    tempRunBlocks = [];\n\t                for (k = registerModules.length - 1; k >= 0; k--) {\n\t                    moduleName = registerModules[k];\n\t                    if (!angular.isString(moduleName)) {\n\t                        moduleName = getModuleName(moduleName);\n\t                    }\n\t                    if (!moduleName || justLoaded.indexOf(moduleName) !== -1 || modules[moduleName] && realModules.indexOf(moduleName) === -1) {\n\t                        continue;\n\t                    }\n\t                    // new if not registered\n\t                    var newModule = regModules.indexOf(moduleName) === -1;\n\t                    moduleFn = ngModuleFct(moduleName);\n\t                    if (newModule) {\n\t                        regModules.push(moduleName);\n\t                        _register(providers, moduleFn.requires, params);\n\t                    }\n\t                    if (moduleFn._runBlocks.length > 0) {\n\t                        // new run blocks detected! Replace the old ones (if existing)\n\t                        runBlocks[moduleName] = [];\n\t                        while (moduleFn._runBlocks.length > 0) {\n\t                            runBlocks[moduleName].push(moduleFn._runBlocks.shift());\n\t                        }\n\t                    }\n\t                    if (angular.isDefined(runBlocks[moduleName]) && (newModule || params.rerun)) {\n\t                        tempRunBlocks = tempRunBlocks.concat(runBlocks[moduleName]);\n\t                    }\n\t                    _invokeQueue(providers, moduleFn._invokeQueue, moduleName, params.reconfig);\n\t                    _invokeQueue(providers, moduleFn._configBlocks, moduleName, params.reconfig); // angular 1.3+\n\t                    broadcast(newModule ? 'ocLazyLoad.moduleLoaded' : 'ocLazyLoad.moduleReloaded', moduleName);\n\t                    registerModules.pop();\n\t                    justLoaded.push(moduleName);\n\t                }\n\t                // execute the run blocks at the end\n\t                var instanceInjector = providers.getInstanceInjector();\n\t                angular.forEach(tempRunBlocks, function (fn) {\n\t                    instanceInjector.invoke(fn);\n\t                });\n\t            }\n\t        }\n\t\n\t        function _registerInvokeList(args, moduleName) {\n\t            var invokeList = args[2][0],\n\t                type = args[1],\n\t                newInvoke = false;\n\t            if (angular.isUndefined(regInvokes[moduleName])) {\n\t                regInvokes[moduleName] = {};\n\t            }\n\t            if (angular.isUndefined(regInvokes[moduleName][type])) {\n\t                regInvokes[moduleName][type] = {};\n\t            }\n\t            var onInvoke = function onInvoke(invokeName, invoke) {\n\t                if (!regInvokes[moduleName][type].hasOwnProperty(invokeName)) {\n\t                    regInvokes[moduleName][type][invokeName] = [];\n\t                }\n\t                if (checkHashes(invoke, regInvokes[moduleName][type][invokeName])) {\n\t                    newInvoke = true;\n\t                    regInvokes[moduleName][type][invokeName].push(invoke);\n\t                    broadcast('ocLazyLoad.componentLoaded', [moduleName, type, invokeName]);\n\t                }\n\t            };\n\t\n\t            function checkHashes(potentialNew, invokes) {\n\t                var isNew = true,\n\t                    newHash;\n\t                if (invokes.length) {\n\t                    newHash = signature(potentialNew);\n\t                    angular.forEach(invokes, function (invoke) {\n\t                        isNew = isNew && signature(invoke) !== newHash;\n\t                    });\n\t                }\n\t                return isNew;\n\t            }\n\t\n\t            function signature(data) {\n\t                if (angular.isArray(data)) {\n\t                    // arrays are objects, we need to test for it first\n\t                    return hashCode(data.toString());\n\t                } else if (angular.isObject(data)) {\n\t                    // constants & values for example\n\t                    return hashCode(stringify(data));\n\t                } else {\n\t                    if (angular.isDefined(data) && data !== null) {\n\t                        return hashCode(data.toString());\n\t                    } else {\n\t                        // null & undefined constants\n\t                        return data;\n\t                    }\n\t                }\n\t            }\n\t\n\t            if (angular.isString(invokeList)) {\n\t                onInvoke(invokeList, args[2][1]);\n\t            } else if (angular.isObject(invokeList)) {\n\t                angular.forEach(invokeList, function (invoke, key) {\n\t                    if (angular.isString(invoke)) {\n\t                        // decorators for example\n\t                        onInvoke(invoke, invokeList[1]);\n\t                    } else {\n\t                        // components registered as object lists {\"componentName\": function() {}}\n\t                        onInvoke(key, invoke);\n\t                    }\n\t                });\n\t            } else {\n\t                return false;\n\t            }\n\t            return newInvoke;\n\t        }\n\t\n\t        function _invokeQueue(providers, queue, moduleName, reconfig) {\n\t            if (!queue) {\n\t                return;\n\t            }\n\t\n\t            var i, len, args, provider;\n\t            for (i = 0, len = queue.length; i < len; i++) {\n\t                args = queue[i];\n\t                if (angular.isArray(args)) {\n\t                    if (providers !== null) {\n\t                        if (providers.hasOwnProperty(args[0])) {\n\t                            provider = providers[args[0]];\n\t                        } else {\n\t                            throw new Error('unsupported provider ' + args[0]);\n\t                        }\n\t                    }\n\t                    var isNew = _registerInvokeList(args, moduleName);\n\t                    if (args[1] !== 'invoke') {\n\t                        if (isNew && angular.isDefined(provider)) {\n\t                            provider[args[1]].apply(provider, args[2]);\n\t                        }\n\t                    } else {\n\t                        // config block\n\t                        var callInvoke = function callInvoke(fct) {\n\t                            var invoked = regConfigs.indexOf(moduleName + '-' + fct);\n\t                            if (invoked === -1 || reconfig) {\n\t                                if (invoked === -1) {\n\t                                    regConfigs.push(moduleName + '-' + fct);\n\t                                }\n\t                                if (angular.isDefined(provider)) {\n\t                                    provider[args[1]].apply(provider, args[2]);\n\t                                }\n\t                            }\n\t                        };\n\t                        if (angular.isFunction(args[2][0])) {\n\t                            callInvoke(args[2][0]);\n\t                        } else if (angular.isArray(args[2][0])) {\n\t                            for (var j = 0, jlen = args[2][0].length; j < jlen; j++) {\n\t                                if (angular.isFunction(args[2][0][j])) {\n\t                                    callInvoke(args[2][0][j]);\n\t                                }\n\t                            }\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        }\n\t\n\t        function getModuleName(module) {\n\t            var moduleName = null;\n\t            if (angular.isString(module)) {\n\t                moduleName = module;\n\t            } else if (angular.isObject(module) && module.hasOwnProperty('name') && angular.isString(module.name)) {\n\t                moduleName = module.name;\n\t            }\n\t            return moduleName;\n\t        }\n\t\n\t        function moduleExists(moduleName) {\n\t            if (!angular.isString(moduleName)) {\n\t                return false;\n\t            }\n\t            try {\n\t                return ngModuleFct(moduleName);\n\t            } catch (e) {\n\t                if (/No module/.test(e) || e.message.indexOf('$injector:nomod') > -1) {\n\t                    return false;\n\t                }\n\t            }\n\t        }\n\t\n\t        this.$get = [\"$log\", \"$rootElement\", \"$rootScope\", \"$cacheFactory\", \"$q\", function ($log, $rootElement, $rootScope, $cacheFactory, $q) {\n\t            var instanceInjector,\n\t                filesCache = $cacheFactory('ocLazyLoad');\n\t\n\t            if (!debug) {\n\t                $log = {};\n\t                $log['error'] = angular.noop;\n\t                $log['warn'] = angular.noop;\n\t                $log['info'] = angular.noop;\n\t            }\n\t\n\t            // Make this lazy because when $get() is called the instance injector hasn't been assigned to the rootElement yet\n\t            providers.getInstanceInjector = function () {\n\t                return instanceInjector ? instanceInjector : instanceInjector = $rootElement.data('$injector') || angular.injector();\n\t            };\n\t\n\t            broadcast = function broadcast(eventName, params) {\n\t                if (events) {\n\t                    $rootScope.$broadcast(eventName, params);\n\t                }\n\t                if (debug) {\n\t                    $log.info(eventName, params);\n\t                }\n\t            };\n\t\n\t            function reject(e) {\n\t                var deferred = $q.defer();\n\t                $log.error(e.message);\n\t                deferred.reject(e);\n\t                return deferred.promise;\n\t            }\n\t\n\t            return {\n\t                _broadcast: broadcast,\n\t\n\t                _$log: $log,\n\t\n\t                /**\n\t                 * Returns the files cache used by the loaders to store the files currently loading\n\t                 * @returns {*}\n\t                 */\n\t                _getFilesCache: function getFilesCache() {\n\t                    return filesCache;\n\t                },\n\t\n\t                /**\n\t                 * Let the service know that it should monitor angular.module because files are loading\n\t                 * @param watch boolean\n\t                 */\n\t                toggleWatch: function toggleWatch(watch) {\n\t                    if (watch) {\n\t                        recordDeclarations.push(true);\n\t                    } else {\n\t                        recordDeclarations.pop();\n\t                    }\n\t                },\n\t\n\t                /**\n\t                 * Let you get a module config object\n\t                 * @param moduleName String the name of the module\n\t                 * @returns {*}\n\t                 */\n\t                getModuleConfig: function getModuleConfig(moduleName) {\n\t                    if (!angular.isString(moduleName)) {\n\t                        throw new Error('You need to give the name of the module to get');\n\t                    }\n\t                    if (!modules[moduleName]) {\n\t                        return null;\n\t                    }\n\t                    return angular.copy(modules[moduleName]);\n\t                },\n\t\n\t                /**\n\t                 * Let you define a module config object\n\t                 * @param moduleConfig Object the module config object\n\t                 * @returns {*}\n\t                 */\n\t                setModuleConfig: function setModuleConfig(moduleConfig) {\n\t                    if (!angular.isObject(moduleConfig)) {\n\t                        throw new Error('You need to give the module config object to set');\n\t                    }\n\t                    modules[moduleConfig.name] = moduleConfig;\n\t                    return moduleConfig;\n\t                },\n\t\n\t                /**\n\t                 * Returns the list of loaded modules\n\t                 * @returns {string[]}\n\t                 */\n\t                getModules: function getModules() {\n\t                    return regModules;\n\t                },\n\t\n\t                /**\n\t                 * Let you check if a module has been loaded into Angular or not\n\t                 * @param modulesNames String/Object a module name, or a list of module names\n\t                 * @returns {boolean}\n\t                 */\n\t                isLoaded: function isLoaded(modulesNames) {\n\t                    var moduleLoaded = function moduleLoaded(module) {\n\t                        var isLoaded = regModules.indexOf(module) > -1;\n\t                        if (!isLoaded) {\n\t                            isLoaded = !!moduleExists(module);\n\t                        }\n\t                        return isLoaded;\n\t                    };\n\t                    if (angular.isString(modulesNames)) {\n\t                        modulesNames = [modulesNames];\n\t                    }\n\t                    if (angular.isArray(modulesNames)) {\n\t                        var i, len;\n\t                        for (i = 0, len = modulesNames.length; i < len; i++) {\n\t                            if (!moduleLoaded(modulesNames[i])) {\n\t                                return false;\n\t                            }\n\t                        }\n\t                        return true;\n\t                    } else {\n\t                        throw new Error('You need to define the module(s) name(s)');\n\t                    }\n\t                },\n\t\n\t                /**\n\t                 * Given a module, return its name\n\t                 * @param module\n\t                 * @returns {String}\n\t                 */\n\t                _getModuleName: getModuleName,\n\t\n\t                /**\n\t                 * Returns a module if it exists\n\t                 * @param moduleName\n\t                 * @returns {module}\n\t                 */\n\t                _getModule: function getModule(moduleName) {\n\t                    try {\n\t                        return ngModuleFct(moduleName);\n\t                    } catch (e) {\n\t                        // this error message really suxx\n\t                        if (/No module/.test(e) || e.message.indexOf('$injector:nomod') > -1) {\n\t                            e.message = 'The module \"' + stringify(moduleName) + '\" that you are trying to load does not exist. ' + e.message;\n\t                        }\n\t                        throw e;\n\t                    }\n\t                },\n\t\n\t                /**\n\t                 * Check if a module exists and returns it if it does\n\t                 * @param moduleName\n\t                 * @returns {boolean}\n\t                 */\n\t                moduleExists: moduleExists,\n\t\n\t                /**\n\t                 * Load the dependencies, and might try to load new files depending on the config\n\t                 * @param moduleName (String or Array of Strings)\n\t                 * @param localParams\n\t                 * @returns {*}\n\t                 * @private\n\t                 */\n\t                _loadDependencies: function _loadDependencies(moduleName, localParams) {\n\t                    var loadedModule,\n\t                        requires,\n\t                        diff,\n\t                        promisesList = [],\n\t                        self = this;\n\t\n\t                    moduleName = self._getModuleName(moduleName);\n\t\n\t                    if (moduleName === null) {\n\t                        return $q.when();\n\t                    } else {\n\t                        try {\n\t                            loadedModule = self._getModule(moduleName);\n\t                        } catch (e) {\n\t                            return reject(e);\n\t                        }\n\t                        // get unloaded requires\n\t                        requires = self.getRequires(loadedModule);\n\t                    }\n\t\n\t                    angular.forEach(requires, function (requireEntry) {\n\t                        // If no configuration is provided, try and find one from a previous load.\n\t                        // If there isn't one, bail and let the normal flow run\n\t                        if (angular.isString(requireEntry)) {\n\t                            var config = self.getModuleConfig(requireEntry);\n\t                            if (config === null) {\n\t                                moduleCache.push(requireEntry); // We don't know about this module, but something else might, so push it anyway.\n\t                                return;\n\t                            }\n\t                            requireEntry = config;\n\t                            // ignore the name because it's probably not a real module name\n\t                            config.name = undefined;\n\t                        }\n\t\n\t                        // Check if this dependency has been loaded previously\n\t                        if (self.moduleExists(requireEntry.name)) {\n\t                            // compare against the already loaded module to see if the new definition adds any new files\n\t                            diff = requireEntry.files.filter(function (n) {\n\t                                return self.getModuleConfig(requireEntry.name).files.indexOf(n) < 0;\n\t                            });\n\t\n\t                            // If the module was redefined, advise via the console\n\t                            if (diff.length !== 0) {\n\t                                self._$log.warn('Module \"', moduleName, '\" attempted to redefine configuration for dependency. \"', requireEntry.name, '\"\\n Additional Files Loaded:', diff);\n\t                            }\n\t\n\t                            // Push everything to the file loader, it will weed out the duplicates.\n\t                            if (angular.isDefined(self.filesLoader)) {\n\t                                // if a files loader is defined\n\t                                promisesList.push(self.filesLoader(requireEntry, localParams).then(function () {\n\t                                    return self._loadDependencies(requireEntry);\n\t                                }));\n\t                            } else {\n\t                                return reject(new Error('Error: New dependencies need to be loaded from external files (' + requireEntry.files + '), but no loader has been defined.'));\n\t                            }\n\t                            return;\n\t                        } else if (angular.isArray(requireEntry)) {\n\t                            var files = [];\n\t                            angular.forEach(requireEntry, function (entry) {\n\t                                // let's check if the entry is a file name or a config name\n\t                                var config = self.getModuleConfig(entry);\n\t                                if (config === null) {\n\t                                    files.push(entry);\n\t                                } else if (config.files) {\n\t                                    files = files.concat(config.files);\n\t                                }\n\t                            });\n\t                            if (files.length > 0) {\n\t                                requireEntry = {\n\t                                    files: files\n\t                                };\n\t                            }\n\t                        } else if (angular.isObject(requireEntry)) {\n\t                            if (requireEntry.hasOwnProperty('name') && requireEntry['name']) {\n\t                                // The dependency doesn't exist in the module cache and is a new configuration, so store and push it.\n\t                                self.setModuleConfig(requireEntry);\n\t                                moduleCache.push(requireEntry['name']);\n\t                            }\n\t                        }\n\t\n\t                        // Check if the dependency has any files that need to be loaded. If there are, push a new promise to the promise list.\n\t                        if (angular.isDefined(requireEntry.files) && requireEntry.files.length !== 0) {\n\t                            if (angular.isDefined(self.filesLoader)) {\n\t                                // if a files loader is defined\n\t                                promisesList.push(self.filesLoader(requireEntry, localParams).then(function () {\n\t                                    return self._loadDependencies(requireEntry);\n\t                                }));\n\t                            } else {\n\t                                return reject(new Error('Error: the module \"' + requireEntry.name + '\" is defined in external files (' + requireEntry.files + '), but no loader has been defined.'));\n\t                            }\n\t                        }\n\t                    });\n\t\n\t                    // Create a wrapper promise to watch the promise list and resolve it once everything is done.\n\t                    return $q.all(promisesList);\n\t                },\n\t\n\t                /**\n\t                 * Inject new modules into Angular\n\t                 * @param moduleName\n\t                 * @param localParams\n\t                 * @param real\n\t                 */\n\t                inject: function inject(moduleName) {\n\t                    var localParams = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\t                    var real = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];\n\t\n\t                    var self = this,\n\t                        deferred = $q.defer();\n\t                    if (angular.isDefined(moduleName) && moduleName !== null) {\n\t                        if (angular.isArray(moduleName)) {\n\t                            var promisesList = [];\n\t                            angular.forEach(moduleName, function (module) {\n\t                                promisesList.push(self.inject(module, localParams, real));\n\t                            });\n\t                            return $q.all(promisesList);\n\t                        } else {\n\t                            self._addToLoadList(self._getModuleName(moduleName), true, real);\n\t                        }\n\t                    }\n\t                    if (modulesToLoad.length > 0) {\n\t                        var res = modulesToLoad.slice(); // clean copy\n\t                        var loadNext = function loadNext(moduleName) {\n\t                            moduleCache.push(moduleName);\n\t                            modulePromises[moduleName] = deferred.promise;\n\t                            self._loadDependencies(moduleName, localParams).then(function success() {\n\t                                try {\n\t                                    justLoaded = [];\n\t                                    _register(providers, moduleCache, localParams);\n\t                                } catch (e) {\n\t                                    self._$log.error(e.message);\n\t                                    deferred.reject(e);\n\t                                    return;\n\t                                }\n\t\n\t                                if (modulesToLoad.length > 0) {\n\t                                    loadNext(modulesToLoad.shift()); // load the next in list\n\t                                } else {\n\t                                        deferred.resolve(res); // everything has been loaded, resolve\n\t                                    }\n\t                            }, function error(err) {\n\t                                deferred.reject(err);\n\t                            });\n\t                        };\n\t\n\t                        // load the first in list\n\t                        loadNext(modulesToLoad.shift());\n\t                    } else if (localParams && localParams.name && modulePromises[localParams.name]) {\n\t                        return modulePromises[localParams.name];\n\t                    } else {\n\t                        deferred.resolve();\n\t                    }\n\t                    return deferred.promise;\n\t                },\n\t\n\t                /**\n\t                 * Get the list of required modules/services/... for this module\n\t                 * @param module\n\t                 * @returns {Array}\n\t                 */\n\t                getRequires: function getRequires(module) {\n\t                    var requires = [];\n\t                    angular.forEach(module.requires, function (requireModule) {\n\t                        if (regModules.indexOf(requireModule) === -1) {\n\t                            requires.push(requireModule);\n\t                        }\n\t                    });\n\t                    return requires;\n\t                },\n\t\n\t                /**\n\t                 * Invoke the new modules & component by their providers\n\t                 * @param providers\n\t                 * @param queue\n\t                 * @param moduleName\n\t                 * @param reconfig\n\t                 * @private\n\t                 */\n\t                _invokeQueue: _invokeQueue,\n\t\n\t                /**\n\t                 * Check if a module has been invoked and registers it if not\n\t                 * @param args\n\t                 * @param moduleName\n\t                 * @returns {boolean} is new\n\t                 */\n\t                _registerInvokeList: _registerInvokeList,\n\t\n\t                /**\n\t                 * Register a new module and loads it, executing the run/config blocks if needed\n\t                 * @param providers\n\t                 * @param registerModules\n\t                 * @param params\n\t                 * @private\n\t                 */\n\t                _register: _register,\n\t\n\t                /**\n\t                 * Add a module name to the list of modules that will be loaded in the next inject\n\t                 * @param name\n\t                 * @param force\n\t                 * @private\n\t                 */\n\t                _addToLoadList: _addToLoadList,\n\t\n\t                /**\n\t                 * Unregister modules (you shouldn't have to use this)\n\t                 * @param modules\n\t                 */\n\t                _unregister: function _unregister(modules) {\n\t                    if (angular.isDefined(modules)) {\n\t                        if (angular.isArray(modules)) {\n\t                            angular.forEach(modules, function (module) {\n\t                                regInvokes[module] = undefined;\n\t                            });\n\t                        }\n\t                    }\n\t                }\n\t            };\n\t        }];\n\t\n\t        // Let's get the list of loaded modules & components\n\t        this._init(angular.element(window.document));\n\t    }]);\n\t\n\t    var bootstrapFct = angular.bootstrap;\n\t    angular.bootstrap = function (element, modules, config) {\n\t        // we use slice to make a clean copy\n\t        angular.forEach(modules.slice(), function (module) {\n\t            _addToLoadList(module, true, true);\n\t        });\n\t        return bootstrapFct(element, modules, config);\n\t    };\n\t\n\t    var _addToLoadList = function _addToLoadList(name, force, real) {\n\t        if ((recordDeclarations.length > 0 || force) && angular.isString(name) && modulesToLoad.indexOf(name) === -1) {\n\t            modulesToLoad.push(name);\n\t            if (real) {\n\t                realModules.push(name);\n\t            }\n\t        }\n\t    };\n\t\n\t    var ngModuleFct = angular.module;\n\t    angular.module = function (name, requires, configFn) {\n\t        _addToLoadList(name, false, true);\n\t        return ngModuleFct(name, requires, configFn);\n\t    };\n\t\n\t    // CommonJS package manager support:\n\t    if (typeof module !== 'undefined' && typeof exports !== 'undefined' && module.exports === exports) {\n\t        module.exports = 'oc.lazyLoad';\n\t    }\n\t})(angular, window);\n\t(function (angular) {\n\t    'use strict';\n\t\n\t    angular.module('oc.lazyLoad').directive('ocLazyLoad', [\"$ocLazyLoad\", \"$compile\", \"$animate\", \"$parse\", \"$timeout\", function ($ocLazyLoad, $compile, $animate, $parse, $timeout) {\n\t        return {\n\t            restrict: 'A',\n\t            terminal: true,\n\t            priority: 1000,\n\t            compile: function compile(element, attrs) {\n\t                // we store the content and remove it before compilation\n\t                var content = element[0].innerHTML;\n\t                element.html('');\n\t\n\t                return function ($scope, $element, $attr) {\n\t                    var model = $parse($attr.ocLazyLoad);\n\t                    $scope.$watch(function () {\n\t                        return model($scope) || $attr.ocLazyLoad; // it can be a module name (string), an object, an array, or a scope reference to any of this\n\t                    }, function (moduleName) {\n\t                        if (angular.isDefined(moduleName)) {\n\t                            $ocLazyLoad.load(moduleName).then(function () {\n\t                                // Attach element contents to DOM and then compile them.\n\t                                // This prevents an issue where IE invalidates saved element objects (HTMLCollections)\n\t                                // of the compiled contents when attaching to the parent DOM.\n\t                                $animate.enter(content, $element);\n\t                                // get the new content & compile it\n\t                                $compile($element.contents())($scope);\n\t                            });\n\t                        }\n\t                    }, true);\n\t                };\n\t            }\n\t        };\n\t    }]);\n\t})(angular);\n\t(function (angular) {\n\t    'use strict';\n\t\n\t    angular.module('oc.lazyLoad').config([\"$provide\", function ($provide) {\n\t        $provide.decorator('$ocLazyLoad', [\"$delegate\", \"$q\", \"$window\", \"$interval\", function ($delegate, $q, $window, $interval) {\n\t            var uaCssChecked = false,\n\t                useCssLoadPatch = false,\n\t                anchor = $window.document.getElementsByTagName('head')[0] || $window.document.getElementsByTagName('body')[0];\n\t\n\t            /**\r\n\t             * Load a js/css file\r\n\t             * @param type\r\n\t             * @param path\r\n\t             * @param params\r\n\t             * @returns promise\r\n\t             */\n\t            $delegate.buildElement = function buildElement(type, path, params) {\n\t                var deferred = $q.defer(),\n\t                    el,\n\t                    loaded,\n\t                    filesCache = $delegate._getFilesCache(),\n\t                    cacheBuster = function cacheBuster(url) {\n\t                    var dc = new Date().getTime();\n\t                    if (url.indexOf('?') >= 0) {\n\t                        if (url.substring(0, url.length - 1) === '&') {\n\t                            return url + '_dc=' + dc;\n\t                        }\n\t                        return url + '&_dc=' + dc;\n\t                    } else {\n\t                        return url + '?_dc=' + dc;\n\t                    }\n\t                };\n\t\n\t                // Store the promise early so the file load can be detected by other parallel lazy loads\n\t                // (ie: multiple routes on one page) a 'true' value isn't sufficient\n\t                // as it causes false positive load results.\n\t                if (angular.isUndefined(filesCache.get(path))) {\n\t                    filesCache.put(path, deferred.promise);\n\t                }\n\t\n\t                // Switch in case more content types are added later\n\t                switch (type) {\n\t                    case 'css':\n\t                        el = $window.document.createElement('link');\n\t                        el.type = 'text/css';\n\t                        el.rel = 'stylesheet';\n\t                        el.href = params.cache === false ? cacheBuster(path) : path;\n\t                        break;\n\t                    case 'js':\n\t                        el = $window.document.createElement('script');\n\t                        el.src = params.cache === false ? cacheBuster(path) : path;\n\t                        break;\n\t                    default:\n\t                        filesCache.remove(path);\n\t                        deferred.reject(new Error('Requested type \"' + type + '\" is not known. Could not inject \"' + path + '\"'));\n\t                        break;\n\t                }\n\t                el.onload = el['onreadystatechange'] = function (e) {\n\t                    if (el['readyState'] && !/^c|loade/.test(el['readyState']) || loaded) return;\n\t                    el.onload = el['onreadystatechange'] = null;\n\t                    loaded = 1;\n\t                    $delegate._broadcast('ocLazyLoad.fileLoaded', path);\n\t                    deferred.resolve();\n\t                };\n\t                el.onerror = function () {\n\t                    filesCache.remove(path);\n\t                    deferred.reject(new Error('Unable to load ' + path));\n\t                };\n\t                el.async = params.serie ? 0 : 1;\n\t\n\t                var insertBeforeElem = anchor.lastChild;\n\t                if (params.insertBefore) {\n\t                    var element = angular.element(angular.isDefined(window.jQuery) ? params.insertBefore : document.querySelector(params.insertBefore));\n\t                    if (element && element.length > 0) {\n\t                        insertBeforeElem = element[0];\n\t                    }\n\t                }\n\t                insertBeforeElem.parentNode.insertBefore(el, insertBeforeElem);\n\t\n\t                /*\r\n\t                 The event load or readystatechange doesn't fire in:\r\n\t                 - iOS < 6       (default mobile browser)\r\n\t                 - Android < 4.4 (default mobile browser)\r\n\t                 - Safari < 6    (desktop browser)\r\n\t                 */\n\t                if (type == 'css') {\n\t                    if (!uaCssChecked) {\n\t                        var ua = $window.navigator.userAgent.toLowerCase();\n\t\n\t                        // iOS < 6\n\t                        if (/iP(hone|od|ad)/.test($window.navigator.platform)) {\n\t                            var v = $window.navigator.appVersion.match(/OS (\\d+)_(\\d+)_?(\\d+)?/);\n\t                            var iOSVersion = parseFloat([parseInt(v[1], 10), parseInt(v[2], 10), parseInt(v[3] || 0, 10)].join('.'));\n\t                            useCssLoadPatch = iOSVersion < 6;\n\t                        } else if (ua.indexOf(\"android\") > -1) {\n\t                            // Android < 4.4\n\t                            var androidVersion = parseFloat(ua.slice(ua.indexOf(\"android\") + 8));\n\t                            useCssLoadPatch = androidVersion < 4.4;\n\t                        } else if (ua.indexOf('safari') > -1) {\n\t                            var versionMatch = ua.match(/version\\/([\\.\\d]+)/i);\n\t                            useCssLoadPatch = versionMatch && versionMatch[1] && parseFloat(versionMatch[1]) < 6;\n\t                        }\n\t                    }\n\t\n\t                    if (useCssLoadPatch) {\n\t                        var tries = 1000; // * 20 = 20000 miliseconds\n\t                        var interval = $interval(function () {\n\t                            try {\n\t                                el.sheet.cssRules;\n\t                                $interval.cancel(interval);\n\t                                el.onload();\n\t                            } catch (e) {\n\t                                if (--tries <= 0) {\n\t                                    el.onerror();\n\t                                }\n\t                            }\n\t                        }, 20);\n\t                    }\n\t                }\n\t\n\t                return deferred.promise;\n\t            };\n\t\n\t            return $delegate;\n\t        }]);\n\t    }]);\n\t})(angular);\n\t(function (angular) {\n\t    'use strict';\n\t\n\t    angular.module('oc.lazyLoad').config([\"$provide\", function ($provide) {\n\t        $provide.decorator('$ocLazyLoad', [\"$delegate\", \"$q\", function ($delegate, $q) {\n\t            /**\r\n\t             * The function that loads new files\r\n\t             * @param config\r\n\t             * @param params\r\n\t             * @returns {*}\r\n\t             */\n\t            $delegate.filesLoader = function filesLoader(config) {\n\t                var params = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\t\n\t                var cssFiles = [],\n\t                    templatesFiles = [],\n\t                    jsFiles = [],\n\t                    promises = [],\n\t                    cachePromise = null,\n\t                    filesCache = $delegate._getFilesCache();\n\t\n\t                $delegate.toggleWatch(true); // start watching angular.module calls\n\t\n\t                angular.extend(params, config);\n\t\n\t                var pushFile = function pushFile(path) {\n\t                    var file_type = null,\n\t                        m;\n\t                    if (angular.isObject(path)) {\n\t                        file_type = path.type;\n\t                        path = path.path;\n\t                    }\n\t                    cachePromise = filesCache.get(path);\n\t                    if (angular.isUndefined(cachePromise) || params.cache === false) {\n\t\n\t                        // always check for requirejs syntax just in case\n\t                        if ((m = /^(css|less|html|htm|js)?(?=!)/.exec(path)) !== null) {\n\t                            // Detect file type using preceding type declaration (ala requireJS)\n\t                            file_type = m[1];\n\t                            path = path.substr(m[1].length + 1, path.length); // Strip the type from the path\n\t                        }\n\t\n\t                        if (!file_type) {\n\t                            if ((m = /[.](css|less|html|htm|js)?((\\?|#).*)?$/.exec(path)) !== null) {\n\t                                // Detect file type via file extension\n\t                                file_type = m[1];\n\t                            } else if (!$delegate.jsLoader.hasOwnProperty('ocLazyLoadLoader') && $delegate.jsLoader.hasOwnProperty('requirejs')) {\n\t                                // requirejs\n\t                                file_type = 'js';\n\t                            } else {\n\t                                $delegate._$log.error('File type could not be determined. ' + path);\n\t                                return;\n\t                            }\n\t                        }\n\t\n\t                        if ((file_type === 'css' || file_type === 'less') && cssFiles.indexOf(path) === -1) {\n\t                            cssFiles.push(path);\n\t                        } else if ((file_type === 'html' || file_type === 'htm') && templatesFiles.indexOf(path) === -1) {\n\t                            templatesFiles.push(path);\n\t                        } else if (file_type === 'js' || jsFiles.indexOf(path) === -1) {\n\t                            jsFiles.push(path);\n\t                        } else {\n\t                            $delegate._$log.error('File type is not valid. ' + path);\n\t                        }\n\t                    } else if (cachePromise) {\n\t                        promises.push(cachePromise);\n\t                    }\n\t                };\n\t\n\t                if (params.serie) {\n\t                    pushFile(params.files.shift());\n\t                } else {\n\t                    angular.forEach(params.files, function (path) {\n\t                        pushFile(path);\n\t                    });\n\t                }\n\t\n\t                if (cssFiles.length > 0) {\n\t                    var cssDeferred = $q.defer();\n\t                    $delegate.cssLoader(cssFiles, function (err) {\n\t                        if (angular.isDefined(err) && $delegate.cssLoader.hasOwnProperty('ocLazyLoadLoader')) {\n\t                            $delegate._$log.error(err);\n\t                            cssDeferred.reject(err);\n\t                        } else {\n\t                            cssDeferred.resolve();\n\t                        }\n\t                    }, params);\n\t                    promises.push(cssDeferred.promise);\n\t                }\n\t\n\t                if (templatesFiles.length > 0) {\n\t                    var templatesDeferred = $q.defer();\n\t                    $delegate.templatesLoader(templatesFiles, function (err) {\n\t                        if (angular.isDefined(err) && $delegate.templatesLoader.hasOwnProperty('ocLazyLoadLoader')) {\n\t                            $delegate._$log.error(err);\n\t                            templatesDeferred.reject(err);\n\t                        } else {\n\t                            templatesDeferred.resolve();\n\t                        }\n\t                    }, params);\n\t                    promises.push(templatesDeferred.promise);\n\t                }\n\t\n\t                if (jsFiles.length > 0) {\n\t                    var jsDeferred = $q.defer();\n\t                    $delegate.jsLoader(jsFiles, function (err) {\n\t                        if (angular.isDefined(err) && ($delegate.jsLoader.hasOwnProperty(\"ocLazyLoadLoader\") || $delegate.jsLoader.hasOwnProperty(\"requirejs\"))) {\n\t                            $delegate._$log.error(err);\n\t                            jsDeferred.reject(err);\n\t                        } else {\n\t                            jsDeferred.resolve();\n\t                        }\n\t                    }, params);\n\t                    promises.push(jsDeferred.promise);\n\t                }\n\t\n\t                if (promises.length === 0) {\n\t                    var deferred = $q.defer(),\n\t                        err = \"Error: no file to load has been found, if you're trying to load an existing module you should use the 'inject' method instead of 'load'.\";\n\t                    $delegate._$log.error(err);\n\t                    deferred.reject(err);\n\t                    return deferred.promise;\n\t                } else if (params.serie && params.files.length > 0) {\n\t                    return $q.all(promises).then(function () {\n\t                        return $delegate.filesLoader(config, params);\n\t                    });\n\t                } else {\n\t                    return $q.all(promises)['finally'](function (res) {\n\t                        $delegate.toggleWatch(false); // stop watching angular.module calls\n\t                        return res;\n\t                    });\n\t                }\n\t            };\n\t\n\t            /**\r\n\t             * Load a module or a list of modules into Angular\r\n\t             * @param module Mixed the name of a predefined module config object, or a module config object, or an array of either\r\n\t             * @param params Object optional parameters\r\n\t             * @returns promise\r\n\t             */\n\t            $delegate.load = function (originalModule) {\n\t                var originalParams = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\t\n\t                var self = this,\n\t                    config = null,\n\t                    deferredList = [],\n\t                    deferred = $q.defer(),\n\t                    errText;\n\t\n\t                // clean copy\n\t                var module = angular.copy(originalModule);\n\t                var params = angular.copy(originalParams);\n\t\n\t                // If module is an array, break it down\n\t                if (angular.isArray(module)) {\n\t                    // Resubmit each entry as a single module\n\t                    angular.forEach(module, function (m) {\n\t                        deferredList.push(self.load(m, params));\n\t                    });\n\t\n\t                    // Resolve the promise once everything has loaded\n\t                    $q.all(deferredList).then(function (res) {\n\t                        deferred.resolve(res);\n\t                    }, function (err) {\n\t                        deferred.reject(err);\n\t                    });\n\t\n\t                    return deferred.promise;\n\t                }\n\t\n\t                // Get or Set a configuration depending on what was passed in\n\t                if (angular.isString(module)) {\n\t                    config = self.getModuleConfig(module);\n\t                    if (!config) {\n\t                        config = {\n\t                            files: [module]\n\t                        };\n\t                    }\n\t                } else if (angular.isObject(module)) {\n\t                    // case {type: 'js', path: lazyLoadUrl + 'testModule.fakejs'}\n\t                    if (angular.isDefined(module.path) && angular.isDefined(module.type)) {\n\t                        config = {\n\t                            files: [module]\n\t                        };\n\t                    } else {\n\t                        config = self.setModuleConfig(module);\n\t                    }\n\t                }\n\t\n\t                if (config === null) {\n\t                    var moduleName = self._getModuleName(module);\n\t                    errText = 'Module \"' + (moduleName || 'unknown') + '\" is not configured, cannot load.';\n\t                    $delegate._$log.error(errText);\n\t                    deferred.reject(new Error(errText));\n\t                    return deferred.promise;\n\t                } else {\n\t                    // deprecated\n\t                    if (angular.isDefined(config.template)) {\n\t                        if (angular.isUndefined(config.files)) {\n\t                            config.files = [];\n\t                        }\n\t                        if (angular.isString(config.template)) {\n\t                            config.files.push(config.template);\n\t                        } else if (angular.isArray(config.template)) {\n\t                            config.files.concat(config.template);\n\t                        }\n\t                    }\n\t                }\n\t\n\t                var localParams = angular.extend({}, params, config);\n\t\n\t                // if someone used an external loader and called the load function with just the module name\n\t                if (angular.isUndefined(config.files) && angular.isDefined(config.name) && $delegate.moduleExists(config.name)) {\n\t                    return $delegate.inject(config.name, localParams, true);\n\t                }\n\t\n\t                $delegate.filesLoader(config, localParams).then(function () {\n\t                    $delegate.inject(null, localParams).then(function (res) {\n\t                        deferred.resolve(res);\n\t                    }, function (err) {\n\t                        deferred.reject(err);\n\t                    });\n\t                }, function (err) {\n\t                    deferred.reject(err);\n\t                });\n\t\n\t                return deferred.promise;\n\t            };\n\t\n\t            // return the patched service\n\t            return $delegate;\n\t        }]);\n\t    }]);\n\t})(angular);\n\t(function (angular) {\n\t    'use strict';\n\t\n\t    angular.module('oc.lazyLoad').config([\"$provide\", function ($provide) {\n\t        $provide.decorator('$ocLazyLoad', [\"$delegate\", \"$q\", function ($delegate, $q) {\n\t            /**\n\t             * cssLoader function\n\t             * @type Function\n\t             * @param paths array list of css files to load\n\t             * @param callback to call when everything is loaded. We use a callback and not a promise\n\t             * @param params object config parameters\n\t             * because the user can overwrite cssLoader and it will probably not use promises :(\n\t             */\n\t            $delegate.cssLoader = function (paths, callback, params) {\n\t                var promises = [];\n\t                angular.forEach(paths, function (path) {\n\t                    promises.push($delegate.buildElement('css', path, params));\n\t                });\n\t                $q.all(promises).then(function () {\n\t                    callback();\n\t                }, function (err) {\n\t                    callback(err);\n\t                });\n\t            };\n\t            $delegate.cssLoader.ocLazyLoadLoader = true;\n\t\n\t            return $delegate;\n\t        }]);\n\t    }]);\n\t})(angular);\n\t(function (angular) {\n\t    'use strict';\n\t\n\t    angular.module('oc.lazyLoad').config([\"$provide\", function ($provide) {\n\t        $provide.decorator('$ocLazyLoad', [\"$delegate\", \"$q\", function ($delegate, $q) {\n\t            /**\n\t             * jsLoader function\n\t             * @type Function\n\t             * @param paths array list of js files to load\n\t             * @param callback to call when everything is loaded. We use a callback and not a promise\n\t             * @param params object config parameters\n\t             * because the user can overwrite jsLoader and it will probably not use promises :(\n\t             */\n\t            $delegate.jsLoader = function (paths, callback, params) {\n\t                var promises = [];\n\t                angular.forEach(paths, function (path) {\n\t                    promises.push($delegate.buildElement('js', path, params));\n\t                });\n\t                $q.all(promises).then(function () {\n\t                    callback();\n\t                }, function (err) {\n\t                    callback(err);\n\t                });\n\t            };\n\t            $delegate.jsLoader.ocLazyLoadLoader = true;\n\t\n\t            return $delegate;\n\t        }]);\n\t    }]);\n\t})(angular);\n\t(function (angular) {\n\t    'use strict';\n\t\n\t    angular.module('oc.lazyLoad').config([\"$provide\", function ($provide) {\n\t        $provide.decorator('$ocLazyLoad', [\"$delegate\", \"$templateCache\", \"$q\", \"$http\", function ($delegate, $templateCache, $q, $http) {\n\t            /**\n\t             * templatesLoader function\n\t             * @type Function\n\t             * @param paths array list of css files to load\n\t             * @param callback to call when everything is loaded. We use a callback and not a promise\n\t             * @param params object config parameters for $http\n\t             * because the user can overwrite templatesLoader and it will probably not use promises :(\n\t             */\n\t            $delegate.templatesLoader = function (paths, callback, params) {\n\t                var promises = [],\n\t                    filesCache = $delegate._getFilesCache();\n\t\n\t                angular.forEach(paths, function (url) {\n\t                    var deferred = $q.defer();\n\t                    promises.push(deferred.promise);\n\t                    $http.get(url, params).success(function (data) {\n\t                        if (angular.isString(data) && data.length > 0) {\n\t                            angular.forEach(angular.element(data), function (node) {\n\t                                if (node.nodeName === 'SCRIPT' && node.type === 'text/ng-template') {\n\t                                    $templateCache.put(node.id, node.innerHTML);\n\t                                }\n\t                            });\n\t                        }\n\t                        if (angular.isUndefined(filesCache.get(url))) {\n\t                            filesCache.put(url, true);\n\t                        }\n\t                        deferred.resolve();\n\t                    }).error(function (err) {\n\t                        deferred.reject(new Error('Unable to load template file \"' + url + '\": ' + err));\n\t                    });\n\t                });\n\t                return $q.all(promises).then(function () {\n\t                    callback();\n\t                }, function (err) {\n\t                    callback(err);\n\t                });\n\t            };\n\t            $delegate.templatesLoader.ocLazyLoadLoader = true;\n\t\n\t            return $delegate;\n\t        }]);\n\t    }]);\n\t})(angular);\n\t// Array.indexOf polyfill for IE8\n\tif (!Array.prototype.indexOf) {\n\t    Array.prototype.indexOf = function (searchElement, fromIndex) {\n\t        var k;\n\t\n\t        // 1. Let O be the result of calling ToObject passing\n\t        //    the this value as the argument.\n\t        if (this == null) {\n\t            throw new TypeError('\"this\" is null or not defined');\n\t        }\n\t\n\t        var O = Object(this);\n\t\n\t        // 2. Let lenValue be the result of calling the Get\n\t        //    internal method of O with the argument \"length\".\n\t        // 3. Let len be ToUint32(lenValue).\n\t        var len = O.length >>> 0;\n\t\n\t        // 4. If len is 0, return -1.\n\t        if (len === 0) {\n\t            return -1;\n\t        }\n\t\n\t        // 5. If argument fromIndex was passed let n be\n\t        //    ToInteger(fromIndex); else let n be 0.\n\t        var n = +fromIndex || 0;\n\t\n\t        if (Math.abs(n) === Infinity) {\n\t            n = 0;\n\t        }\n\t\n\t        // 6. If n >= len, return -1.\n\t        if (n >= len) {\n\t            return -1;\n\t        }\n\t\n\t        // 7. If n >= 0, then Let k be n.\n\t        // 8. Else, n<0, Let k be len - abs(n).\n\t        //    If k is less than 0, then let k be 0.\n\t        k = Math.max(n >= 0 ? n : len - Math.abs(n), 0);\n\t\n\t        // 9. Repeat, while k < len\n\t        while (k < len) {\n\t            // a. Let Pk be ToString(k).\n\t            //   This is implicit for LHS operands of the in operator\n\t            // b. Let kPresent be the result of calling the\n\t            //    HasProperty internal method of O with argument Pk.\n\t            //   This step can be combined with c\n\t            // c. If kPresent is true, then\n\t            //    i.  Let elementK be the result of calling the Get\n\t            //        internal method of O with the argument ToString(k).\n\t            //   ii.  Let same be the result of applying the\n\t            //        Strict Equality Comparison Algorithm to\n\t            //        searchElement and elementK.\n\t            //  iii.  If same is true, return k.\n\t            if (k in O && O[k] === searchElement) {\n\t                return k;\n\t            }\n\t            k++;\n\t        }\n\t        return -1;\n\t    };\n\t}\n\n/***/ },\n/* 16 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.default = appRouter;\n\t\n\tvar _insert = __webpack_require__(17);\n\t\n\tvar _insert2 = _interopRequireDefault(_insert);\n\t\n\tvar _config = __webpack_require__(18);\n\t\n\tvar _config2 = _interopRequireDefault(_config);\n\t\n\tvar _tokenRefreshInterceptor = __webpack_require__(19);\n\t\n\tvar _tokenRefreshInterceptor2 = _interopRequireDefault(_tokenRefreshInterceptor);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t(0, _tokenRefreshInterceptor.setRefreshTokenUrl)(_config2.default.passport + '/credentials/refresh'); /**\r\n\t                                                                                                       * @author Created by taoyong\r\n\t                                                                                                       * @Date  on 2016/9/1.\r\n\t                                                                                                       */\n\t\n\t(0, _tokenRefreshInterceptor.setAuthFailedBehavior)(function () {\n\t  if (true) {\n\t    location.replace('/portal/timeout.html');\n\t  } else {\n\t    location.replace('/portal/login.html');\n\t  }\n\t});\n\t\n\tfunction appRouter($projectProvider, $httpProvider) {\n\t  $httpProvider.defaults.withCredentials = true;\n\t  // interceptor\n\t  $httpProvider.interceptors.push(function () {\n\t    return _tokenRefreshInterceptor2.default;\n\t  });\n\t\n\t  // 401\n\t  $httpProvider.interceptors.push(['$q', function ($q) {\n\t    return {\n\t      responseError: function responseError(response) {\n\t        if (response.status === 401) {\n\t          if (true) {\n\t            location.replace('/portal/timeout.html');\n\t          } else {\n\t            location.replace('/portal/login.html');\n\t          }\n\t        };\n\t        return $q.reject(response);\n\t      }\n\t    };\n\t  }]);\n\t\n\t  Object.freeze($httpProvider);\n\t\n\t  $projectProvider.state('ebm', {\n\t    url: '/ebm',\n\t    templateUrl: '/ebm/index.html?_=' + (1490150682860)\n\t  }).state('wxcrm', {\n\t    url: '/wxcrm',\n\t    templateUrl: '/wxcrm-web/index.html?_=' + (1490150682860)\n\t  }).state('branding', {\n\t    url: '/branding',\n\t    templateUrl: '/branding/index.html?_=' + (1490150682860)\n\t  }).state('customer', {\n\t    url: '/customer',\n\t    templateUrl: '/customer/index.html?_=' + (1490150682860)\n\t  }).state('insert', {\n\t    url: '/insert/{context}',\n\t    templateUrl: _insert2.default\n\t  }).state('dashboard', {\n\t    url: '/dashboard',\n\t    templateUrl: '/ccms/modules/dashboard/index.html?_=' + (1490150682860)\n\t  }).state('campagin', {\n\t    url: '/campagin',\n\t    templateUrl: '/ccms/modules/marketing/index.html?_=' + (1490150682860)\n\t  }).state('systemManage', {\n\t    url: '/systemManage',\n\t    templateUrl: '/ccms/modules/systemManage/index.html?_=' + (1490150682860)\n\t  }).state('dataManagement', {\n\t    url: '/dataManagement',\n\t    templateUrl: '/ccms/modules/dataManagement/index.html?_=' + (1490150682860)\n\t  }).state('benefitManage', {\n\t    url: '/benefitManage',\n\t    templateUrl: '/ccms/modules/benefitManage/index.html?_=' + (1490150682860)\n\t  }).state('portlet', {\n\t    url: '/portlet',\n\t    templateUrl: '/portlet/index.html?_=' + (1490150682860)\n\t  });\n\t};\n\tappRouter.$inject = ['$projectProvider', '$httpProvider'];\n\n/***/ },\n/* 17 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__.p + \"app/insert/insert-11b229793b65674a03b5.html\";\n\n/***/ },\n/* 18 */,\n/* 19 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\texports.refreshTokenUrl = exports.execAuthFailure = undefined;\n\texports.setAuthFailedBehavior = setAuthFailedBehavior;\n\texports.setRefreshTokenUrl = setRefreshTokenUrl;\n\t\n\tvar _credentials = __webpack_require__(20);\n\t\n\tvar _metadata = __webpack_require__(22);\n\t\n\tfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; } /**\n\t                                                                                                                                                                                                                   * @author Kuitos\n\t                                                                                                                                                                                                                   * @homepage https://github.com/kuitos/\n\t                                                                                                                                                                                                                   * @since 2016-09-09\n\t                                                                                                                                                                                                                   */\n\t\n\t\n\tvar needToRefreshToken = false;\n\t\n\tvar execAuthFailure = exports.execAuthFailure = function execAuthFailure() {};\n\tfunction setAuthFailedBehavior() {\n\t\tvar fn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : execAuthFailure;\n\t\n\t\n\t\texports.execAuthFailure = execAuthFailure = function execAuthFailure(rejection) {\n\t\n\t\t\ttry {\n\t\t\t\tfn();\n\t\t\t} finally {\n\t\t\t\t(0, _credentials.removeRequestCredential)();\n\t\t\t}\n\t\n\t\t\tvar ex = new TypeError('Unauthorized! Credential was expired or had been removed, pls set it before the get action!');\n\t\t\tconsole.error(ex);\n\t\n\t\t\tif (typeof rejection.abort === 'function') {\n\t\t\t\trejection.abort(ex);\n\t\t\t} else {\n\t\t\t\trejection.status = rejection.status || 401;\n\t\t\t\trejection.statusText = rejection.statusText || 'Unauthorized!';\n\t\t\t\tvar injector = __webpack_require__(23).default;\n\t\t\t\treturn injector.get('$q').reject(rejection);\n\t\t\t}\n\t\t};\n\t}\n\t\n\tvar refreshTokenUrl = exports.refreshTokenUrl = '';\n\tfunction setRefreshTokenUrl(url) {\n\t\texports.refreshTokenUrl = refreshTokenUrl = url;\n\t\t_metadata.REQUEST_WHITE_LIST.push(url);\n\t}\n\t\n\texports.default = {\n\t\trequest: function request(config) {\n\t\n\t\t\tvar credential = (0, _credentials.getRequestCredential)();\n\t\t\t// storage 里的状态有可能已经失效\n\t\t\tif (!credential) {\n\t\t\t\treturn execAuthFailure({ config: config });\n\t\t\t}\n\t\n\t\t\tconfig.headers[_metadata.REQUEST_TOKEN_HEADER] = credential.id;\n\t\n\t\t\t// 白名单之外的url做校验\n\t\t\t// TODO 兼容处理,如果拿不到refreshToken说明系统还未升级,则不做刷新token逻辑\n\t\t\tif (credential.refreshToken && _metadata.REQUEST_WHITE_LIST.indexOf(config.url) === -1) {\n\t\n\t\t\t\tvar expireTime = _metadata.Date.parse(credential.expireTime);\n\t\t\t\tvar now = _metadata.Date.now();\n\t\n\t\t\t\t// token失效则直接跳转登录页面\n\t\t\t\t// token未失效但是可用时长已低于用户会话最短保留时间,则需要刷新token\n\t\t\t\tif (_metadata.USER_SESSION_AVAILABLE_TIME >= expireTime - now && expireTime - now >= 0) {\n\t\t\t\t\tneedToRefreshToken = true;\n\t\t\t\t} else if (expireTime - now < 0) {\n\t\t\t\t\t// token失效\n\t\t\t\t\treturn execAuthFailure({ config: config });\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn config;\n\t\t},\n\t\tresponse: function response(_response) {\n\t\n\t\t\t// 如果请求能正常响应,说明 storage 里的状态是存在的,所以这里不做判断\n\t\t\tvar credential = (0, _credentials.getRequestCredential)();\n\t\n\t\t\tvar injector = __webpack_require__(23).default;\n\t\t\tvar $http = injector.get('$http');\n\t\t\t// 所有请求结束了才做refreshToken的操作,避免后端因为token被刷新而导致前一请求失败\n\t\t\tif (needToRefreshToken && $http.pendingRequests.length === 0) {\n\t\n\t\t\t\tneedToRefreshToken = false;\n\t\t\t\t// refresh token\n\t\t\t\t$http.put(refreshTokenUrl, credential.refreshToken, { headers: _defineProperty({}, _metadata.REQUEST_TOKEN_HEADER, credential.id) }).then(function (response) {\n\t\t\t\t\t// 更新localStorage中token信息\n\t\t\t\t\t(0, _credentials.setRequestCredential)(response.data);\n\t\t\t\t}, execAuthFailure);\n\t\t\t}\n\t\n\t\t\treturn _response;\n\t\t}\n\t};\n\n/***/ },\n/* 20 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\texports.getRequestCredential = getRequestCredential;\n\texports.setRequestCredential = setRequestCredential;\n\texports.removeRequestCredential = removeRequestCredential;\n\t\n\tvar _jsCookie = __webpack_require__(21);\n\t\n\tvar _jsCookie2 = _interopRequireDefault(_jsCookie);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar localStorage = window.localStorage; /**\n\t                                         * @author Kuitos\n\t                                         * @homepage https://github.com/kuitos/\n\t                                         * @since 2016-09-29\n\t                                         */\n\t\n\tvar JSON = window.JSON;\n\t\n\tvar REQUEST_TOKEN_STORAGE_KEY = 'ccmsRequestCredential';\n\t\n\tfunction getRequestCredential() {\n\t\n\t\tvar credential = null;\n\t\t// get credential from cookie when inside an iframe\n\t\tif (window.self !== window.top) {\n\t\t\tcredential = _jsCookie2.default.get(REQUEST_TOKEN_STORAGE_KEY) || null;\n\t\t} else {\n\t\t\tcredential = localStorage.getItem(REQUEST_TOKEN_STORAGE_KEY) || null;\n\t\t}\n\t\n\t\treturn JSON.parse(credential);\n\t}\n\t\n\tfunction setRequestCredential(credential) {\n\t\tlocalStorage.setItem(REQUEST_TOKEN_STORAGE_KEY, JSON.stringify(credential));\n\t}\n\t\n\tfunction removeRequestCredential() {\n\t\tlocalStorage.removeItem(REQUEST_TOKEN_STORAGE_KEY);\n\t\t_jsCookie2.default.remove(REQUEST_TOKEN_STORAGE_KEY);\n\t}\n\n/***/ },\n/* 21 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n\t * JavaScript Cookie v2.1.3\n\t * https://github.com/js-cookie/js-cookie\n\t *\n\t * Copyright 2006, 2015 Klaus Hartl & Fagner Brack\n\t * Released under the MIT license\n\t */\n\t;(function (factory) {\n\t\tvar registeredInModuleLoader = false;\n\t\tif (true) {\n\t\t\t!(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t\t\tregisteredInModuleLoader = true;\n\t\t}\n\t\tif (true) {\n\t\t\tmodule.exports = factory();\n\t\t\tregisteredInModuleLoader = true;\n\t\t}\n\t\tif (!registeredInModuleLoader) {\n\t\t\tvar OldCookies = window.Cookies;\n\t\t\tvar api = window.Cookies = factory();\n\t\t\tapi.noConflict = function () {\n\t\t\t\twindow.Cookies = OldCookies;\n\t\t\t\treturn api;\n\t\t\t};\n\t\t}\n\t}(function () {\n\t\tfunction extend () {\n\t\t\tvar i = 0;\n\t\t\tvar result = {};\n\t\t\tfor (; i < arguments.length; i++) {\n\t\t\t\tvar attributes = arguments[ i ];\n\t\t\t\tfor (var key in attributes) {\n\t\t\t\t\tresult[key] = attributes[key];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t\n\t\tfunction init (converter) {\n\t\t\tfunction api (key, value, attributes) {\n\t\t\t\tvar result;\n\t\t\t\tif (typeof document === 'undefined') {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\n\t\t\t\t// Write\n\t\n\t\t\t\tif (arguments.length > 1) {\n\t\t\t\t\tattributes = extend({\n\t\t\t\t\t\tpath: '/'\n\t\t\t\t\t}, api.defaults, attributes);\n\t\n\t\t\t\t\tif (typeof attributes.expires === 'number') {\n\t\t\t\t\t\tvar expires = new Date();\n\t\t\t\t\t\texpires.setMilliseconds(expires.getMilliseconds() + attributes.expires * 864e+5);\n\t\t\t\t\t\tattributes.expires = expires;\n\t\t\t\t\t}\n\t\n\t\t\t\t\ttry {\n\t\t\t\t\t\tresult = JSON.stringify(value);\n\t\t\t\t\t\tif (/^[\\{\\[]/.test(result)) {\n\t\t\t\t\t\t\tvalue = result;\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (e) {}\n\t\n\t\t\t\t\tif (!converter.write) {\n\t\t\t\t\t\tvalue = encodeURIComponent(String(value))\n\t\t\t\t\t\t\t.replace(/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g, decodeURIComponent);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvalue = converter.write(value, key);\n\t\t\t\t\t}\n\t\n\t\t\t\t\tkey = encodeURIComponent(String(key));\n\t\t\t\t\tkey = key.replace(/%(23|24|26|2B|5E|60|7C)/g, decodeURIComponent);\n\t\t\t\t\tkey = key.replace(/[\\(\\)]/g, escape);\n\t\n\t\t\t\t\treturn (document.cookie = [\n\t\t\t\t\t\tkey, '=', value,\n\t\t\t\t\t\tattributes.expires ? '; expires=' + attributes.expires.toUTCString() : '', // use expires attribute, max-age is not supported by IE\n\t\t\t\t\t\tattributes.path ? '; path=' + attributes.path : '',\n\t\t\t\t\t\tattributes.domain ? '; domain=' + attributes.domain : '',\n\t\t\t\t\t\tattributes.secure ? '; secure' : ''\n\t\t\t\t\t].join(''));\n\t\t\t\t}\n\t\n\t\t\t\t// Read\n\t\n\t\t\t\tif (!key) {\n\t\t\t\t\tresult = {};\n\t\t\t\t}\n\t\n\t\t\t\t// To prevent the for loop in the first place assign an empty array\n\t\t\t\t// in case there are no cookies at all. Also prevents odd result when\n\t\t\t\t// calling \"get()\"\n\t\t\t\tvar cookies = document.cookie ? document.cookie.split('; ') : [];\n\t\t\t\tvar rdecode = /(%[0-9A-Z]{2})+/g;\n\t\t\t\tvar i = 0;\n\t\n\t\t\t\tfor (; i < cookies.length; i++) {\n\t\t\t\t\tvar parts = cookies[i].split('=');\n\t\t\t\t\tvar cookie = parts.slice(1).join('=');\n\t\n\t\t\t\t\tif (cookie.charAt(0) === '\"') {\n\t\t\t\t\t\tcookie = cookie.slice(1, -1);\n\t\t\t\t\t}\n\t\n\t\t\t\t\ttry {\n\t\t\t\t\t\tvar name = parts[0].replace(rdecode, decodeURIComponent);\n\t\t\t\t\t\tcookie = converter.read ?\n\t\t\t\t\t\t\tconverter.read(cookie, name) : converter(cookie, name) ||\n\t\t\t\t\t\t\tcookie.replace(rdecode, decodeURIComponent);\n\t\n\t\t\t\t\t\tif (this.json) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tcookie = JSON.parse(cookie);\n\t\t\t\t\t\t\t} catch (e) {}\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif (key === name) {\n\t\t\t\t\t\t\tresult = cookie;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif (!key) {\n\t\t\t\t\t\t\tresult[name] = cookie;\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (e) {}\n\t\t\t\t}\n\t\n\t\t\t\treturn result;\n\t\t\t}\n\t\n\t\t\tapi.set = api;\n\t\t\tapi.get = function (key) {\n\t\t\t\treturn api.call(api, key);\n\t\t\t};\n\t\t\tapi.getJSON = function () {\n\t\t\t\treturn api.apply({\n\t\t\t\t\tjson: true\n\t\t\t\t}, [].slice.call(arguments));\n\t\t\t};\n\t\t\tapi.defaults = {};\n\t\n\t\t\tapi.remove = function (key, attributes) {\n\t\t\t\tapi(key, '', extend(attributes, {\n\t\t\t\t\texpires: -1\n\t\t\t\t}));\n\t\t\t};\n\t\n\t\t\tapi.withConverter = init;\n\t\n\t\t\treturn api;\n\t\t}\n\t\n\t\treturn init(function () {});\n\t}));\n\n\n/***/ },\n/* 22 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t/**\n\t * @author qix\n\t * @homepage https://github.com/qixman/\n\t * @since 2016-10-21\n\t */\n\t\n\tvar Date = exports.Date = window.Date;\n\tvar REQUEST_TOKEN_HEADER = exports.REQUEST_TOKEN_HEADER = 'X-TOKEN';\n\tvar USER_SESSION_AVAILABLE_TIME = exports.USER_SESSION_AVAILABLE_TIME = 30 * 60 * 1000;\n\tvar REQUEST_WHITE_LIST = exports.REQUEST_WHITE_LIST = [];\n\n/***/ },\n/* 23 */\n[67, 24],\n/* 24 */\n34,\n/* 25 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _angular = __webpack_require__(1);\n\t\n\tvar _angular2 = _interopRequireDefault(_angular);\n\t\n\tvar _menu = __webpack_require__(26);\n\t\n\tvar _menu2 = _interopRequireDefault(_menu);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t/*\r\n\t * @author Created by taoyong\r\n\t * @time Created on 16/5/24.\r\n\t */\n\texports.default = _angular2.default.module('common.directive', [_menu2.default]).name;\n\n/***/ },\n/* 26 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\t__webpack_require__(27);\n\t\n\tvar _angular = __webpack_require__(1);\n\t\n\tvar _angular2 = _interopRequireDefault(_angular);\n\t\n\tvar _directive = __webpack_require__(28);\n\t\n\tvar _directive2 = _interopRequireDefault(_directive);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = _angular2.default.module('common.directive.menu', []).run(['$rootScope', function ($rootScope) {\n\t  var execValue = /([^-.]+)\\.(ccms|s1|minicrm)\\./.exec(location.hostname);\n\t  var hostName = execValue && execValue[1] || 'yangyangyang3';\n\t  $rootScope.tenantId = window.sessionStorage.getItem('tenantId');\n\t  $rootScope.hostName = hostName;\n\t}]).config(['$httpProvider', function ($httpProvider) {\n\t  $httpProvider.defaults.useXDomain = true;\n\t  delete $httpProvider.defaults.headers.common['X-Requested-with'];\n\t}]).component('menus', _directive2.default).name; /*\r\n\t                                                   * @author Created by taoyong\r\n\t                                                   * @time Created on 16/5/24.\r\n\t                                                   */\n\n/***/ },\n/* 27 */\n10,\n/* 28 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _menu = __webpack_require__(29);\n\t\n\tvar _menu2 = _interopRequireDefault(_menu);\n\t\n\tvar _controller = __webpack_require__(30);\n\t\n\tvar _controller2 = _interopRequireDefault(_controller);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t/*\r\n\t * @author Created by taoyong\r\n\t * @time Created on 16/5/24.\r\n\t */\n\texports.default = {\n\t  templateUrl: _menu2.default,\n\t  controller: _controller2.default,\n\t  controllerAs: '$menuCtrl'\n\t};\n\n/***/ },\n/* 29 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__.p + \"components/menu/menu-f3f8c360beb898da4c02.html\";\n\n/***/ },\n/* 30 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.default = undefined;\n\t\n\tvar _angular = __webpack_require__(1);\n\t\n\tvar _angular2 = _interopRequireDefault(_angular);\n\t\n\tvar _service = __webpack_require__(31);\n\t\n\tvar _service2 = _interopRequireDefault(_service);\n\t\n\tvar _collectPerInfo = __webpack_require__(35);\n\t\n\tvar _collectPerInfo2 = _interopRequireDefault(_collectPerInfo);\n\t\n\tvar _collectPerCtrl = __webpack_require__(36);\n\t\n\tvar _collectPerCtrl2 = _interopRequireDefault(_collectPerCtrl);\n\t\n\tvar _password = __webpack_require__(37);\n\t\n\tvar _password2 = _interopRequireDefault(_password);\n\t\n\tvar _passwordCtrl = __webpack_require__(38);\n\t\n\tvar _passwordCtrl2 = _interopRequireDefault(_passwordCtrl);\n\t\n\tvar _message = __webpack_require__(39);\n\t\n\tvar _message2 = _interopRequireDefault(_message);\n\t\n\tvar _messageCtrl = __webpack_require__(40);\n\t\n\tvar _messageCtrl2 = _interopRequireDefault(_messageCtrl);\n\t\n\tvar _utils = __webpack_require__(41);\n\t\n\tvar _utils2 = _interopRequireDefault(_utils);\n\t\n\tvar _config = __webpack_require__(18);\n\t\n\tvar _config2 = _interopRequireDefault(_config);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } } /*\r\n\t                                                                                                                                                           * @author Created by taoyong\r\n\t                                                                                                                                                           * @time Created on 16/5/24.\r\n\t                                                                                                                                                           */\n\t\n\t\n\tvar MenuCtrl = function MenuCtrl($http, $location, $rootScope, $timeout, $q, $interval, $ccModal, $ccValidator, $ccTips) {\n\t  _classCallCheck(this, MenuCtrl);\n\t\n\t  var _this = this;\n\t  $rootScope.shuyunLoginUrl = '';\n\t  _this.shopInfoDefer = $q.defer();\n\t  $rootScope.user = _this.user = {\n\t    'name': _this.userName,\n\t    'noticeCount': 58,\n\t    'id': _this.useID\n\t  };\n\t  // 发送_ati给予淘宝日志\n\t  _service2.default.getAti({}, function () {\n\t    // doing\n\t  });\n\t\n\t  // 检查是否到期\n\t  _service2.default.getShopInfo({}, function (data) {\n\t    $rootScope.ccmsVersion = data.version_code;\n\t    _this.shopInfoDefer.resolve();\n\t    if (data.overdue) {\n\t      _this.isExpire = true;\n\t    }\n\t    /* 得到个性化营销的number tip */\n\t    _service2.default.getNumber({}, function (data) {\n\t      _this.unionMarketingNumberShow = data.count * 1 || false;\n\t      _this.unionMarketingNumber = data.count * 1 > 100 ? 99 : data.count;\n\t    }, function (err) {\n\t      _this.unionMarketingNumberShow = false;\n\t      return err;\n\t    });\n\t  }, _angular2.default.noop);\n\t\n\t  // 检验登入\n\t  function checkLogin() {\n\t    _service2.default.checkLogin({}, function (data) {\n\t      // 借用此接口获取下用户\n\t      if (data.expired) {\n\t        // true 需要登录\n\t        var loginUrl;\n\t        if (true) {\n\t          loginUrl = '/portal/timeout.html';\n\t        } else {\n\t          loginUrl = '/portal/login.html';\n\t        }\n\t        location.replace(loginUrl);\n\t      } else {\n\t        _this.userName = data.username;\n\t        _this.useID = data.userId;\n\t        _this.campUserName = data.username;\n\t        _this.user.name = _this.userName;\n\t        _this.user.id = _this.useID;\n\t        $rootScope.tenantId = data.tenantId;\n\t        window.sessionStorage.setItem('tenantId', data.tenantId);\n\t        fetchMenu();\n\t        getContactAjaxMethod();\n\t        _this.getAccountLink();\n\t      }\n\t    }, function (data) {\n\t      var loginUrl;\n\t      if (true) {\n\t        loginUrl = '/portal/timeout.html';\n\t      } else {\n\t        loginUrl = '/portal/login.html';\n\t      }\n\t      location.replace(loginUrl);\n\t    });\n\t  }\n\t\n\t  checkLogin();\n\t\n\t  // 退出账户\n\t  var clearStorage = function clearStorage() {\n\t    window.sessionStorage.removeItem('shuyunSessionMenu');\n\t    window.sessionStorage.removeItem('shuYunMenuHelp');\n\t    window.sessionStorage.removeItem('shuYunSSOlink');\n\t    window.sessionStorage.removeItem('shuyunAccountLink');\n\t    window.sessionStorage.removeItem('shuyunContact');\n\t  };\n\t  _this.logout = function () {\n\t    var modalInstance = $ccModal.confirm('确认退出该用户？');\n\t    modalInstance.open().result.then(function () {\n\t      _service2.default.logOut({}, function () {\n\t        clearStorage();\n\t        if (true) {\n\t          location.replace('/portal/loginout.html');\n\t        } else {\n\t          location.replace('/portal/login.html');\n\t        }\n\t      }, _angular2.default.noop);\n\t    });\n\t  };\n\t  // 修改密码\n\t  _this.changePassword = function () {\n\t    $ccModal.modal({\n\t      title: '修改密码',\n\t      locals: {\n\t        data: [1, 2, 3]\n\t      },\n\t      style: {\n\t        'min-height': '140px',\n\t        'min-width': '630px'\n\t      },\n\t      body: _password2.default,\n\t      controller: _passwordCtrl2.default,\n\t      controllerAs: 'passWordModal',\n\t      bindings: true\n\t    }).open();\n\t  };\n\t\n\t  function fetchMenu() {\n\t    var navAry = [];\n\t    var appSeeionMenu = _angular2.default.fromJson(sessionStorage.getItem('shuyunSessionMenu')); //  '获取菜单缓存'\n\t    if (appSeeionMenu) {\n\t      getSessionMenu(appSeeionMenu);\n\t    } else {\n\t      _service2.default.checkVisit({\n\t        hostName: $rootScope.hostName,\n\t        tenantId: $rootScope.tenantId\n\t      }, function (data) {\n\t        _angular2.default.forEach(data.children, function (n) {\n\t          n.url = root + n.url;\n\t          navAry.push(n);\n\t        });\n\t        _this.user.nav = navAry;\n\t        var stringData = JSON.stringify({\n\t          menuData: _this.user.nav.slice()\n\t        });\n\t        setTimeout(function () {\n\t          _utils2.default.setNavFunction();\n\t        }, 0);\n\t        sessionStorage.setItem('shuyunSessionMenu', stringData);\n\t      }, function () {});\n\t    }\n\t  }\n\t\n\t  function getSessionMenu(data) {\n\t    var appSeeionMenu = data;\n\t    _this.user.nav = appSeeionMenu.menuData.slice();\n\t    setTimeout(function () {\n\t      _utils2.default.setNavFunction();\n\t    }, 0);\n\t  }\n\t\n\t  /* start 是否已经有联系方式 */\n\t  var getContactAjaxMethod = function getContactAjaxMethod() {\n\t    var shuyunContact = window.sessionStorage.getItem('shuyunContact');\n\t    if (shuyunContact) {\n\t      var response = JSON.parse(shuyunContact);\n\t      if (response.exists) {\n\t        _this.addPerInfoFlag = false;\n\t        _this.contactLiFlag = true;\n\t        _this.contactName = response.contact.fullName;\n\t        _this.contactQQ = response.contact.qq;\n\t        _this.contactPhone = response.contact.mobile;\n\t        _this.contactWW = response.contact.wangwang;\n\t        _this.contactEmail = response.contact.email;\n\t        _this.contactWeibo = response.contact.weibo;\n\t      } else {\n\t        _this.addPerInfoFlag = true;\n\t        _this.contactLiFlag = false;\n\t        _this.contactName = '';\n\t        _this.contactQQ = '';\n\t        _this.contactPhone = '';\n\t        _this.contactWW = '';\n\t        _this.contactEmail = '';\n\t        _this.contactWeibo = '';\n\t      }\n\t    } else {\n\t      $http.get(_config2.default.webDashboard + '/dashboard/assemble/contact/exists/?tenantId=' + $rootScope.tenantId).success(function (response) {\n\t        var Stringres = JSON.stringify(response);\n\t        window.sessionStorage.setItem('shuyunContact', Stringres);\n\t        if (response.exists) {\n\t          _this.addPerInfoFlag = false;\n\t          _this.contactLiFlag = true;\n\t          _this.contactName = response.contact.fullName;\n\t          _this.contactQQ = response.contact.qq;\n\t          _this.contactPhone = response.contact.mobile;\n\t          _this.contactWW = response.contact.wangwang;\n\t          _this.contactEmail = response.contact.email;\n\t          _this.contactWeibo = response.contact.weibo;\n\t        } else {\n\t          _this.addPerInfoFlag = true;\n\t          _this.contactLiFlag = false;\n\t          _this.contactName = '';\n\t          _this.contactQQ = '';\n\t          _this.contactPhone = '';\n\t          _this.contactWW = '';\n\t          _this.contactEmail = '';\n\t          _this.contactWeibo = '';\n\t        }\n\t      });\n\t    }\n\t  };\n\t  /* end 是否已经有联系方式 */\n\t\n\t  _this.getContactInfo = function () {\n\t    // 查看联系人信息\n\t    getContactAjaxMethod();\n\t  };\n\t\n\t  _this.cancelAddInfo = function () {\n\t    // 关闭提示\n\t    _this.addPerInfoFlag = false;\n\t  };\n\t\n\t  _this.viewAddPerPop = function () {\n\t    // 弹出信息框\n\t    var modalInstance = $ccModal.modal({\n\t      title: '填写联系人信息',\n\t      style: {\n\t        'min-height': '240px'\n\t      },\n\t      body: _collectPerInfo2.default,\n\t      controller: _collectPerCtrl2.default,\n\t      controllerAs: 'collectModal',\n\t      bindings: true\n\t    }).open();\n\t\n\t    modalInstance.result.then(function (v) {\n\t      _this.addPerInfoFlag = false;\n\t      _this.contactLiFlag = true;\n\t    }, function (v) {});\n\t  };\n\t\n\t  // 获取帮助更多链接\n\t  _this.getHelpLink = function () {\n\t    $http.get(_config2.default.webDashboard + '/dashboard/assemble/helplink/').success(function (response) {\n\t      _this.helplink = response.url;\n\t      window.open(_this.helplink);\n\t    }).error(function (data, status, headers, config) {\n\t      if (data.message) {\n\t        $ccTips.error(data.message, document.querySelector('.content'));\n\t      }\n\t    });\n\t  };\n\t  // 单点登录\n\t  _this.SSOlinkyes = false;\n\t  _this.get5xLink = function () {\n\t    var shuYunSSOlink = window.sessionStorage.getItem('shuYunSSOlink');\n\t    if (shuYunSSOlink) {\n\t      _this.SSOlink = shuYunSSOlink;\n\t      _this.SSOlinkyes = true;\n\t    } else {\n\t      $http.get(_config2.default.webDashboard + '/dashboard/sso/directive/').success(function (resoponse) {\n\t        if (resoponse) {\n\t          _this.SSOlink = resoponse.url;\n\t          _this.SSOlinkyes = true;\n\t          window.sessionStorage.setItem('shuYunSSOlink', resoponse.url);\n\t        }\n\t      }).error(function (data, status, headers, config) {\n\t        if (data.message) {\n\t          $ccTips.error(data.message, document.querySelector('.content'));\n\t        }\n\t      });\n\t    }\n\t  };\n\t  _this.get5xLink();\n\t\n\t  // 获取账户信息链接\n\t  _this.getAccountLink = function () {\n\t    var accountlink = window.sessionStorage.getItem('shuyunAccountLink');\n\t    if (accountlink) {\n\t      _this.accountLink = accountlink;\n\t    } else {\n\t      $http.get(_config2.default.webDashboard + '/dashboard/channel/accountlink/?tenantId=' + $rootScope.tenantId).success(function (response) {\n\t        _this.accountLink = response.url;\n\t        window.sessionStorage.setItem('shuyunAccountLink', response.url);\n\t      }).error(function (data, status, headers, config) {\n\t        if (data.message) {\n\t          $ccTips.error(data.message, document.querySelector('.content'));\n\t        }\n\t      });\n\t    };\n\t  };\n\t\n\t  // 嵌入模板之间相互切换 操作\n\t  $rootScope.resertTemplateClickFlag = true;\n\t  _this.disponseTitleALink = function (data) {\n\t    //  菜单$watch 和嵌入模板click();\n\t    if (data.indexOf('callcenter') !== -1) {\n\t      return 'javascript:void(0)';\n\t    };\n\t\n\t    if (data.indexOf('insert') === -1) {\n\t      return data;\n\t    } else {\n\t      return 'javascript:void(0)';\n\t    }\n\t  };\n\t\n\t  _this.appOrigin = location.protocol + '// ' + location.host; //  获取绝对路径http\n\t  _this.appRoot = root;\n\t\n\t  _this.insertCompileLocation = function (url) {\n\t    $rootScope.resertTemplateClickFlag = false;\n\t    if (url.indexOf('callcenter') !== -1) {\n\t      //  电话模块在新页面操作\n\t      var newUrl = url.substring(8);\n\t      window.open(newUrl);\n\t      return false;\n\t    }\n\t\n\t    if (url.indexOf('insert') !== -1) {\n\t      window.location.href = _this.appOrigin + url;\n\t      if (window.location.href.indexOf('insert') !== -1) {\n\t        window.location.reload();\n\t      }\n\t    }\n\t  };\n\t\n\t  // 弹出更多的弹出框\n\t  _this.showMoreMessageDialog = function () {\n\t    $ccModal.modal({\n\t      title: '系统消息',\n\t      hasFooter: false,\n\t      body: _message2.default,\n\t      style: {\n\t        'min-height': 'auto',\n\t        'max-height': '580px'\n\t      },\n\t      controller: _messageCtrl2.default,\n\t      controllerAs: 'messageModal',\n\t      bindings: {\n\t        campUserName: _this.campUserName\n\t      }\n\t    }).open();\n\t  };\n\t\n\t  // 获取收件箱信息\n\t  var interProm = null;\n\t  var getMessageStatus = function getMessageStatus() {\n\t    var param = {\n\t      'userName': $rootScope.tenantId,\n\t      'ccmsVersion': $rootScope.ccmsVersion\n\t    };\n\t    _service2.default.getStatus(param, function (res) {\n\t      if (res.status) {\n\t        _this.newsTrue = true;\n\t      } else {\n\t        _this.newsTrue = false;\n\t      }\n\t    }, function () {\n\t      interProm && $interval.cancel(interProm);\n\t    });\n\t  };\n\t\n\t  interProm = $interval(function () {\n\t    getMessageStatus();\n\t  }, 60000);\n\t\n\t  _this.shopInfoDefer.promise.then(function () {\n\t    getMessageStatus();\n\t  });\n\t};\n\t\n\texports.default = MenuCtrl;\n\t;\n\tMenuCtrl.$inject = ['$http', '$location', '$rootScope', '$timeout', '$q', '$interval', '$ccModal', '$ccValidator', '$ccTips'];\n\n/***/ },\n/* 31 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _rsGenerator = __webpack_require__(32);\n\t\n\tvar _rsGenerator2 = _interopRequireDefault(_rsGenerator);\n\t\n\tvar _config = __webpack_require__(18);\n\t\n\tvar _config2 = _interopRequireDefault(_config);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t/*\r\n\t * @author Created by taoyong\r\n\t * @time Created on 16/5/24.\r\n\t */\n\texports.default = {\n\t  checkVisit: function checkVisit(param, success, error) {\n\t    var VisitResource = (0, _rsGenerator2.default)(_config2.default.webPortal + '/visits', false);\n\t    VisitResource.save(param, success, error);\n\t  },\n\t  checkLogin: function checkLogin(param, success, error) {\n\t    var CheckResource = (0, _rsGenerator2.default)(_config2.default.webPortal + '/credentials', false);\n\t    CheckResource.get(param, success, error);\n\t  },\n\t  logOut: function logOut(param, success, error) {\n\t    var LoginResource = (0, _rsGenerator2.default)(_config2.default.webPortal + '/loginOut', false);\n\t    LoginResource.delete(param, success, error);\n\t  },\n\t  getShopInfo: function getShopInfo(param, success, error) {\n\t    var ShopResource = (0, _rsGenerator2.default)(_config2.default.webDashboard + '/dashboard/assemble/shopinfo/', false);\n\t    ShopResource.get(param, success, error);\n\t  },\n\t  getNumber: function getNumber(param, success, error) {\n\t    var EbmResource = (0, _rsGenerator2.default)(_config2.default.webNode + '/node/edm/cb-service/messages/count/?_=' + new Date().getTime(), false);\n\t    EbmResource.get(param, success, error);\n\t  },\n\t  getNoticesList: function getNoticesList(param, success, error) {\n\t    var userName = param.userName;\n\t    var ccmsVersion = param.ccmsVersion;\n\t    var pageNo = param.pageNo;\n\t    var timestamp = new Date().getTime();\n\t    var pageSize = param.pageSize || 10;\n\t    var NoticesResource = (0, _rsGenerator2.default)(_config2.default.webPortal + '/notification/notice' + '?timestamp=' + timestamp + '&pageSize=' + pageSize + '&pageNo=' + pageNo + '&setId=' + ccmsVersion + '&userName=' + userName, false);\n\t    NoticesResource.get({}, success, error);\n\t  },\n\t  getStatus: function getStatus(param, success, error) {\n\t    var userName = param.userName;\n\t    var ccmsVersion = param.ccmsVersion;\n\t    var StatusResource = (0, _rsGenerator2.default)(_config2.default.webPortal + '/notification/status?setId=' + ccmsVersion + '&userName=' + userName, false);\n\t    StatusResource.get({}, success, error);\n\t  },\n\t  postNotice: function postNotice(param, success, error) {\n\t    var userName = param.userName;\n\t    var ccmsVersion = param.ccmsVersion;\n\t    var campUserName = param.campUserName;\n\t    var id = param.id;\n\t    var data = {\n\t      'setId': ccmsVersion,\n\t      'userName': userName,\n\t      'noticeId': id,\n\t      'optName': campUserName\n\t    };\n\t    var NoticeResource = (0, _rsGenerator2.default)(_config2.default.webPortal + '/notification/notice/' + id, false);\n\t    NoticeResource.save(data, success, error);\n\t  },\n\t  deleteNotices: function deleteNotices(param, success, error) {\n\t    var userName = param.userName;\n\t    var ccmsVersion = param.setId;\n\t    var ids = param.ids;\n\t    var NoticeResource = (0, _rsGenerator2.default)(_config2.default.webPortal + '/notification/notice?setId=' + ccmsVersion + '&userName=' + userName + '&noticeId=' + ids, false);\n\t    NoticeResource.delete({}, success, error);\n\t  },\n\t  getAti: function getAti(param, success, error) {\n\t    var ati = '';\n\t    var cookiesAry = document.cookie.split(';');\n\t    cookiesAry.forEach(function (v, i) {\n\t      if (v.indexOf('_ati') !== -1) {\n\t        ati = v.replace(/\\s/g, '').substr(5);\n\t      }\n\t    });\n\t    var ShopResource = (0, _rsGenerator2.default)(_config2.default.webDashboard + '/dashboard/assemble/setLoginLog?ati=' + ati, false);\n\t    ShopResource.get(param, success, error);\n\t  }\n\t};\n\n/***/ },\n/* 32 */,\n/* 33 */,\n/* 34 */,\n/* 35 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__.p + \"components/menu/template/collectPerInfo-c2a7c48a6d14045179ea.html\";\n\n/***/ },\n/* 36 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _config = __webpack_require__(18);\n\t\n\tvar _config2 = _interopRequireDefault(_config);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = ['$element', '$scope', '$http', 'modalInstance', '$ccValidator', '$ccTips', function ($element, $scope, $http, modalInstance, $ccValidator, $ccTips) {\n\t  var that = this;\n\t  this.ok = function () {\n\t    that.perInfoSave(modalInstance.ok);\n\t  };\n\t\n\t  this.ccValidators = {\n\t    phone: {\n\t      msg: '请输入正确的手机号码',\n\t      fn: function fn(modelValue, viewValue) {\n\t        var value = modelValue || viewValue;\n\t        return value ? /^[1][3-9]{1}\\d{9}$/.test(value) : !value;\n\t      }\n\t    }\n\t  };\n\t\n\t  this.perInfoSave = function (callback) {\n\t    // 保存联系人方式\n\t    $ccValidator.validate($scope.collerinfo).then(function () {\n\t      var contactPerInfo = {};\n\t      contactPerInfo.fullName = that.contactName;\n\t      contactPerInfo.email = that.contactEmail;\n\t      contactPerInfo.mobile = that.contactPhone;\n\t      contactPerInfo.qq = that.contactQQ;\n\t      contactPerInfo.wangwang = that.contactWW;\n\t      contactPerInfo.weibo = that.contactWeibo;\n\t      contactPerInfo.tenantId = $scope.tenantId;\n\t      $http.post(_config2.default.webDashboard + '/dashboard/assemble/contact/', contactPerInfo).success(function (response) {\n\t        if (response.code === 200) {\n\t          var sessionData = window.sessionStorage.getItem('shuyunContact');\n\t          if (!sessionData) {\n\t            sessionData = '{}';\n\t          }\n\t          sessionData = JSON.parse(sessionData);\n\t          sessionData.exists = true;\n\t\n\t          for (var i in contactPerInfo) {\n\t            if (!sessionData.contact) {\n\t              sessionData.contact = {};\n\t            }\n\t            sessionData.contact[i] = contactPerInfo[i];\n\t          }\n\t          sessionData = JSON.stringify(sessionData);\n\t          window.sessionStorage.setItem('shuyunContact', sessionData);\n\t          callback();\n\t          $ccTips.success('保存成功');\n\t        } else {\n\t          $ccTips.error(response.message, document.querySelector('.content'));\n\t        }\n\t      });\n\t    }, function () {\n\t      console.log('校验失败!');\n\t    });\n\t  };\n\t  /* end 填写信息 */\n\t}];\n\n/***/ },\n/* 37 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__.p + \"components/menu/template/password-2c0c1a3c510aacb8215e.html\";\n\n/***/ },\n/* 38 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _config = __webpack_require__(18);\n\t\n\tvar _config2 = _interopRequireDefault(_config);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = ['$element', '$scope', 'modalInstance', '$ccValidator', '$http', '$ccTips', function ($element, $scope, modalInstance, $ccValidator, $http, $ccTips) {\n\t  var that = this;\n\t  this.ok = function () {\n\t    that.savePassword(modalInstance.ok);\n\t  };\n\t  this.ccValidators = {\n\t    checkpasswd: {\n\t      msg: '密码至少8位，并包括大小写字母及数字',\n\t      regex: /^.*(?=.{8,})(?=.*[a-z])(?=.*[A-Z])(?=.*[0-9]).*$/\n\t    },\n\t    equalTo: {\n\t      msg: '两次输入的密码不一致',\n\t      fn: function fn(modelValue, viewValue) {\n\t        var value = modelValue || viewValue;\n\t        return value ? value === that.password : !value;\n\t      }\n\t    }\n\t  };\n\t  var tips = null;\n\t  var saveFn = function saveFn(callback) {\n\t    var PasswordInfo = {\n\t      id: $scope.user.id,\n\t      password: that.password,\n\t      newPassword: that.newPassword,\n\t      oldPassword: that.oldPassword\n\t    };\n\t\n\t    $http.put(_config2.default.webSystem + 'sys/user/' + PasswordInfo.id + '/password/?_=' + new Date().getTime(), PasswordInfo).success(function () {\n\t      callback();\n\t      $ccTips.success('密码修改成功');\n\t    }).error(function (data, status, headers, config) {\n\t      if (!tips || !tips.element) {\n\t        tips = $ccTips.error(data.description, document.querySelector('.ccms-modal'));\n\t      }\n\t    });\n\t  };\n\t  this.savePassword = function (callback) {\n\t    $ccValidator.validate($scope.changepassword).then(function () {\n\t      saveFn(callback);\n\t    }, function () {\n\t      console.log('校验失败!');\n\t    });\n\t  };\n\t}];\n\n/***/ },\n/* 39 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__.p + \"components/menu/template/message-0b9d765fae00c9877d6e.html\";\n\n/***/ },\n/* 40 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _service = __webpack_require__(31);\n\t\n\tvar _service2 = _interopRequireDefault(_service);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = ['$element', '$scope', '$rootScope', 'modalInstance', '$ccValidator', '$http', '$ccTips', '$interval', '$sce', function ($element, $scope, $rootScope, modalInstance, $ccValidator, $http, $ccTips, $interval, $sce) {\n\t  var that = this;\n\t  var ccmsVersion = $rootScope.ccmsVersion;\n\t  // 影藏消息详情内容弹出框\n\t  that.hideContentDialog = function () {\n\t    that.noticeObj.hideMessContent();\n\t  };\n\t\n\t  this.noticeObj = {\n\t    'deleIdList': {},\n\t    'hideContentDialog': function hideContentDialog() {\n\t      that.isShowMessContent = false;\n\t    },\n\t    'setSelectAll': function setSelectAll(checked) {\n\t      var _this = this;\n\t      that.popMesses.forEach(function (item) {\n\t        _this.deleIdList[item.id] = checked;\n\t        item.select = checked;\n\t      });\n\t      that.deleteButton = checked;\n\t    },\n\t    'selectNoticeId': function selectNoticeId(id, checked) {\n\t      var _this = this;\n\t      _this.deleIdList[id] = checked;\n\t      var checkedList = that.popMesses.filter(function (item) {\n\t        return item.select === true;\n\t      });\n\t      that.deleteButton = checkedList.length > 0;\n\t      that.selectAll = checkedList.length === that.popMesses.length;\n\t      if (that.popMesses.length === 0) {\n\t        that.selectAll = false;\n\t      }\n\t    },\n\t    'getNoticeCb': function getNoticeCb(res) {\n\t      that.selectAll = false;\n\t      // 总共多少页\n\t      var pages = Math.ceil(res.total / 10);\n\t      if (pages === 0) {\n\t        pages = 1;\n\t      }\n\t      res.data.forEach(function (item) {\n\t        item.isRead = item.status === 1;\n\t        // item.select = that.noticeObj.deleIdList[item.noticeId];\n\t      });\n\t      that.deleteButton = false;\n\t\n\t      that.popMesses = res.data;\n\t      // that.page = res.page;\n\t      that.total = pages;\n\t      // 是否是第一页，是否是最后一页\n\t      that.isLastPage = !!(pages - res.page);\n\t      that.isFirstPage = res.page !== 1;\n\t    },\n\t    'getNoticeEB': function getNoticeEB(res) {\n\t      that.popMesses = [];\n\t      that.page = 0;\n\t      that.total = 0;\n\t    },\n\t    onPageChange: function onPageChange(pageNum) {\n\t      var _this = this;\n\t      var param = {\n\t        'userName': $rootScope.tenantId,\n\t        'ccmsVersion': ccmsVersion,\n\t        'pageNo': pageNum\n\t      };\n\t      that.page = pageNum;\n\t      _service2.default.getNoticesList(param, _this.getNoticeCb, _this.getNoticeEB);\n\t    },\n\t    'getNotices': function getNotices() {\n\t      var _this = this;\n\t      var param = {\n\t        'userName': $rootScope.tenantId,\n\t        'ccmsVersion': ccmsVersion,\n\t        'pageNo': 1\n\t      };\n\t      that.page = 1;\n\t      _service2.default.getNoticesList(param, _this.getNoticeCb, _this.getNoticeEB);\n\t    },\n\t    'readClick': function readClick(index) {\n\t      var notice = that.popMesses[index];\n\t      var param = {\n\t        'campUserName': that.campUserName,\n\t        'userName': $rootScope.tenantId,\n\t        'ccmsVersion': ccmsVersion,\n\t        'id': notice.noticeId * 1\n\t      };\n\t      // $('#isShowMessContent').css('display', 'block')\n\t      that.isShowMessContent = true;\n\t      notice.isRead || _service2.default.postNotice(param);\n\t      notice.isRead = true;\n\t\n\t      that.content = $sce.trustAsHtml(notice.content);\n\t      that.contitle = notice.title;\n\t      that.condate = notice.created;\n\t    },\n\t    'deleteNotice': function deleteNotice() {\n\t      if (!that.deleteButton) return;\n\t      var _this = this;\n\t      var ids = [];\n\t      for (var i in _this.deleIdList) {\n\t        if (_this.deleIdList[i]) {\n\t          ids.push(i);\n\t        }\n\t      }\n\t      var param = {\n\t        'userName': $rootScope.tenantId,\n\t        'setId': ccmsVersion,\n\t        'ccmsVersion': ccmsVersion,\n\t        'ids': ids.join(',')\n\t      };\n\t\n\t      var cb = function cb(res) {\n\t        _this.ids = [];\n\t        var text = '删除失败';\n\t        if (res.success) {\n\t          text = '删除成功';\n\t        }\n\t        _this.getNotices();\n\t        $ccTips.success(text, document.querySelector('.ccms-modal'));\n\t      };\n\t      var eb = function eb() {};\n\t\n\t      _service2.default.deleteNotices(param, cb, eb);\n\t    },\n\t    'clearNotice': function clearNotice() {\n\t      var _this = this;\n\t      var ids = [];\n\t      that.popMesses.forEach(function (item) {\n\t        if (item.isRead) {\n\t          ids.push(item.noticeId);\n\t        }\n\t      });\n\t      if (ids.length === 0) return;\n\t      var param = {\n\t        'userName': $rootScope.tenantId,\n\t        'setId': ccmsVersion,\n\t        'ccmsVersion': ccmsVersion,\n\t        'ids': ids.join(',')\n\t      };\n\t\n\t      var cb = function cb(res) {\n\t        _this.ids = [];\n\t        _this.getNotices();\n\t        $ccTips.success('删除成功', document.querySelector('.ccms-modal'));\n\t      };\n\t      var eb = function eb() {};\n\t\n\t      _service2.default.deleteNotices(param, cb, eb);\n\t    }\n\t  };\n\t\n\t  // 获取服务器数据\n\t  this.noticeObj.getNotices();\n\t}];\n\n/***/ },\n/* 41 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t/*\r\n\t * @author Created by taoyong\r\n\t * @time Created on 16/5/24.\r\n\t */\n\t// 顶部导航栏\n\tvar setNavFunction = function setNavFunction() {\n\t  var navElement = document.querySelectorAll('.nav>li');\n\t  var moreElement = document.querySelectorAll('.more');\n\t  var moreLiElement = document.querySelectorAll('.more ul li');\n\t  var listnum = navElement.length; // 导航总共的个数\n\t  var navwidth = document.body.offsetWidth - document.querySelectorAll('h1')[0].offsetWidth - document.querySelectorAll('.headerAside')[0].offsetWidth - 80;\n\t  var showlistnum = parseInt(navwidth / navElement[0].offsetWidth * 1, 10);\n\t  var hidelistnum = listnum - showlistnum;\n\t  if (hidelistnum > 0) {\n\t    var showLength = navElement.length - hidelistnum - 1;\n\t    for (var i = 0, len = navElement.length; i < len; i++) {\n\t      if (i > showLength) {\n\t        navElement[i].style.display = 'none';\n\t        moreLiElement[i].style.display = 'block';\n\t      } else {\n\t        navElement[i].style.display = 'block';\n\t        moreLiElement[i].style.display = 'none';\n\t      }\n\t    };\n\t    moreElement[0].style.display = 'block';\n\t  } else if (hidelistnum <= 0) {\n\t    for (var j = 0, length = navElement.length; j < length; j++) {\n\t      navElement[j].style.display = 'block';\n\t    };\n\t    moreElement[0].style.display = 'none';\n\t  };\n\t};\n\t\n\tdocument.addEventListener('DOMContentLoaded', function () {\n\t  window.onresize = function () {\n\t    setNavFunction();\n\t  };\n\t});\n\t\n\texports.default = {\n\t  setNavFunction: setNavFunction\n\t};\n\n/***/ },\n/* 42 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _angular = __webpack_require__(1);\n\t\n\tvar _angular2 = _interopRequireDefault(_angular);\n\t\n\tvar _insertCtrl = __webpack_require__(43);\n\t\n\tvar _insertCtrl2 = _interopRequireDefault(_insertCtrl);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t/**\r\n\t * @author Created by taoyong\r\n\t * @Date  on 2016/9/2.\r\n\t */\n\texports.default = _angular2.default.module('insert', []).controller('InsertCtrl', _insertCtrl2.default).name;\n\n/***/ },\n/* 43 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.default = undefined;\n\t\n\tvar _dec, _class; /**\r\n\t                   * @author Created by taoyong\r\n\t                   * @Date  on 2016/5/18.\r\n\t                   */\n\t\n\t\n\t__webpack_require__(44);\n\t\n\tvar _angular = __webpack_require__(1);\n\t\n\tvar _angular2 = _interopRequireDefault(_angular);\n\t\n\tvar _angularEsUtils = __webpack_require__(45);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar IframeCtrl = (_dec = (0, _angularEsUtils.Inject)('$rootScope', '$stateParams', '$sce', '$state'), _dec(_class = function IframeCtrl($rootScope, $stateParams, $sce, $state) {\n\t  _classCallCheck(this, IframeCtrl);\n\t\n\t  var _this = this;\n\t  var context = $stateParams.context || '';\n\t  _angular2.default.forEach($rootScope.user.nav, function (v, k) {\n\t    if (v.url.indexOf('insert') !== -1 && v.id.indexOf('_' + context) !== -1) {\n\t      var seesionItem = sessionStorage.getItem('marketingParams');\n\t      var dataUrl = v.dataUrl;\n\t      if (seesionItem) {\n\t        dataUrl += '&' + seesionItem;\n\t      }\n\t      console.log(dataUrl);\n\t      _this.contextUrl = $sce.trustAsResourceUrl(dataUrl);\n\t      return false;\n\t    }\n\t  });\n\t  window.addEventListener('message', function (e) {\n\t    // dashboard ==> marketing\n\t    if (e.data) {\n\t      if (e.data === 'authReject') {\n\t        if (true) {\n\t          location.pathname = '/portal/timeout.html';\n\t        } else {\n\t          location.pathname = '/portal/login.html';\n\t        }\n\t      } else if (e.data === 'contentManage') {\n\t        // 内容管理\n\t        $state.go('insert', { context: 'contentManage' });\n\t      }\n\t    };\n\t    window.removeEventListener('message', function () {}, false);\n\t  }, false);\n\t}) || _class);\n\texports.default = IframeCtrl;\n\t;\n\n/***/ },\n/* 44 */\n10,\n/* 45 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\texports.EventBus = exports.genResource = exports.dynamicExport = exports.getInjector = exports.Animation = exports.Deferred = exports.ModuleHelper = exports.FactoryCreator = undefined;\n\t\n\tvar _decorators = __webpack_require__(46);\n\t\n\tObject.keys(_decorators).forEach(function (key) {\n\t\tif (key === \"default\" || key === \"__esModule\") return;\n\t\tObject.defineProperty(exports, key, {\n\t\t\tenumerable: true,\n\t\t\tget: function get() {\n\t\t\t\treturn _decorators[key];\n\t\t\t}\n\t\t});\n\t});\n\t\n\tvar _factoryCreator = __webpack_require__(52);\n\t\n\tvar _factoryCreator2 = _interopRequireDefault(_factoryCreator);\n\t\n\tvar _moduleHelper = __webpack_require__(53);\n\t\n\tvar _moduleHelper2 = _interopRequireDefault(_moduleHelper);\n\t\n\tvar _deferred = __webpack_require__(54);\n\t\n\tvar _deferred2 = _interopRequireDefault(_deferred);\n\t\n\tvar _animation = __webpack_require__(55);\n\t\n\tvar _animation2 = _interopRequireDefault(_animation);\n\t\n\tvar _injector = __webpack_require__(33);\n\t\n\tvar _rsGenerator = __webpack_require__(32);\n\t\n\tvar _rsGenerator2 = _interopRequireDefault(_rsGenerator);\n\t\n\tvar _eventBus = __webpack_require__(56);\n\t\n\tvar _eventBus2 = _interopRequireDefault(_eventBus);\n\t\n\tvar _dynamicExport = __webpack_require__(34);\n\t\n\tvar _dynamicExport2 = _interopRequireDefault(_dynamicExport);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.FactoryCreator = _factoryCreator2.default;\n\texports.ModuleHelper = _moduleHelper2.default;\n\texports.Deferred = _deferred2.default;\n\texports.Animation = _animation2.default;\n\texports.getInjector = _injector.getInjector;\n\texports.dynamicExport = _dynamicExport2.default;\n\texports.genResource = _rsGenerator2.default;\n\texports.EventBus = _eventBus2.default; /**\n\t                                        * @author Kuitos\n\t                                        * @homepage https://github.com/kuitos/\n\t                                        * @since 2016-02-02\n\t                                        */\n\n/***/ },\n/* 46 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\texports.Delay = exports.Debounce = exports.Throttle = exports.Bind = exports.Inject = undefined;\n\t\n\tvar _Inject = __webpack_require__(47);\n\t\n\tvar _Inject2 = _interopRequireDefault(_Inject);\n\t\n\tvar _Bind = __webpack_require__(48);\n\t\n\tvar _Bind2 = _interopRequireDefault(_Bind);\n\t\n\tvar _Throttle = __webpack_require__(49);\n\t\n\tvar _Throttle2 = _interopRequireDefault(_Throttle);\n\t\n\tvar _Debounce = __webpack_require__(50);\n\t\n\tvar _Debounce2 = _interopRequireDefault(_Debounce);\n\t\n\tvar _Delay = __webpack_require__(51);\n\t\n\tvar _Delay2 = _interopRequireDefault(_Delay);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.Inject = _Inject2.default;\n\texports.Bind = _Bind2.default;\n\texports.Throttle = _Throttle2.default;\n\texports.Debounce = _Debounce2.default;\n\texports.Delay = _Delay2.default; /**\n\t                                  * @author Kuitos\n\t                                  * @homepage https://github.com/kuitos/\n\t                                  * @since 2016-01-17\n\t                                  */\n\n/***/ },\n/* 47 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t/**\n\t * @author Kuitos\n\t * @homepage https://github.com/kuitos/\n\t * @since 2016-01-11\n\t */\n\t\n\t// safari里调用getOwnPropertyNames会拿到 arguments 跟 caller\n\tvar stupidSafariProps = ['arguments', 'caller'];\n\t// 需要过滤的构造函数的属性\n\tvar propBlacklist = ['name', 'prototype', 'length'].concat(stupidSafariProps);\n\t/**\n\t * angular依赖注入器\n\t */\n\t\n\texports.default = function () {\n\t\tfor (var _len = arguments.length, dependencies = Array(_len), _key = 0; _key < _len; _key++) {\n\t\t\tdependencies[_key] = arguments[_key];\n\t\t}\n\t\n\t\treturn function (target, name, descriptor) {\n\t\n\t\t\tif (descriptor) {\n\t\t\t\tthrow new Error('can not use Inject decorator with a non-constructor!');\n\t\t\t}\n\t\n\t\t\tvar OriginalConstructor = target;\n\t\n\t\t\tvar Constructor = function Constructor() {\n\t\t\t\tvar _this = this;\n\t\n\t\t\t\tfor (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n\t\t\t\t\targs[_key2] = arguments[_key2];\n\t\t\t\t}\n\t\n\t\t\t\t_classCallCheck(this, Constructor);\n\t\n\t\t\t\t/* ----------------- 以下这一段恶心的代码都是为了兼容function跟class定义controller这两种情况 ------------------------ */\n\t\t\t\t/* ----------------- 因为class定义的Constructor有时候需要直接访问this中已绑定的数据(fn.apply(instance, locals)) ---- */\n\t\n\t\t\t\t// 存在通过 fn.apply(instance, locals) 的方式调用的情况,所以这里直接将依赖的服务拷贝到this里(服务以下划线作为前缀)\n\t\t\t\tdependencies.forEach(function (dependency, i) {\n\t\t\t\t\treturn _this['_' + dependency] = args[i];\n\t\t\t\t});\n\t\t\t\t// 将构造器初始化时就需要访问的数据挂载到prototype上,这样即使通过new方式实例化,constructor里的this也具备完整信息\n\t\t\t\tObject.assign(OriginalConstructor.prototype, this);\n\t\n\t\t\t\tvar instance = new (Function.prototype.bind.apply(OriginalConstructor, [null].concat(args)))();\n\t\n\t\t\t\t// 初始化完毕需要从prototype上删除挂载的属性,因为有一些注入的局部服务对于每一个实例而言是隔离的,如果改变prototype会出现混乱\n\t\t\t\tObject.keys(this).forEach(function (prop) {\n\t\t\t\t\t// prototype上不可枚举的属性不能删除(比如方法/accessor等)\n\t\t\t\t\tif (OriginalConstructor.prototype.propertyIsEnumerable(prop)) {\n\t\t\t\t\t\tdelete OriginalConstructor.prototype[prop];\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// 属性可能会被重新定义,比如 this.name = this.name + 'xx';\n\t\t\t\t\t// 所以这里不能直接Object.assign(instance, this)\n\t\t\t\t\t// 只有this上存在但是instance上不存在的属性才复制过去\n\t\t\t\t\tif (!instance.hasOwnProperty(prop)) {\n\t\t\t\t\t\tinstance[prop] = _this[prop];\n\t\t\t\t\t}\n\t\t\t\t});\n\t\n\t\t\t\treturn instance;\n\t\t\t};\n\t\n\t\t\t// 将原始构造函数的属性复制到新的Constructor中,包括prototype\n\t\t\t// 因为通过static class property语法定义的静态方法是不可枚举的,所以这里不能用Object.keys API来筛选.\n\t\n\t\n\t\t\tObject.getOwnPropertyNames(target).forEach(function (prop) {\n\t\t\t\tif (propBlacklist.indexOf(prop) === -1) {\n\t\t\t\t\tConstructor[prop] = target[prop];\n\t\t\t\t}\n\t\t\t});\n\t\t\tConstructor.$inject = dependencies;\n\t\n\t\t\treturn Constructor;\n\t\t};\n\t};\n\n/***/ },\n/* 48 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\t\n\t/**\n\t * @author Kuitos\n\t * @homepage https://github.com/kuitos/\n\t * @since 2016-04-06\n\t */\n\t\n\t/**\n\t * bind装饰器,用于处理function bind不适用的场景\n\t */\n\texports.default = function (target, name, descriptor) {\n\t\n\t\tif (!descriptor) {\n\t\t\tthrow new Error('can not use Bind decorator with a constructor!');\n\t\t}\n\t\n\t\tvar fn = descriptor.value || target[name];\n\t\t// use function string as identifier which can ensure every function uniquely after wrapped\n\t\t// we can not use Function.name as identifier because its name may be empty(anonymous function) or defined by other ways(such as Object.defineProperty)\n\t\tvar fnName = '__' + fn + 'Fn__';\n\t\n\t\t// 定义访问器属性的同时不能定义value跟writable\n\t\t// @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty\n\t\tdelete descriptor.value;\n\t\tdelete descriptor.writable;\n\t\n\t\tdescriptor.set = function (value) {\n\t\t\tthis[fnName] = value;\n\t\t};\n\t\n\t\tdescriptor.get = function () {\n\t\t\treturn this[fnName] || (this[fnName] = fn.bind(this));\n\t\t};\n\t\n\t\treturn descriptor;\n\t};\n\n/***/ },\n/* 49 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\t\n\t/**\n\t * @author Kuitos\n\t * @homepage https://github.com/kuitos/\n\t * @since 2016-04-12\n\t */\n\t\n\texports.default = function () {\n\t\tvar delay = arguments.length <= 0 || arguments[0] === undefined ? 10 : arguments[0];\n\t\tvar context = arguments[1];\n\t\treturn function (target, name, descriptor) {\n\t\n\t\t\tif (!descriptor) {\n\t\t\t\tthrow new Error('can not use Throttle decorator with a constructor!');\n\t\t\t}\n\t\n\t\t\tvar fn = descriptor.value || target[name];\n\t\n\t\t\tvar recent = void 0;\n\t\n\t\t\tdescriptor.value = function () {\n\t\n\t\t\t\tvar now = Date.now();\n\t\n\t\t\t\tif (!recent || now - recent > delay) {\n\t\t\t\t\tfor (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t\t\t\t\t\targs[_key] = arguments[_key];\n\t\t\t\t\t}\n\t\n\t\t\t\t\tfn.apply(context || this, args);\n\t\t\t\t\trecent = now;\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\treturn descriptor;\n\t\t};\n\t};\n\n/***/ },\n/* 50 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\t\n\tvar _injector = __webpack_require__(33);\n\t\n\tvar _injector2 = _interopRequireDefault(_injector);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = function () {\n\t\tvar delay = arguments.length <= 0 || arguments[0] === undefined ? 300 : arguments[0];\n\t\tvar context = arguments[1];\n\t\tvar invokeApply = arguments[2];\n\t\treturn function (target, name, descriptor) {\n\t\n\t\t\tif (!descriptor) {\n\t\t\t\tthrow new Error('can not use Debounce decorator with a constructor!');\n\t\t\t}\n\t\n\t\t\tvar fn = descriptor.value || target[name];\n\t\t\tvar $timeout = null;\n\t\t\tvar pendingDebounce = null;\n\t\n\t\t\tdescriptor.value = function () {\n\t\t\t\tvar _this = this;\n\t\n\t\t\t\tfor (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t\t\t\t\targs[_key] = arguments[_key];\n\t\t\t\t}\n\t\n\t\t\t\t// lazy init\n\t\t\t\t$timeout = $timeout || _injector2.default.get('$timeout');\n\t\n\t\t\t\t$timeout.cancel(pendingDebounce);\n\t\n\t\t\t\tpendingDebounce = $timeout(function () {\n\t\t\t\t\tpendingDebounce = null;\n\t\t\t\t\tfn.apply(context || _this, args);\n\t\t\t\t}, delay, invokeApply);\n\t\t\t};\n\t\n\t\t\treturn descriptor;\n\t\t};\n\t}; /**\n\t    * @author Kuitos\n\t    * @homepage https://github.com/kuitos/\n\t    * @since 2016-04-12\n\t    */\n\n/***/ },\n/* 51 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\t\n\tvar _injector = __webpack_require__(33);\n\t\n\tvar _injector2 = _interopRequireDefault(_injector);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = function () {\n\t\tvar delay = arguments.length <= 0 || arguments[0] === undefined ? 0 : arguments[0];\n\t\tvar invokeApply = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];\n\t\treturn function (target, name, descriptor) {\n\t\n\t\t\tif (!descriptor) {\n\t\t\t\tthrow new Error('can not use Delay decorator with a constructor!');\n\t\t\t}\n\t\n\t\t\tvar fn = descriptor.value || target[name];\n\t\t\tvar $timeout = null;\n\t\n\t\t\tdescriptor.value = function () {\n\t\t\t\tvar _this = this;\n\t\n\t\t\t\tfor (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t\t\t\t\targs[_key] = arguments[_key];\n\t\t\t\t}\n\t\n\t\t\t\t// lazy init\n\t\t\t\t$timeout = $timeout || _injector2.default.get('$timeout');\n\t\t\t\t$timeout(function () {\n\t\t\t\t\tfn.apply(_this, args);\n\t\t\t\t}, delay, invokeApply);\n\t\t\t};\n\t\n\t\t\treturn descriptor;\n\t\t};\n\t}; /**\n\t    * @author Kuitos\n\t    * @homepage https://github.com/kuitos/\n\t    * @since 2016-07-06\n\t    */\n\n/***/ },\n/* 52 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\t/**\n\t * @author Kuitos\n\t * @homepage https://github.com/kuitos/\n\t * @since 2015-12-29\n\t */\n\t\n\tvar FUNCTION_PRIVATE_PROPS = ['apply', 'arguments', 'bind', 'call', 'caller', 'constructor', 'Symbol'];\n\t\n\texports.default = {\n\t\tcreate: function create(Constructor) {\n\t\n\t\t\tconsole.warn('FactoryCreator.create 方法将在下一版本废弃,请尽快使用别的替代解决方案!(迁移指南:https://github.com/kuitos/angular-es-utils/blob/master/src/factory-creator/README.md)');\n\t\n\t\t\tfunction factory() {\n\t\t\t\tfor (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t\t\t\t\targs[_key] = arguments[_key];\n\t\t\t\t}\n\t\n\t\t\t\tvar instance = new (Function.prototype.bind.apply(Constructor, [null].concat(args)))();\n\t\n\t\t\t\tvar prototype = Object.getPrototypeOf(instance);\n\t\n\t\t\t\tObject.getOwnPropertyNames(prototype).forEach(function (prop) {\n\t\n\t\t\t\t\t// 只处理非私有方法\n\t\t\t\t\tif (FUNCTION_PRIVATE_PROPS.indexOf(prop) === -1) {\n\t\t\t\t\t\t// 绑定实例到构造函数的每个方法下\n\t\t\t\t\t\tvar fn = prototype[prop];\n\t\t\t\t\t\tif (typeof fn === 'function') {\n\t\t\t\t\t\t\tprototype[prop] = fn.bind(instance);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\n\t\t\t\treturn instance;\n\t\t\t}\n\t\n\t\t\tfactory.$inject = Constructor.$inject || [];\n\t\n\t\t\treturn factory;\n\t\t}\n\t};\n\n/***/ },\n/* 53 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\t\n\tvar _angular = __webpack_require__(1);\n\t\n\tvar _angular2 = _interopRequireDefault(_angular);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = {\n\t\tget: function get(moduleName, deps) {\n\t\n\t\t\ttry {\n\t\t\t\treturn _angular2.default.module(moduleName);\n\t\t\t} catch (e) {\n\t\t\t\treturn _angular2.default.module(moduleName, deps);\n\t\t\t}\n\t\t}\n\t}; /**\n\t    * @author Kuitos\n\t    * @homepage https://github.com/kuitos/\n\t    * @since 2016-01-17\n\t    */\n\n/***/ },\n/* 54 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t/**\n\t * @author Kuitos\n\t * @homepage https://github.com/kuitos/\n\t * @since 2016-03-02\n\t */\n\t\n\tvar Deferred = function () {\n\t\tfunction Deferred() {\n\t\t\tvar _this = this;\n\t\n\t\t\t_classCallCheck(this, Deferred);\n\t\n\t\t\tthis.promise = new Promise(function (resolve, reject) {\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_this._reject = reject;\n\t\t\t});\n\t\t}\n\t\n\t\t_createClass(Deferred, [{\n\t\t\tkey: \"resolve\",\n\t\t\tvalue: function resolve(value) {\n\t\t\t\tthis._resolve.call(this.promise, value);\n\t\t\t}\n\t\t}, {\n\t\t\tkey: \"reject\",\n\t\t\tvalue: function reject(value) {\n\t\t\t\tthis._reject.call(this.promise, value);\n\t\t\t}\n\t\t}]);\n\t\n\t\treturn Deferred;\n\t}();\n\t\n\texports.default = Deferred;\n\n/***/ },\n/* 55 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\t/**\n\t * @author Kuitos\n\t * @homepage https://github.com/kuitos/\n\t * @since 2016-03-24\n\t */\n\t\n\tvar ANIMATIONEND_EVENT = void 0,\n\t    TRANSITIONEND_EVENT = void 0;\n\t\n\tif (window.onanimationend === undefined && window.onwebkitanimationend !== undefined) {\n\t\tANIMATIONEND_EVENT = 'webkitAnimationEnd animationend';\n\t} else {\n\t\tANIMATIONEND_EVENT = 'animationend';\n\t}\n\t\n\tif (window.ontransitionend === undefined && window.onwebkittransitionend !== undefined) {\n\t\tTRANSITIONEND_EVENT = 'webkitTransitionEnd transitionend';\n\t} else {\n\t\tTRANSITIONEND_EVENT = 'transitionend';\n\t}\n\t\n\tvar EVENTS = [ANIMATIONEND_EVENT, TRANSITIONEND_EVENT].join(' ').split(' ');\n\tvar noop = function noop() {};\n\t\n\texports.default = {\n\t\n\t\taddClass: function addClass(element, className) {\n\t\t\tvar doneHook = arguments.length <= 2 || arguments[2] === undefined ? noop : arguments[2];\n\t\t\tvar autoRemove = arguments.length <= 3 || arguments[3] === undefined ? false : arguments[3];\n\t\n\t\t\tEVENTS.forEach(function (event) {\n\t\t\t\telement.addEventListener(event, function () {\n\t\n\t\t\t\t\tif (autoRemove) {\n\t\t\t\t\t\telement.classList.remove(className);\n\t\t\t\t\t}\n\t\n\t\t\t\t\tdoneHook();\n\t\t\t\t}, false);\n\t\t\t});\n\t\n\t\t\telement.classList.add(className);\n\t\t},\n\t\n\t\tremoveClass: function removeClass(element, className, doneHook) {\n\t\t\tEVENTS.forEach(function (event) {\n\t\t\t\telement.addEventListener(event, doneHook, false);\n\t\t\t});\n\t\n\t\t\telement.classList.remove(className);\n\t\t}\n\t\n\t};\n\n/***/ },\n/* 56 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\t\n\tvar _typeAuth = __webpack_require__(57);\n\t\n\tvar topics = {};\n\t\n\t/**\n\t * 事件总线。用于解决各模块间无法通过 $scope.$emit $scope.$on 等方式实现通信的问题(例如兄弟模块间通信)\n\t */\n\t/**\n\t * @author Kuitos\n\t * @homepage https://github.com/kuitos/\n\t * @since 2016-05-04\n\t */\n\t\n\texports.default = {\n\t\n\t\t/**\n\t  * 订阅消息\n\t  * @param topic 订阅消息名\n\t  * @param listener 消息发布时触发的回调\n\t  * @returns {Function} 取消订阅的反注册函数\n\t  */\n\t\ton: function on(topic, listener) {\n\t\n\t\t\tvar topicListeners = topics[topic] = topics[topic] || [];\n\t\t\ttopicListeners.push(listener);\n\t\n\t\t\treturn this.off.bind(this, topic, listener);\n\t\t},\n\t\n\t\tonce: function once(topic, listener) {\n\t\t\tvar _this = this;\n\t\n\t\t\tvar onceListener = function onceListener() {\n\t\t\t\tfor (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t\t\t\t\targs[_key] = arguments[_key];\n\t\t\t\t}\n\t\n\t\t\t\t_this.off(topic, onceListener);\n\t\t\t\tlistener.apply(null, args);\n\t\t\t};\n\t\n\t\t\treturn this.on(topic, onceListener);\n\t\t},\n\t\n\t\t/**\n\t  * 移除注册信息\n\t  * @param topic 消息名\n\t  * @param listener  移除的注册函数,不传则移除全部注册\n\t  */\n\t\toff: function off(topic, listener) {\n\t\n\t\t\tvar topicListeners = topics[topic];\n\t\n\t\t\tif (listener) {\n\t\n\t\t\t\tvar listenerIndex = topicListeners.indexOf(listener);\n\t\t\t\tif (~listenerIndex) {\n\t\t\t\t\ttopicListeners[listenerIndex] = null;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// 清空\n\t\t\t\ttopicListeners.length = 0;\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\t},\n\t\n\t\t/**\n\t  * 发布消息，支持链式调用\n\t  */\n\t\tdispatch: function dispatch() {\n\t\t\tfor (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n\t\t\t\targs[_key2] = arguments[_key2];\n\t\t\t}\n\t\n\t\t\tvar topic = args[0];\n\t\t\tvar listeners = topics[topic] || [];\n\t\n\t\t\tfor (var i = 0; i < listeners.length; i++) {\n\t\n\t\t\t\tif (listeners[i] === null) {\n\t\t\t\t\tlisteners.splice(i, 1);\n\t\t\t\t} else {\n\t\n\t\t\t\t\tif ((0, _typeAuth.isFunction)(listeners[i])) {\n\t\t\t\t\t\tlisteners[i].apply(null, args.slice(1));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.error('事件总线分发 %s 消息失败，注册的listener不是函数类型！', topic);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\t},\n\t\n\t\tgetListeners: function getListeners(topic) {\n\t\t\treturn topics[topic] || [];\n\t\t}\n\t};\n\n/***/ },\n/* 57 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\t\n\texports.isClass = isClass;\n\texports.isNumber = isNumber;\n\texports.isRegExp = isRegExp;\n\texports.isObject = isObject;\n\texports.isString = isString;\n\texports.isFunction = isFunction;\n\texports.isPromiseLike = isPromiseLike;\n\texports.isElement = isElement;\n\texports.isDefined = isDefined;\n\t/**\n\t * @author Kuitos\n\t * @homepage https://github.com/kuitos/\n\t * @since 2016-06-07\n\t */\n\t\n\tvar msie = window.document.documentMode;\n\tfunction isClass(func) {\n\t\t// IE 9-11 do not support classes and IE9 leaks with the code below.\n\t\tif (msie <= 11) {\n\t\t\treturn false;\n\t\t}\n\t\t// Workaround for MS Edge.\n\t\t// Check https://connect.microsoft.com/IE/Feedback/Details/2211653\n\t\treturn typeof func === 'function' && /^(?:class\\s|constructor\\()/.test(Function.prototype.toString.call(func));\n\t}\n\t\n\tfunction isNumber() {\n\t\treturn typeof value === 'number';\n\t}\n\t\n\tfunction isRegExp(value) {\n\t\treturn Object.prototype.toString.call(value) === '[object RegExp]';\n\t}\n\t\n\tfunction isObject(value) {\n\t\treturn value !== null && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object';\n\t}\n\t\n\tfunction isString(value) {\n\t\treturn typeof value === 'string';\n\t}\n\t\n\tfunction isFunction(value) {\n\t\treturn typeof value === 'function';\n\t}\n\t\n\tfunction isPromiseLike(obj) {\n\t\treturn !!obj && typeof obj.then === 'function';\n\t}\n\t\n\tfunction isElement(node) {\n\t\treturn !!(node && (node.nodeName || node.prop && node.attr && node.find)); // We have an on and find method part of jQuery API.\n\t}\n\t\n\tfunction isDefined(value) {\n\t\treturn typeof value !== 'undefined';\n\t}\n\n/***/ },\n/* 58 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\t\n\tvar _credentials = __webpack_require__(20);\n\t\n\tvar _metadata = __webpack_require__(22);\n\t\n\tvar _tokenRefreshInterceptor = __webpack_require__(19);\n\t\n\tfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; } /**\n\t                                                                                                                                                                                                                   * @author qix\n\t                                                                                                                                                                                                                   * @homepage https://github.com/qixman/\n\t                                                                                                                                                                                                                   * @since 2016-10-11\n\t                                                                                                                                                                                                                   */\n\t\n\t\n\tvar needToRefreshToken = false;\n\t\n\texports.default = {\n\t\n\t\tbeforeSend: function beforeSend(xhr, config) {\n\t\n\t\t\tvar credential = (0, _credentials.getRequestCredential)();\n\t\t\tif (!credential) {\n\t\t\t\t(0, _tokenRefreshInterceptor.execAuthFailure)(xhr);\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\txhr.setRequestHeader(_metadata.REQUEST_TOKEN_HEADER, credential.id);\n\t\t\txhr[_metadata.REQUEST_TOKEN_HEADER] = credential.id;\n\t\t\tif (credential.refreshToken && _metadata.REQUEST_WHITE_LIST.indexOf(config.url) === -1) {\n\t\n\t\t\t\tvar expireTime = _metadata.Date.parse(credential.expireTime);\n\t\t\t\tvar now = _metadata.Date.now();\n\t\n\t\t\t\t// token失效则直接跳转登录页面\n\t\t\t\t// token未失效但是可用时长已低于用户会话最短保留时间,则需要刷新token\n\t\t\t\tif (_metadata.USER_SESSION_AVAILABLE_TIME >= expireTime - now && expireTime - now >= 0) {\n\t\t\t\t\tneedToRefreshToken = true;\n\t\t\t\t} else if (expireTime - now < 0) {\n\t\t\t\t\t// token失效\n\t\t\t\t\t(0, _tokenRefreshInterceptor.execAuthFailure)(xhr);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tcomplete: function complete(xhr) {\n\t\n\t\t\t// 如果请求能正常响应,说明 storage 里的状态是存在的,所以这里不做判断\n\t\t\tvar credential = (0, _credentials.getRequestCredential)();\n\t\t\tvar $ = window.$;\n\t\n\t\t\t// 所有请求结束了才做refreshToken的操作,避免后端因为token被刷新而导致前一请求失败\n\t\t\tif (needToRefreshToken && $.active <= 1) {\n\t\t\t\tneedToRefreshToken = false;\n\t\t\t\txhr[_metadata.REQUEST_TOKEN_HEADER] = credential.id;\n\t\t\t\t// refresh token\n\t\t\t\t$.ajax({\n\t\t\t\t\turl: _tokenRefreshInterceptor.refreshTokenUrl,\n\t\t\t\t\tmethod: 'PUT',\n\t\t\t\t\tdata: credential.refreshToken,\n\t\t\t\t\theaders: _defineProperty({}, _metadata.REQUEST_TOKEN_HEADER, credential.id)\n\t\t\t\t}).done(function (response) {\n\t\t\t\t\t// 更新localStorage中token信息\n\t\t\t\t\t(0, _credentials.setRequestCredential)(JSON.parse(response));\n\t\t\t\t}).fail(function () {\n\t\t\t\t\treturn (0, _tokenRefreshInterceptor.execAuthFailure)(xhr);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t};\n\n/***/ }\n]);\n\n\n// WEBPACK FOOTER //\n// app-e5e8e5b91d48d7dcdf0e.min.js","import angular from 'angular';\r\nimport ngResource from 'angular-resource';\r\nimport ngAnimate from 'angular-animate';\r\nimport ngSanitize from 'angular-sanitize';\r\nimport ccmsComponents from 'ccms-components';\r\nimport projectRouter from '../common/project-router/project.js';\r\nimport router from './router';\r\nimport commonDirectve from '../components';\r\nimport insert from './insert';\r\nimport Configs from './config';\r\nimport { setAuthFailedBehavior, setRefreshTokenUrl } from 'ccms-sdk/interceptors/token-refresh-interceptor';\r\nimport tokenRefreshInterceptor from 'ccms-sdk/interceptors/token-refresh-interceptor-jq';\r\n\r\nsetRefreshTokenUrl(Configs.passport + '/credentials/refresh');\r\nsetAuthFailedBehavior(function() {\r\n  if (__pro__) {\r\n    location.replace('/portal/timeout.html');\r\n  } else {\r\n    location.replace('/portal/login.html');\r\n  }\r\n});\r\n\r\nwindow.$.ajaxSetup(tokenRefreshInterceptor);\r\n\r\nvar webApp = angular.module('ccmsApp', [projectRouter, ngAnimate, ngSanitize, ngResource, ccmsComponents, commonDirectve, insert]);\r\nwebApp.config(router);\r\n\r\nwebApp.run(['$rootScope', function($rootScope) {\r\n  $rootScope.$on('$viewContentLoading', function(event, viewConfig) {\r\n    $rootScope.tmlLoaded = false;\r\n  });\r\n  $rootScope.$on('$viewContentLoaded', function(event, viewConfig) {\r\n    $rootScope.tmlLoaded = true;\r\n  });\r\n  $rootScope.$on('$stateChangeStart', function(e, toState, toParams, fromState, fromParams, options) {\r\n    if (!options.isTrigger) {\r\n      sessionStorage.removeItem('marketingParams');\r\n    }\r\n  });\r\n}]);\r\n\n\n\n// WEBPACK FOOTER //\n// ./app/app.js","require('./angular-animate');\nmodule.exports = 'ngAnimate';\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/angular-animate/index.js\n// module id = 5\n// module chunks = 0","/**\n * @license AngularJS v1.5.8\n * (c) 2010-2016 Google, Inc. http://angularjs.org\n * License: MIT\n */\n(function(window, angular) {'use strict';\n\nvar ELEMENT_NODE = 1;\nvar COMMENT_NODE = 8;\n\nvar ADD_CLASS_SUFFIX = '-add';\nvar REMOVE_CLASS_SUFFIX = '-remove';\nvar EVENT_CLASS_PREFIX = 'ng-';\nvar ACTIVE_CLASS_SUFFIX = '-active';\nvar PREPARE_CLASS_SUFFIX = '-prepare';\n\nvar NG_ANIMATE_CLASSNAME = 'ng-animate';\nvar NG_ANIMATE_CHILDREN_DATA = '$$ngAnimateChildren';\n\n// Detect proper transitionend/animationend event names.\nvar CSS_PREFIX = '', TRANSITION_PROP, TRANSITIONEND_EVENT, ANIMATION_PROP, ANIMATIONEND_EVENT;\n\n// If unprefixed events are not supported but webkit-prefixed are, use the latter.\n// Otherwise, just use W3C names, browsers not supporting them at all will just ignore them.\n// Note: Chrome implements `window.onwebkitanimationend` and doesn't implement `window.onanimationend`\n// but at the same time dispatches the `animationend` event and not `webkitAnimationEnd`.\n// Register both events in case `window.onanimationend` is not supported because of that,\n// do the same for `transitionend` as Safari is likely to exhibit similar behavior.\n// Also, the only modern browser that uses vendor prefixes for transitions/keyframes is webkit\n// therefore there is no reason to test anymore for other vendor prefixes:\n// http://caniuse.com/#search=transition\nif ((window.ontransitionend === void 0) && (window.onwebkittransitionend !== void 0)) {\n  CSS_PREFIX = '-webkit-';\n  TRANSITION_PROP = 'WebkitTransition';\n  TRANSITIONEND_EVENT = 'webkitTransitionEnd transitionend';\n} else {\n  TRANSITION_PROP = 'transition';\n  TRANSITIONEND_EVENT = 'transitionend';\n}\n\nif ((window.onanimationend === void 0) && (window.onwebkitanimationend !== void 0)) {\n  CSS_PREFIX = '-webkit-';\n  ANIMATION_PROP = 'WebkitAnimation';\n  ANIMATIONEND_EVENT = 'webkitAnimationEnd animationend';\n} else {\n  ANIMATION_PROP = 'animation';\n  ANIMATIONEND_EVENT = 'animationend';\n}\n\nvar DURATION_KEY = 'Duration';\nvar PROPERTY_KEY = 'Property';\nvar DELAY_KEY = 'Delay';\nvar TIMING_KEY = 'TimingFunction';\nvar ANIMATION_ITERATION_COUNT_KEY = 'IterationCount';\nvar ANIMATION_PLAYSTATE_KEY = 'PlayState';\nvar SAFE_FAST_FORWARD_DURATION_VALUE = 9999;\n\nvar ANIMATION_DELAY_PROP = ANIMATION_PROP + DELAY_KEY;\nvar ANIMATION_DURATION_PROP = ANIMATION_PROP + DURATION_KEY;\nvar TRANSITION_DELAY_PROP = TRANSITION_PROP + DELAY_KEY;\nvar TRANSITION_DURATION_PROP = TRANSITION_PROP + DURATION_KEY;\n\nvar ngMinErr = angular.$$minErr('ng');\nfunction assertArg(arg, name, reason) {\n  if (!arg) {\n    throw ngMinErr('areq', \"Argument '{0}' is {1}\", (name || '?'), (reason || \"required\"));\n  }\n  return arg;\n}\n\nfunction mergeClasses(a,b) {\n  if (!a && !b) return '';\n  if (!a) return b;\n  if (!b) return a;\n  if (isArray(a)) a = a.join(' ');\n  if (isArray(b)) b = b.join(' ');\n  return a + ' ' + b;\n}\n\nfunction packageStyles(options) {\n  var styles = {};\n  if (options && (options.to || options.from)) {\n    styles.to = options.to;\n    styles.from = options.from;\n  }\n  return styles;\n}\n\nfunction pendClasses(classes, fix, isPrefix) {\n  var className = '';\n  classes = isArray(classes)\n      ? classes\n      : classes && isString(classes) && classes.length\n          ? classes.split(/\\s+/)\n          : [];\n  forEach(classes, function(klass, i) {\n    if (klass && klass.length > 0) {\n      className += (i > 0) ? ' ' : '';\n      className += isPrefix ? fix + klass\n                            : klass + fix;\n    }\n  });\n  return className;\n}\n\nfunction removeFromArray(arr, val) {\n  var index = arr.indexOf(val);\n  if (val >= 0) {\n    arr.splice(index, 1);\n  }\n}\n\nfunction stripCommentsFromElement(element) {\n  if (element instanceof jqLite) {\n    switch (element.length) {\n      case 0:\n        return element;\n\n      case 1:\n        // there is no point of stripping anything if the element\n        // is the only element within the jqLite wrapper.\n        // (it's important that we retain the element instance.)\n        if (element[0].nodeType === ELEMENT_NODE) {\n          return element;\n        }\n        break;\n\n      default:\n        return jqLite(extractElementNode(element));\n    }\n  }\n\n  if (element.nodeType === ELEMENT_NODE) {\n    return jqLite(element);\n  }\n}\n\nfunction extractElementNode(element) {\n  if (!element[0]) return element;\n  for (var i = 0; i < element.length; i++) {\n    var elm = element[i];\n    if (elm.nodeType == ELEMENT_NODE) {\n      return elm;\n    }\n  }\n}\n\nfunction $$addClass($$jqLite, element, className) {\n  forEach(element, function(elm) {\n    $$jqLite.addClass(elm, className);\n  });\n}\n\nfunction $$removeClass($$jqLite, element, className) {\n  forEach(element, function(elm) {\n    $$jqLite.removeClass(elm, className);\n  });\n}\n\nfunction applyAnimationClassesFactory($$jqLite) {\n  return function(element, options) {\n    if (options.addClass) {\n      $$addClass($$jqLite, element, options.addClass);\n      options.addClass = null;\n    }\n    if (options.removeClass) {\n      $$removeClass($$jqLite, element, options.removeClass);\n      options.removeClass = null;\n    }\n  };\n}\n\nfunction prepareAnimationOptions(options) {\n  options = options || {};\n  if (!options.$$prepared) {\n    var domOperation = options.domOperation || noop;\n    options.domOperation = function() {\n      options.$$domOperationFired = true;\n      domOperation();\n      domOperation = noop;\n    };\n    options.$$prepared = true;\n  }\n  return options;\n}\n\nfunction applyAnimationStyles(element, options) {\n  applyAnimationFromStyles(element, options);\n  applyAnimationToStyles(element, options);\n}\n\nfunction applyAnimationFromStyles(element, options) {\n  if (options.from) {\n    element.css(options.from);\n    options.from = null;\n  }\n}\n\nfunction applyAnimationToStyles(element, options) {\n  if (options.to) {\n    element.css(options.to);\n    options.to = null;\n  }\n}\n\nfunction mergeAnimationDetails(element, oldAnimation, newAnimation) {\n  var target = oldAnimation.options || {};\n  var newOptions = newAnimation.options || {};\n\n  var toAdd = (target.addClass || '') + ' ' + (newOptions.addClass || '');\n  var toRemove = (target.removeClass || '') + ' ' + (newOptions.removeClass || '');\n  var classes = resolveElementClasses(element.attr('class'), toAdd, toRemove);\n\n  if (newOptions.preparationClasses) {\n    target.preparationClasses = concatWithSpace(newOptions.preparationClasses, target.preparationClasses);\n    delete newOptions.preparationClasses;\n  }\n\n  // noop is basically when there is no callback; otherwise something has been set\n  var realDomOperation = target.domOperation !== noop ? target.domOperation : null;\n\n  extend(target, newOptions);\n\n  // TODO(matsko or sreeramu): proper fix is to maintain all animation callback in array and call at last,but now only leave has the callback so no issue with this.\n  if (realDomOperation) {\n    target.domOperation = realDomOperation;\n  }\n\n  if (classes.addClass) {\n    target.addClass = classes.addClass;\n  } else {\n    target.addClass = null;\n  }\n\n  if (classes.removeClass) {\n    target.removeClass = classes.removeClass;\n  } else {\n    target.removeClass = null;\n  }\n\n  oldAnimation.addClass = target.addClass;\n  oldAnimation.removeClass = target.removeClass;\n\n  return target;\n}\n\nfunction resolveElementClasses(existing, toAdd, toRemove) {\n  var ADD_CLASS = 1;\n  var REMOVE_CLASS = -1;\n\n  var flags = {};\n  existing = splitClassesToLookup(existing);\n\n  toAdd = splitClassesToLookup(toAdd);\n  forEach(toAdd, function(value, key) {\n    flags[key] = ADD_CLASS;\n  });\n\n  toRemove = splitClassesToLookup(toRemove);\n  forEach(toRemove, function(value, key) {\n    flags[key] = flags[key] === ADD_CLASS ? null : REMOVE_CLASS;\n  });\n\n  var classes = {\n    addClass: '',\n    removeClass: ''\n  };\n\n  forEach(flags, function(val, klass) {\n    var prop, allow;\n    if (val === ADD_CLASS) {\n      prop = 'addClass';\n      allow = !existing[klass] || existing[klass + REMOVE_CLASS_SUFFIX];\n    } else if (val === REMOVE_CLASS) {\n      prop = 'removeClass';\n      allow = existing[klass] || existing[klass + ADD_CLASS_SUFFIX];\n    }\n    if (allow) {\n      if (classes[prop].length) {\n        classes[prop] += ' ';\n      }\n      classes[prop] += klass;\n    }\n  });\n\n  function splitClassesToLookup(classes) {\n    if (isString(classes)) {\n      classes = classes.split(' ');\n    }\n\n    var obj = {};\n    forEach(classes, function(klass) {\n      // sometimes the split leaves empty string values\n      // incase extra spaces were applied to the options\n      if (klass.length) {\n        obj[klass] = true;\n      }\n    });\n    return obj;\n  }\n\n  return classes;\n}\n\nfunction getDomNode(element) {\n  return (element instanceof jqLite) ? element[0] : element;\n}\n\nfunction applyGeneratedPreparationClasses(element, event, options) {\n  var classes = '';\n  if (event) {\n    classes = pendClasses(event, EVENT_CLASS_PREFIX, true);\n  }\n  if (options.addClass) {\n    classes = concatWithSpace(classes, pendClasses(options.addClass, ADD_CLASS_SUFFIX));\n  }\n  if (options.removeClass) {\n    classes = concatWithSpace(classes, pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX));\n  }\n  if (classes.length) {\n    options.preparationClasses = classes;\n    element.addClass(classes);\n  }\n}\n\nfunction clearGeneratedClasses(element, options) {\n  if (options.preparationClasses) {\n    element.removeClass(options.preparationClasses);\n    options.preparationClasses = null;\n  }\n  if (options.activeClasses) {\n    element.removeClass(options.activeClasses);\n    options.activeClasses = null;\n  }\n}\n\nfunction blockTransitions(node, duration) {\n  // we use a negative delay value since it performs blocking\n  // yet it doesn't kill any existing transitions running on the\n  // same element which makes this safe for class-based animations\n  var value = duration ? '-' + duration + 's' : '';\n  applyInlineStyle(node, [TRANSITION_DELAY_PROP, value]);\n  return [TRANSITION_DELAY_PROP, value];\n}\n\nfunction blockKeyframeAnimations(node, applyBlock) {\n  var value = applyBlock ? 'paused' : '';\n  var key = ANIMATION_PROP + ANIMATION_PLAYSTATE_KEY;\n  applyInlineStyle(node, [key, value]);\n  return [key, value];\n}\n\nfunction applyInlineStyle(node, styleTuple) {\n  var prop = styleTuple[0];\n  var value = styleTuple[1];\n  node.style[prop] = value;\n}\n\nfunction concatWithSpace(a,b) {\n  if (!a) return b;\n  if (!b) return a;\n  return a + ' ' + b;\n}\n\nvar $$rAFSchedulerFactory = ['$$rAF', function($$rAF) {\n  var queue, cancelFn;\n\n  function scheduler(tasks) {\n    // we make a copy since RAFScheduler mutates the state\n    // of the passed in array variable and this would be difficult\n    // to track down on the outside code\n    queue = queue.concat(tasks);\n    nextTick();\n  }\n\n  queue = scheduler.queue = [];\n\n  /* waitUntilQuiet does two things:\n   * 1. It will run the FINAL `fn` value only when an uncanceled RAF has passed through\n   * 2. It will delay the next wave of tasks from running until the quiet `fn` has run.\n   *\n   * The motivation here is that animation code can request more time from the scheduler\n   * before the next wave runs. This allows for certain DOM properties such as classes to\n   * be resolved in time for the next animation to run.\n   */\n  scheduler.waitUntilQuiet = function(fn) {\n    if (cancelFn) cancelFn();\n\n    cancelFn = $$rAF(function() {\n      cancelFn = null;\n      fn();\n      nextTick();\n    });\n  };\n\n  return scheduler;\n\n  function nextTick() {\n    if (!queue.length) return;\n\n    var items = queue.shift();\n    for (var i = 0; i < items.length; i++) {\n      items[i]();\n    }\n\n    if (!cancelFn) {\n      $$rAF(function() {\n        if (!cancelFn) nextTick();\n      });\n    }\n  }\n}];\n\n/**\n * @ngdoc directive\n * @name ngAnimateChildren\n * @restrict AE\n * @element ANY\n *\n * @description\n *\n * ngAnimateChildren allows you to specify that children of this element should animate even if any\n * of the children's parents are currently animating. By default, when an element has an active `enter`, `leave`, or `move`\n * (structural) animation, child elements that also have an active structural animation are not animated.\n *\n * Note that even if `ngAnimteChildren` is set, no child animations will run when the parent element is removed from the DOM (`leave` animation).\n *\n *\n * @param {string} ngAnimateChildren If the value is empty, `true` or `on`,\n *     then child animations are allowed. If the value is `false`, child animations are not allowed.\n *\n * @example\n * <example module=\"ngAnimateChildren\" name=\"ngAnimateChildren\" deps=\"angular-animate.js\" animations=\"true\">\n     <file name=\"index.html\">\n       <div ng-controller=\"mainController as main\">\n         <label>Show container? <input type=\"checkbox\" ng-model=\"main.enterElement\" /></label>\n         <label>Animate children? <input type=\"checkbox\" ng-model=\"main.animateChildren\" /></label>\n         <hr>\n         <div ng-animate-children=\"{{main.animateChildren}}\">\n           <div ng-if=\"main.enterElement\" class=\"container\">\n             List of items:\n             <div ng-repeat=\"item in [0, 1, 2, 3]\" class=\"item\">Item {{item}}</div>\n           </div>\n         </div>\n       </div>\n     </file>\n     <file name=\"animations.css\">\n\n      .container.ng-enter,\n      .container.ng-leave {\n        transition: all ease 1.5s;\n      }\n\n      .container.ng-enter,\n      .container.ng-leave-active {\n        opacity: 0;\n      }\n\n      .container.ng-leave,\n      .container.ng-enter-active {\n        opacity: 1;\n      }\n\n      .item {\n        background: firebrick;\n        color: #FFF;\n        margin-bottom: 10px;\n      }\n\n      .item.ng-enter,\n      .item.ng-leave {\n        transition: transform 1.5s ease;\n      }\n\n      .item.ng-enter {\n        transform: translateX(50px);\n      }\n\n      .item.ng-enter-active {\n        transform: translateX(0);\n      }\n    </file>\n    <file name=\"script.js\">\n      angular.module('ngAnimateChildren', ['ngAnimate'])\n        .controller('mainController', function() {\n          this.animateChildren = false;\n          this.enterElement = false;\n        });\n    </file>\n  </example>\n */\nvar $$AnimateChildrenDirective = ['$interpolate', function($interpolate) {\n  return {\n    link: function(scope, element, attrs) {\n      var val = attrs.ngAnimateChildren;\n      if (isString(val) && val.length === 0) { //empty attribute\n        element.data(NG_ANIMATE_CHILDREN_DATA, true);\n      } else {\n        // Interpolate and set the value, so that it is available to\n        // animations that run right after compilation\n        setData($interpolate(val)(scope));\n        attrs.$observe('ngAnimateChildren', setData);\n      }\n\n      function setData(value) {\n        value = value === 'on' || value === 'true';\n        element.data(NG_ANIMATE_CHILDREN_DATA, value);\n      }\n    }\n  };\n}];\n\nvar ANIMATE_TIMER_KEY = '$$animateCss';\n\n/**\n * @ngdoc service\n * @name $animateCss\n * @kind object\n *\n * @description\n * The `$animateCss` service is a useful utility to trigger customized CSS-based transitions/keyframes\n * from a JavaScript-based animation or directly from a directive. The purpose of `$animateCss` is NOT\n * to side-step how `$animate` and ngAnimate work, but the goal is to allow pre-existing animations or\n * directives to create more complex animations that can be purely driven using CSS code.\n *\n * Note that only browsers that support CSS transitions and/or keyframe animations are capable of\n * rendering animations triggered via `$animateCss` (bad news for IE9 and lower).\n *\n * ## Usage\n * Once again, `$animateCss` is designed to be used inside of a registered JavaScript animation that\n * is powered by ngAnimate. It is possible to use `$animateCss` directly inside of a directive, however,\n * any automatic control over cancelling animations and/or preventing animations from being run on\n * child elements will not be handled by Angular. For this to work as expected, please use `$animate` to\n * trigger the animation and then setup a JavaScript animation that injects `$animateCss` to trigger\n * the CSS animation.\n *\n * The example below shows how we can create a folding animation on an element using `ng-if`:\n *\n * ```html\n * <!-- notice the `fold-animation` CSS class -->\n * <div ng-if=\"onOff\" class=\"fold-animation\">\n *   This element will go BOOM\n * </div>\n * <button ng-click=\"onOff=true\">Fold In</button>\n * ```\n *\n * Now we create the **JavaScript animation** that will trigger the CSS transition:\n *\n * ```js\n * ngModule.animation('.fold-animation', ['$animateCss', function($animateCss) {\n *   return {\n *     enter: function(element, doneFn) {\n *       var height = element[0].offsetHeight;\n *       return $animateCss(element, {\n *         from: { height:'0px' },\n *         to: { height:height + 'px' },\n *         duration: 1 // one second\n *       });\n *     }\n *   }\n * }]);\n * ```\n *\n * ## More Advanced Uses\n *\n * `$animateCss` is the underlying code that ngAnimate uses to power **CSS-based animations** behind the scenes. Therefore CSS hooks\n * like `.ng-EVENT`, `.ng-EVENT-active`, `.ng-EVENT-stagger` are all features that can be triggered using `$animateCss` via JavaScript code.\n *\n * This also means that just about any combination of adding classes, removing classes, setting styles, dynamically setting a keyframe animation,\n * applying a hardcoded duration or delay value, changing the animation easing or applying a stagger animation are all options that work with\n * `$animateCss`. The service itself is smart enough to figure out the combination of options and examine the element styling properties in order\n * to provide a working animation that will run in CSS.\n *\n * The example below showcases a more advanced version of the `.fold-animation` from the example above:\n *\n * ```js\n * ngModule.animation('.fold-animation', ['$animateCss', function($animateCss) {\n *   return {\n *     enter: function(element, doneFn) {\n *       var height = element[0].offsetHeight;\n *       return $animateCss(element, {\n *         addClass: 'red large-text pulse-twice',\n *         easing: 'ease-out',\n *         from: { height:'0px' },\n *         to: { height:height + 'px' },\n *         duration: 1 // one second\n *       });\n *     }\n *   }\n * }]);\n * ```\n *\n * Since we're adding/removing CSS classes then the CSS transition will also pick those up:\n *\n * ```css\n * /&#42; since a hardcoded duration value of 1 was provided in the JavaScript animation code,\n * the CSS classes below will be transitioned despite them being defined as regular CSS classes &#42;/\n * .red { background:red; }\n * .large-text { font-size:20px; }\n *\n * /&#42; we can also use a keyframe animation and $animateCss will make it work alongside the transition &#42;/\n * .pulse-twice {\n *   animation: 0.5s pulse linear 2;\n *   -webkit-animation: 0.5s pulse linear 2;\n * }\n *\n * @keyframes pulse {\n *   from { transform: scale(0.5); }\n *   to { transform: scale(1.5); }\n * }\n *\n * @-webkit-keyframes pulse {\n *   from { -webkit-transform: scale(0.5); }\n *   to { -webkit-transform: scale(1.5); }\n * }\n * ```\n *\n * Given this complex combination of CSS classes, styles and options, `$animateCss` will figure everything out and make the animation happen.\n *\n * ## How the Options are handled\n *\n * `$animateCss` is very versatile and intelligent when it comes to figuring out what configurations to apply to the element to ensure the animation\n * works with the options provided. Say for example we were adding a class that contained a keyframe value and we wanted to also animate some inline\n * styles using the `from` and `to` properties.\n *\n * ```js\n * var animator = $animateCss(element, {\n *   from: { background:'red' },\n *   to: { background:'blue' }\n * });\n * animator.start();\n * ```\n *\n * ```css\n * .rotating-animation {\n *   animation:0.5s rotate linear;\n *   -webkit-animation:0.5s rotate linear;\n * }\n *\n * @keyframes rotate {\n *   from { transform: rotate(0deg); }\n *   to { transform: rotate(360deg); }\n * }\n *\n * @-webkit-keyframes rotate {\n *   from { -webkit-transform: rotate(0deg); }\n *   to { -webkit-transform: rotate(360deg); }\n * }\n * ```\n *\n * The missing pieces here are that we do not have a transition set (within the CSS code nor within the `$animateCss` options) and the duration of the animation is\n * going to be detected from what the keyframe styles on the CSS class are. In this event, `$animateCss` will automatically create an inline transition\n * style matching the duration detected from the keyframe style (which is present in the CSS class that is being added) and then prepare both the transition\n * and keyframe animations to run in parallel on the element. Then when the animation is underway the provided `from` and `to` CSS styles will be applied\n * and spread across the transition and keyframe animation.\n *\n * ## What is returned\n *\n * `$animateCss` works in two stages: a preparation phase and an animation phase. Therefore when `$animateCss` is first called it will NOT actually\n * start the animation. All that is going on here is that the element is being prepared for the animation (which means that the generated CSS classes are\n * added and removed on the element). Once `$animateCss` is called it will return an object with the following properties:\n *\n * ```js\n * var animator = $animateCss(element, { ... });\n * ```\n *\n * Now what do the contents of our `animator` variable look like:\n *\n * ```js\n * {\n *   // starts the animation\n *   start: Function,\n *\n *   // ends (aborts) the animation\n *   end: Function\n * }\n * ```\n *\n * To actually start the animation we need to run `animation.start()` which will then return a promise that we can hook into to detect when the animation ends.\n * If we choose not to run the animation then we MUST run `animation.end()` to perform a cleanup on the element (since some CSS classes and styles may have been\n * applied to the element during the preparation phase). Note that all other properties such as duration, delay, transitions and keyframes are just properties\n * and that changing them will not reconfigure the parameters of the animation.\n *\n * ### runner.done() vs runner.then()\n * It is documented that `animation.start()` will return a promise object and this is true, however, there is also an additional method available on the\n * runner called `.done(callbackFn)`. The done method works the same as `.finally(callbackFn)`, however, it does **not trigger a digest to occur**.\n * Therefore, for performance reasons, it's always best to use `runner.done(callback)` instead of `runner.then()`, `runner.catch()` or `runner.finally()`\n * unless you really need a digest to kick off afterwards.\n *\n * Keep in mind that, to make this easier, ngAnimate has tweaked the JS animations API to recognize when a runner instance is returned from $animateCss\n * (so there is no need to call `runner.done(doneFn)` inside of your JavaScript animation code).\n * Check the {@link ngAnimate.$animateCss#usage animation code above} to see how this works.\n *\n * @param {DOMElement} element the element that will be animated\n * @param {object} options the animation-related options that will be applied during the animation\n *\n * * `event` - The DOM event (e.g. enter, leave, move). When used, a generated CSS class of `ng-EVENT` and `ng-EVENT-active` will be applied\n * to the element during the animation. Multiple events can be provided when spaces are used as a separator. (Note that this will not perform any DOM operation.)\n * * `structural` - Indicates that the `ng-` prefix will be added to the event class. Setting to `false` or omitting will turn `ng-EVENT` and\n * `ng-EVENT-active` in `EVENT` and `EVENT-active`. Unused if `event` is omitted.\n * * `easing` - The CSS easing value that will be applied to the transition or keyframe animation (or both).\n * * `transitionStyle` - The raw CSS transition style that will be used (e.g. `1s linear all`).\n * * `keyframeStyle` - The raw CSS keyframe animation style that will be used (e.g. `1s my_animation linear`).\n * * `from` - The starting CSS styles (a key/value object) that will be applied at the start of the animation.\n * * `to` - The ending CSS styles (a key/value object) that will be applied across the animation via a CSS transition.\n * * `addClass` - A space separated list of CSS classes that will be added to the element and spread across the animation.\n * * `removeClass` - A space separated list of CSS classes that will be removed from the element and spread across the animation.\n * * `duration` - A number value representing the total duration of the transition and/or keyframe (note that a value of 1 is 1000ms). If a value of `0`\n * is provided then the animation will be skipped entirely.\n * * `delay` - A number value representing the total delay of the transition and/or keyframe (note that a value of 1 is 1000ms). If a value of `true` is\n * used then whatever delay value is detected from the CSS classes will be mirrored on the elements styles (e.g. by setting delay true then the style value\n * of the element will be `transition-delay: DETECTED_VALUE`). Using `true` is useful when you want the CSS classes and inline styles to all share the same\n * CSS delay value.\n * * `stagger` - A numeric time value representing the delay between successively animated elements\n * ({@link ngAnimate#css-staggering-animations Click here to learn how CSS-based staggering works in ngAnimate.})\n * * `staggerIndex` - The numeric index representing the stagger item (e.g. a value of 5 is equal to the sixth item in the stagger; therefore when a\n *   `stagger` option value of `0.1` is used then there will be a stagger delay of `600ms`)\n * * `applyClassesEarly` - Whether or not the classes being added or removed will be used when detecting the animation. This is set by `$animate` when enter/leave/move animations are fired to ensure that the CSS classes are resolved in time. (Note that this will prevent any transitions from occurring on the classes being added and removed.)\n * * `cleanupStyles` - Whether or not the provided `from` and `to` styles will be removed once\n *    the animation is closed. This is useful for when the styles are used purely for the sake of\n *    the animation and do not have a lasting visual effect on the element (e.g. a collapse and open animation).\n *    By default this value is set to `false`.\n *\n * @return {object} an object with start and end methods and details about the animation.\n *\n * * `start` - The method to start the animation. This will return a `Promise` when called.\n * * `end` - This method will cancel the animation and remove all applied CSS classes and styles.\n */\nvar ONE_SECOND = 1000;\nvar BASE_TEN = 10;\n\nvar ELAPSED_TIME_MAX_DECIMAL_PLACES = 3;\nvar CLOSING_TIME_BUFFER = 1.5;\n\nvar DETECT_CSS_PROPERTIES = {\n  transitionDuration:      TRANSITION_DURATION_PROP,\n  transitionDelay:         TRANSITION_DELAY_PROP,\n  transitionProperty:      TRANSITION_PROP + PROPERTY_KEY,\n  animationDuration:       ANIMATION_DURATION_PROP,\n  animationDelay:          ANIMATION_DELAY_PROP,\n  animationIterationCount: ANIMATION_PROP + ANIMATION_ITERATION_COUNT_KEY\n};\n\nvar DETECT_STAGGER_CSS_PROPERTIES = {\n  transitionDuration:      TRANSITION_DURATION_PROP,\n  transitionDelay:         TRANSITION_DELAY_PROP,\n  animationDuration:       ANIMATION_DURATION_PROP,\n  animationDelay:          ANIMATION_DELAY_PROP\n};\n\nfunction getCssKeyframeDurationStyle(duration) {\n  return [ANIMATION_DURATION_PROP, duration + 's'];\n}\n\nfunction getCssDelayStyle(delay, isKeyframeAnimation) {\n  var prop = isKeyframeAnimation ? ANIMATION_DELAY_PROP : TRANSITION_DELAY_PROP;\n  return [prop, delay + 's'];\n}\n\nfunction computeCssStyles($window, element, properties) {\n  var styles = Object.create(null);\n  var detectedStyles = $window.getComputedStyle(element) || {};\n  forEach(properties, function(formalStyleName, actualStyleName) {\n    var val = detectedStyles[formalStyleName];\n    if (val) {\n      var c = val.charAt(0);\n\n      // only numerical-based values have a negative sign or digit as the first value\n      if (c === '-' || c === '+' || c >= 0) {\n        val = parseMaxTime(val);\n      }\n\n      // by setting this to null in the event that the delay is not set or is set directly as 0\n      // then we can still allow for negative values to be used later on and not mistake this\n      // value for being greater than any other negative value.\n      if (val === 0) {\n        val = null;\n      }\n      styles[actualStyleName] = val;\n    }\n  });\n\n  return styles;\n}\n\nfunction parseMaxTime(str) {\n  var maxValue = 0;\n  var values = str.split(/\\s*,\\s*/);\n  forEach(values, function(value) {\n    // it's always safe to consider only second values and omit `ms` values since\n    // getComputedStyle will always handle the conversion for us\n    if (value.charAt(value.length - 1) == 's') {\n      value = value.substring(0, value.length - 1);\n    }\n    value = parseFloat(value) || 0;\n    maxValue = maxValue ? Math.max(value, maxValue) : value;\n  });\n  return maxValue;\n}\n\nfunction truthyTimingValue(val) {\n  return val === 0 || val != null;\n}\n\nfunction getCssTransitionDurationStyle(duration, applyOnlyDuration) {\n  var style = TRANSITION_PROP;\n  var value = duration + 's';\n  if (applyOnlyDuration) {\n    style += DURATION_KEY;\n  } else {\n    value += ' linear all';\n  }\n  return [style, value];\n}\n\nfunction createLocalCacheLookup() {\n  var cache = Object.create(null);\n  return {\n    flush: function() {\n      cache = Object.create(null);\n    },\n\n    count: function(key) {\n      var entry = cache[key];\n      return entry ? entry.total : 0;\n    },\n\n    get: function(key) {\n      var entry = cache[key];\n      return entry && entry.value;\n    },\n\n    put: function(key, value) {\n      if (!cache[key]) {\n        cache[key] = { total: 1, value: value };\n      } else {\n        cache[key].total++;\n      }\n    }\n  };\n}\n\n// we do not reassign an already present style value since\n// if we detect the style property value again we may be\n// detecting styles that were added via the `from` styles.\n// We make use of `isDefined` here since an empty string\n// or null value (which is what getPropertyValue will return\n// for a non-existing style) will still be marked as a valid\n// value for the style (a falsy value implies that the style\n// is to be removed at the end of the animation). If we had a simple\n// \"OR\" statement then it would not be enough to catch that.\nfunction registerRestorableStyles(backup, node, properties) {\n  forEach(properties, function(prop) {\n    backup[prop] = isDefined(backup[prop])\n        ? backup[prop]\n        : node.style.getPropertyValue(prop);\n  });\n}\n\nvar $AnimateCssProvider = ['$animateProvider', function($animateProvider) {\n  var gcsLookup = createLocalCacheLookup();\n  var gcsStaggerLookup = createLocalCacheLookup();\n\n  this.$get = ['$window', '$$jqLite', '$$AnimateRunner', '$timeout',\n               '$$forceReflow', '$sniffer', '$$rAFScheduler', '$$animateQueue',\n       function($window,   $$jqLite,   $$AnimateRunner,   $timeout,\n                $$forceReflow,   $sniffer,   $$rAFScheduler, $$animateQueue) {\n\n    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);\n\n    var parentCounter = 0;\n    function gcsHashFn(node, extraClasses) {\n      var KEY = \"$$ngAnimateParentKey\";\n      var parentNode = node.parentNode;\n      var parentID = parentNode[KEY] || (parentNode[KEY] = ++parentCounter);\n      return parentID + '-' + node.getAttribute('class') + '-' + extraClasses;\n    }\n\n    function computeCachedCssStyles(node, className, cacheKey, properties) {\n      var timings = gcsLookup.get(cacheKey);\n\n      if (!timings) {\n        timings = computeCssStyles($window, node, properties);\n        if (timings.animationIterationCount === 'infinite') {\n          timings.animationIterationCount = 1;\n        }\n      }\n\n      // we keep putting this in multiple times even though the value and the cacheKey are the same\n      // because we're keeping an internal tally of how many duplicate animations are detected.\n      gcsLookup.put(cacheKey, timings);\n      return timings;\n    }\n\n    function computeCachedCssStaggerStyles(node, className, cacheKey, properties) {\n      var stagger;\n\n      // if we have one or more existing matches of matching elements\n      // containing the same parent + CSS styles (which is how cacheKey works)\n      // then staggering is possible\n      if (gcsLookup.count(cacheKey) > 0) {\n        stagger = gcsStaggerLookup.get(cacheKey);\n\n        if (!stagger) {\n          var staggerClassName = pendClasses(className, '-stagger');\n\n          $$jqLite.addClass(node, staggerClassName);\n\n          stagger = computeCssStyles($window, node, properties);\n\n          // force the conversion of a null value to zero incase not set\n          stagger.animationDuration = Math.max(stagger.animationDuration, 0);\n          stagger.transitionDuration = Math.max(stagger.transitionDuration, 0);\n\n          $$jqLite.removeClass(node, staggerClassName);\n\n          gcsStaggerLookup.put(cacheKey, stagger);\n        }\n      }\n\n      return stagger || {};\n    }\n\n    var cancelLastRAFRequest;\n    var rafWaitQueue = [];\n    function waitUntilQuiet(callback) {\n      rafWaitQueue.push(callback);\n      $$rAFScheduler.waitUntilQuiet(function() {\n        gcsLookup.flush();\n        gcsStaggerLookup.flush();\n\n        // DO NOT REMOVE THIS LINE OR REFACTOR OUT THE `pageWidth` variable.\n        // PLEASE EXAMINE THE `$$forceReflow` service to understand why.\n        var pageWidth = $$forceReflow();\n\n        // we use a for loop to ensure that if the queue is changed\n        // during this looping then it will consider new requests\n        for (var i = 0; i < rafWaitQueue.length; i++) {\n          rafWaitQueue[i](pageWidth);\n        }\n        rafWaitQueue.length = 0;\n      });\n    }\n\n    function computeTimings(node, className, cacheKey) {\n      var timings = computeCachedCssStyles(node, className, cacheKey, DETECT_CSS_PROPERTIES);\n      var aD = timings.animationDelay;\n      var tD = timings.transitionDelay;\n      timings.maxDelay = aD && tD\n          ? Math.max(aD, tD)\n          : (aD || tD);\n      timings.maxDuration = Math.max(\n          timings.animationDuration * timings.animationIterationCount,\n          timings.transitionDuration);\n\n      return timings;\n    }\n\n    return function init(element, initialOptions) {\n      // all of the animation functions should create\n      // a copy of the options data, however, if a\n      // parent service has already created a copy then\n      // we should stick to using that\n      var options = initialOptions || {};\n      if (!options.$$prepared) {\n        options = prepareAnimationOptions(copy(options));\n      }\n\n      var restoreStyles = {};\n      var node = getDomNode(element);\n      if (!node\n          || !node.parentNode\n          || !$$animateQueue.enabled()) {\n        return closeAndReturnNoopAnimator();\n      }\n\n      var temporaryStyles = [];\n      var classes = element.attr('class');\n      var styles = packageStyles(options);\n      var animationClosed;\n      var animationPaused;\n      var animationCompleted;\n      var runner;\n      var runnerHost;\n      var maxDelay;\n      var maxDelayTime;\n      var maxDuration;\n      var maxDurationTime;\n      var startTime;\n      var events = [];\n\n      if (options.duration === 0 || (!$sniffer.animations && !$sniffer.transitions)) {\n        return closeAndReturnNoopAnimator();\n      }\n\n      var method = options.event && isArray(options.event)\n            ? options.event.join(' ')\n            : options.event;\n\n      var isStructural = method && options.structural;\n      var structuralClassName = '';\n      var addRemoveClassName = '';\n\n      if (isStructural) {\n        structuralClassName = pendClasses(method, EVENT_CLASS_PREFIX, true);\n      } else if (method) {\n        structuralClassName = method;\n      }\n\n      if (options.addClass) {\n        addRemoveClassName += pendClasses(options.addClass, ADD_CLASS_SUFFIX);\n      }\n\n      if (options.removeClass) {\n        if (addRemoveClassName.length) {\n          addRemoveClassName += ' ';\n        }\n        addRemoveClassName += pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX);\n      }\n\n      // there may be a situation where a structural animation is combined together\n      // with CSS classes that need to resolve before the animation is computed.\n      // However this means that there is no explicit CSS code to block the animation\n      // from happening (by setting 0s none in the class name). If this is the case\n      // we need to apply the classes before the first rAF so we know to continue if\n      // there actually is a detected transition or keyframe animation\n      if (options.applyClassesEarly && addRemoveClassName.length) {\n        applyAnimationClasses(element, options);\n      }\n\n      var preparationClasses = [structuralClassName, addRemoveClassName].join(' ').trim();\n      var fullClassName = classes + ' ' + preparationClasses;\n      var activeClasses = pendClasses(preparationClasses, ACTIVE_CLASS_SUFFIX);\n      var hasToStyles = styles.to && Object.keys(styles.to).length > 0;\n      var containsKeyframeAnimation = (options.keyframeStyle || '').length > 0;\n\n      // there is no way we can trigger an animation if no styles and\n      // no classes are being applied which would then trigger a transition,\n      // unless there a is raw keyframe value that is applied to the element.\n      if (!containsKeyframeAnimation\n           && !hasToStyles\n           && !preparationClasses) {\n        return closeAndReturnNoopAnimator();\n      }\n\n      var cacheKey, stagger;\n      if (options.stagger > 0) {\n        var staggerVal = parseFloat(options.stagger);\n        stagger = {\n          transitionDelay: staggerVal,\n          animationDelay: staggerVal,\n          transitionDuration: 0,\n          animationDuration: 0\n        };\n      } else {\n        cacheKey = gcsHashFn(node, fullClassName);\n        stagger = computeCachedCssStaggerStyles(node, preparationClasses, cacheKey, DETECT_STAGGER_CSS_PROPERTIES);\n      }\n\n      if (!options.$$skipPreparationClasses) {\n        $$jqLite.addClass(element, preparationClasses);\n      }\n\n      var applyOnlyDuration;\n\n      if (options.transitionStyle) {\n        var transitionStyle = [TRANSITION_PROP, options.transitionStyle];\n        applyInlineStyle(node, transitionStyle);\n        temporaryStyles.push(transitionStyle);\n      }\n\n      if (options.duration >= 0) {\n        applyOnlyDuration = node.style[TRANSITION_PROP].length > 0;\n        var durationStyle = getCssTransitionDurationStyle(options.duration, applyOnlyDuration);\n\n        // we set the duration so that it will be picked up by getComputedStyle later\n        applyInlineStyle(node, durationStyle);\n        temporaryStyles.push(durationStyle);\n      }\n\n      if (options.keyframeStyle) {\n        var keyframeStyle = [ANIMATION_PROP, options.keyframeStyle];\n        applyInlineStyle(node, keyframeStyle);\n        temporaryStyles.push(keyframeStyle);\n      }\n\n      var itemIndex = stagger\n          ? options.staggerIndex >= 0\n              ? options.staggerIndex\n              : gcsLookup.count(cacheKey)\n          : 0;\n\n      var isFirst = itemIndex === 0;\n\n      // this is a pre-emptive way of forcing the setup classes to be added and applied INSTANTLY\n      // without causing any combination of transitions to kick in. By adding a negative delay value\n      // it forces the setup class' transition to end immediately. We later then remove the negative\n      // transition delay to allow for the transition to naturally do it's thing. The beauty here is\n      // that if there is no transition defined then nothing will happen and this will also allow\n      // other transitions to be stacked on top of each other without any chopping them out.\n      if (isFirst && !options.skipBlocking) {\n        blockTransitions(node, SAFE_FAST_FORWARD_DURATION_VALUE);\n      }\n\n      var timings = computeTimings(node, fullClassName, cacheKey);\n      var relativeDelay = timings.maxDelay;\n      maxDelay = Math.max(relativeDelay, 0);\n      maxDuration = timings.maxDuration;\n\n      var flags = {};\n      flags.hasTransitions          = timings.transitionDuration > 0;\n      flags.hasAnimations           = timings.animationDuration > 0;\n      flags.hasTransitionAll        = flags.hasTransitions && timings.transitionProperty == 'all';\n      flags.applyTransitionDuration = hasToStyles && (\n                                        (flags.hasTransitions && !flags.hasTransitionAll)\n                                         || (flags.hasAnimations && !flags.hasTransitions));\n      flags.applyAnimationDuration  = options.duration && flags.hasAnimations;\n      flags.applyTransitionDelay    = truthyTimingValue(options.delay) && (flags.applyTransitionDuration || flags.hasTransitions);\n      flags.applyAnimationDelay     = truthyTimingValue(options.delay) && flags.hasAnimations;\n      flags.recalculateTimingStyles = addRemoveClassName.length > 0;\n\n      if (flags.applyTransitionDuration || flags.applyAnimationDuration) {\n        maxDuration = options.duration ? parseFloat(options.duration) : maxDuration;\n\n        if (flags.applyTransitionDuration) {\n          flags.hasTransitions = true;\n          timings.transitionDuration = maxDuration;\n          applyOnlyDuration = node.style[TRANSITION_PROP + PROPERTY_KEY].length > 0;\n          temporaryStyles.push(getCssTransitionDurationStyle(maxDuration, applyOnlyDuration));\n        }\n\n        if (flags.applyAnimationDuration) {\n          flags.hasAnimations = true;\n          timings.animationDuration = maxDuration;\n          temporaryStyles.push(getCssKeyframeDurationStyle(maxDuration));\n        }\n      }\n\n      if (maxDuration === 0 && !flags.recalculateTimingStyles) {\n        return closeAndReturnNoopAnimator();\n      }\n\n      if (options.delay != null) {\n        var delayStyle;\n        if (typeof options.delay !== \"boolean\") {\n          delayStyle = parseFloat(options.delay);\n          // number in options.delay means we have to recalculate the delay for the closing timeout\n          maxDelay = Math.max(delayStyle, 0);\n        }\n\n        if (flags.applyTransitionDelay) {\n          temporaryStyles.push(getCssDelayStyle(delayStyle));\n        }\n\n        if (flags.applyAnimationDelay) {\n          temporaryStyles.push(getCssDelayStyle(delayStyle, true));\n        }\n      }\n\n      // we need to recalculate the delay value since we used a pre-emptive negative\n      // delay value and the delay value is required for the final event checking. This\n      // property will ensure that this will happen after the RAF phase has passed.\n      if (options.duration == null && timings.transitionDuration > 0) {\n        flags.recalculateTimingStyles = flags.recalculateTimingStyles || isFirst;\n      }\n\n      maxDelayTime = maxDelay * ONE_SECOND;\n      maxDurationTime = maxDuration * ONE_SECOND;\n      if (!options.skipBlocking) {\n        flags.blockTransition = timings.transitionDuration > 0;\n        flags.blockKeyframeAnimation = timings.animationDuration > 0 &&\n                                       stagger.animationDelay > 0 &&\n                                       stagger.animationDuration === 0;\n      }\n\n      if (options.from) {\n        if (options.cleanupStyles) {\n          registerRestorableStyles(restoreStyles, node, Object.keys(options.from));\n        }\n        applyAnimationFromStyles(element, options);\n      }\n\n      if (flags.blockTransition || flags.blockKeyframeAnimation) {\n        applyBlocking(maxDuration);\n      } else if (!options.skipBlocking) {\n        blockTransitions(node, false);\n      }\n\n      // TODO(matsko): for 1.5 change this code to have an animator object for better debugging\n      return {\n        $$willAnimate: true,\n        end: endFn,\n        start: function() {\n          if (animationClosed) return;\n\n          runnerHost = {\n            end: endFn,\n            cancel: cancelFn,\n            resume: null, //this will be set during the start() phase\n            pause: null\n          };\n\n          runner = new $$AnimateRunner(runnerHost);\n\n          waitUntilQuiet(start);\n\n          // we don't have access to pause/resume the animation\n          // since it hasn't run yet. AnimateRunner will therefore\n          // set noop functions for resume and pause and they will\n          // later be overridden once the animation is triggered\n          return runner;\n        }\n      };\n\n      function endFn() {\n        close();\n      }\n\n      function cancelFn() {\n        close(true);\n      }\n\n      function close(rejected) { // jshint ignore:line\n        // if the promise has been called already then we shouldn't close\n        // the animation again\n        if (animationClosed || (animationCompleted && animationPaused)) return;\n        animationClosed = true;\n        animationPaused = false;\n\n        if (!options.$$skipPreparationClasses) {\n          $$jqLite.removeClass(element, preparationClasses);\n        }\n        $$jqLite.removeClass(element, activeClasses);\n\n        blockKeyframeAnimations(node, false);\n        blockTransitions(node, false);\n\n        forEach(temporaryStyles, function(entry) {\n          // There is only one way to remove inline style properties entirely from elements.\n          // By using `removeProperty` this works, but we need to convert camel-cased CSS\n          // styles down to hyphenated values.\n          node.style[entry[0]] = '';\n        });\n\n        applyAnimationClasses(element, options);\n        applyAnimationStyles(element, options);\n\n        if (Object.keys(restoreStyles).length) {\n          forEach(restoreStyles, function(value, prop) {\n            value ? node.style.setProperty(prop, value)\n                  : node.style.removeProperty(prop);\n          });\n        }\n\n        // the reason why we have this option is to allow a synchronous closing callback\n        // that is fired as SOON as the animation ends (when the CSS is removed) or if\n        // the animation never takes off at all. A good example is a leave animation since\n        // the element must be removed just after the animation is over or else the element\n        // will appear on screen for one animation frame causing an overbearing flicker.\n        if (options.onDone) {\n          options.onDone();\n        }\n\n        if (events && events.length) {\n          // Remove the transitionend / animationend listener(s)\n          element.off(events.join(' '), onAnimationProgress);\n        }\n\n        //Cancel the fallback closing timeout and remove the timer data\n        var animationTimerData = element.data(ANIMATE_TIMER_KEY);\n        if (animationTimerData) {\n          $timeout.cancel(animationTimerData[0].timer);\n          element.removeData(ANIMATE_TIMER_KEY);\n        }\n\n        // if the preparation function fails then the promise is not setup\n        if (runner) {\n          runner.complete(!rejected);\n        }\n      }\n\n      function applyBlocking(duration) {\n        if (flags.blockTransition) {\n          blockTransitions(node, duration);\n        }\n\n        if (flags.blockKeyframeAnimation) {\n          blockKeyframeAnimations(node, !!duration);\n        }\n      }\n\n      function closeAndReturnNoopAnimator() {\n        runner = new $$AnimateRunner({\n          end: endFn,\n          cancel: cancelFn\n        });\n\n        // should flush the cache animation\n        waitUntilQuiet(noop);\n        close();\n\n        return {\n          $$willAnimate: false,\n          start: function() {\n            return runner;\n          },\n          end: endFn\n        };\n      }\n\n      function onAnimationProgress(event) {\n        event.stopPropagation();\n        var ev = event.originalEvent || event;\n\n        // we now always use `Date.now()` due to the recent changes with\n        // event.timeStamp in Firefox, Webkit and Chrome (see #13494 for more info)\n        var timeStamp = ev.$manualTimeStamp || Date.now();\n\n        /* Firefox (or possibly just Gecko) likes to not round values up\n         * when a ms measurement is used for the animation */\n        var elapsedTime = parseFloat(ev.elapsedTime.toFixed(ELAPSED_TIME_MAX_DECIMAL_PLACES));\n\n        /* $manualTimeStamp is a mocked timeStamp value which is set\n         * within browserTrigger(). This is only here so that tests can\n         * mock animations properly. Real events fallback to event.timeStamp,\n         * or, if they don't, then a timeStamp is automatically created for them.\n         * We're checking to see if the timeStamp surpasses the expected delay,\n         * but we're using elapsedTime instead of the timeStamp on the 2nd\n         * pre-condition since animationPauseds sometimes close off early */\n        if (Math.max(timeStamp - startTime, 0) >= maxDelayTime && elapsedTime >= maxDuration) {\n          // we set this flag to ensure that if the transition is paused then, when resumed,\n          // the animation will automatically close itself since transitions cannot be paused.\n          animationCompleted = true;\n          close();\n        }\n      }\n\n      function start() {\n        if (animationClosed) return;\n        if (!node.parentNode) {\n          close();\n          return;\n        }\n\n        // even though we only pause keyframe animations here the pause flag\n        // will still happen when transitions are used. Only the transition will\n        // not be paused since that is not possible. If the animation ends when\n        // paused then it will not complete until unpaused or cancelled.\n        var playPause = function(playAnimation) {\n          if (!animationCompleted) {\n            animationPaused = !playAnimation;\n            if (timings.animationDuration) {\n              var value = blockKeyframeAnimations(node, animationPaused);\n              animationPaused\n                  ? temporaryStyles.push(value)\n                  : removeFromArray(temporaryStyles, value);\n            }\n          } else if (animationPaused && playAnimation) {\n            animationPaused = false;\n            close();\n          }\n        };\n\n        // checking the stagger duration prevents an accidentally cascade of the CSS delay style\n        // being inherited from the parent. If the transition duration is zero then we can safely\n        // rely that the delay value is an intentional stagger delay style.\n        var maxStagger = itemIndex > 0\n                         && ((timings.transitionDuration && stagger.transitionDuration === 0) ||\n                            (timings.animationDuration && stagger.animationDuration === 0))\n                         && Math.max(stagger.animationDelay, stagger.transitionDelay);\n        if (maxStagger) {\n          $timeout(triggerAnimationStart,\n                   Math.floor(maxStagger * itemIndex * ONE_SECOND),\n                   false);\n        } else {\n          triggerAnimationStart();\n        }\n\n        // this will decorate the existing promise runner with pause/resume methods\n        runnerHost.resume = function() {\n          playPause(true);\n        };\n\n        runnerHost.pause = function() {\n          playPause(false);\n        };\n\n        function triggerAnimationStart() {\n          // just incase a stagger animation kicks in when the animation\n          // itself was cancelled entirely\n          if (animationClosed) return;\n\n          applyBlocking(false);\n\n          forEach(temporaryStyles, function(entry) {\n            var key = entry[0];\n            var value = entry[1];\n            node.style[key] = value;\n          });\n\n          applyAnimationClasses(element, options);\n          $$jqLite.addClass(element, activeClasses);\n\n          if (flags.recalculateTimingStyles) {\n            fullClassName = node.className + ' ' + preparationClasses;\n            cacheKey = gcsHashFn(node, fullClassName);\n\n            timings = computeTimings(node, fullClassName, cacheKey);\n            relativeDelay = timings.maxDelay;\n            maxDelay = Math.max(relativeDelay, 0);\n            maxDuration = timings.maxDuration;\n\n            if (maxDuration === 0) {\n              close();\n              return;\n            }\n\n            flags.hasTransitions = timings.transitionDuration > 0;\n            flags.hasAnimations = timings.animationDuration > 0;\n          }\n\n          if (flags.applyAnimationDelay) {\n            relativeDelay = typeof options.delay !== \"boolean\" && truthyTimingValue(options.delay)\n                  ? parseFloat(options.delay)\n                  : relativeDelay;\n\n            maxDelay = Math.max(relativeDelay, 0);\n            timings.animationDelay = relativeDelay;\n            delayStyle = getCssDelayStyle(relativeDelay, true);\n            temporaryStyles.push(delayStyle);\n            node.style[delayStyle[0]] = delayStyle[1];\n          }\n\n          maxDelayTime = maxDelay * ONE_SECOND;\n          maxDurationTime = maxDuration * ONE_SECOND;\n\n          if (options.easing) {\n            var easeProp, easeVal = options.easing;\n            if (flags.hasTransitions) {\n              easeProp = TRANSITION_PROP + TIMING_KEY;\n              temporaryStyles.push([easeProp, easeVal]);\n              node.style[easeProp] = easeVal;\n            }\n            if (flags.hasAnimations) {\n              easeProp = ANIMATION_PROP + TIMING_KEY;\n              temporaryStyles.push([easeProp, easeVal]);\n              node.style[easeProp] = easeVal;\n            }\n          }\n\n          if (timings.transitionDuration) {\n            events.push(TRANSITIONEND_EVENT);\n          }\n\n          if (timings.animationDuration) {\n            events.push(ANIMATIONEND_EVENT);\n          }\n\n          startTime = Date.now();\n          var timerTime = maxDelayTime + CLOSING_TIME_BUFFER * maxDurationTime;\n          var endTime = startTime + timerTime;\n\n          var animationsData = element.data(ANIMATE_TIMER_KEY) || [];\n          var setupFallbackTimer = true;\n          if (animationsData.length) {\n            var currentTimerData = animationsData[0];\n            setupFallbackTimer = endTime > currentTimerData.expectedEndTime;\n            if (setupFallbackTimer) {\n              $timeout.cancel(currentTimerData.timer);\n            } else {\n              animationsData.push(close);\n            }\n          }\n\n          if (setupFallbackTimer) {\n            var timer = $timeout(onAnimationExpired, timerTime, false);\n            animationsData[0] = {\n              timer: timer,\n              expectedEndTime: endTime\n            };\n            animationsData.push(close);\n            element.data(ANIMATE_TIMER_KEY, animationsData);\n          }\n\n          if (events.length) {\n            element.on(events.join(' '), onAnimationProgress);\n          }\n\n          if (options.to) {\n            if (options.cleanupStyles) {\n              registerRestorableStyles(restoreStyles, node, Object.keys(options.to));\n            }\n            applyAnimationToStyles(element, options);\n          }\n        }\n\n        function onAnimationExpired() {\n          var animationsData = element.data(ANIMATE_TIMER_KEY);\n\n          // this will be false in the event that the element was\n          // removed from the DOM (via a leave animation or something\n          // similar)\n          if (animationsData) {\n            for (var i = 1; i < animationsData.length; i++) {\n              animationsData[i]();\n            }\n            element.removeData(ANIMATE_TIMER_KEY);\n          }\n        }\n      }\n    };\n  }];\n}];\n\nvar $$AnimateCssDriverProvider = ['$$animationProvider', function($$animationProvider) {\n  $$animationProvider.drivers.push('$$animateCssDriver');\n\n  var NG_ANIMATE_SHIM_CLASS_NAME = 'ng-animate-shim';\n  var NG_ANIMATE_ANCHOR_CLASS_NAME = 'ng-anchor';\n\n  var NG_OUT_ANCHOR_CLASS_NAME = 'ng-anchor-out';\n  var NG_IN_ANCHOR_CLASS_NAME = 'ng-anchor-in';\n\n  function isDocumentFragment(node) {\n    return node.parentNode && node.parentNode.nodeType === 11;\n  }\n\n  this.$get = ['$animateCss', '$rootScope', '$$AnimateRunner', '$rootElement', '$sniffer', '$$jqLite', '$document',\n       function($animateCss,   $rootScope,   $$AnimateRunner,   $rootElement,   $sniffer,   $$jqLite,   $document) {\n\n    // only browsers that support these properties can render animations\n    if (!$sniffer.animations && !$sniffer.transitions) return noop;\n\n    var bodyNode = $document[0].body;\n    var rootNode = getDomNode($rootElement);\n\n    var rootBodyElement = jqLite(\n      // this is to avoid using something that exists outside of the body\n      // we also special case the doc fragment case because our unit test code\n      // appends the $rootElement to the body after the app has been bootstrapped\n      isDocumentFragment(rootNode) || bodyNode.contains(rootNode) ? rootNode : bodyNode\n    );\n\n    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);\n\n    return function initDriverFn(animationDetails) {\n      return animationDetails.from && animationDetails.to\n          ? prepareFromToAnchorAnimation(animationDetails.from,\n                                         animationDetails.to,\n                                         animationDetails.classes,\n                                         animationDetails.anchors)\n          : prepareRegularAnimation(animationDetails);\n    };\n\n    function filterCssClasses(classes) {\n      //remove all the `ng-` stuff\n      return classes.replace(/\\bng-\\S+\\b/g, '');\n    }\n\n    function getUniqueValues(a, b) {\n      if (isString(a)) a = a.split(' ');\n      if (isString(b)) b = b.split(' ');\n      return a.filter(function(val) {\n        return b.indexOf(val) === -1;\n      }).join(' ');\n    }\n\n    function prepareAnchoredAnimation(classes, outAnchor, inAnchor) {\n      var clone = jqLite(getDomNode(outAnchor).cloneNode(true));\n      var startingClasses = filterCssClasses(getClassVal(clone));\n\n      outAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME);\n      inAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME);\n\n      clone.addClass(NG_ANIMATE_ANCHOR_CLASS_NAME);\n\n      rootBodyElement.append(clone);\n\n      var animatorIn, animatorOut = prepareOutAnimation();\n\n      // the user may not end up using the `out` animation and\n      // only making use of the `in` animation or vice-versa.\n      // In either case we should allow this and not assume the\n      // animation is over unless both animations are not used.\n      if (!animatorOut) {\n        animatorIn = prepareInAnimation();\n        if (!animatorIn) {\n          return end();\n        }\n      }\n\n      var startingAnimator = animatorOut || animatorIn;\n\n      return {\n        start: function() {\n          var runner;\n\n          var currentAnimation = startingAnimator.start();\n          currentAnimation.done(function() {\n            currentAnimation = null;\n            if (!animatorIn) {\n              animatorIn = prepareInAnimation();\n              if (animatorIn) {\n                currentAnimation = animatorIn.start();\n                currentAnimation.done(function() {\n                  currentAnimation = null;\n                  end();\n                  runner.complete();\n                });\n                return currentAnimation;\n              }\n            }\n            // in the event that there is no `in` animation\n            end();\n            runner.complete();\n          });\n\n          runner = new $$AnimateRunner({\n            end: endFn,\n            cancel: endFn\n          });\n\n          return runner;\n\n          function endFn() {\n            if (currentAnimation) {\n              currentAnimation.end();\n            }\n          }\n        }\n      };\n\n      function calculateAnchorStyles(anchor) {\n        var styles = {};\n\n        var coords = getDomNode(anchor).getBoundingClientRect();\n\n        // we iterate directly since safari messes up and doesn't return\n        // all the keys for the coords object when iterated\n        forEach(['width','height','top','left'], function(key) {\n          var value = coords[key];\n          switch (key) {\n            case 'top':\n              value += bodyNode.scrollTop;\n              break;\n            case 'left':\n              value += bodyNode.scrollLeft;\n              break;\n          }\n          styles[key] = Math.floor(value) + 'px';\n        });\n        return styles;\n      }\n\n      function prepareOutAnimation() {\n        var animator = $animateCss(clone, {\n          addClass: NG_OUT_ANCHOR_CLASS_NAME,\n          delay: true,\n          from: calculateAnchorStyles(outAnchor)\n        });\n\n        // read the comment within `prepareRegularAnimation` to understand\n        // why this check is necessary\n        return animator.$$willAnimate ? animator : null;\n      }\n\n      function getClassVal(element) {\n        return element.attr('class') || '';\n      }\n\n      function prepareInAnimation() {\n        var endingClasses = filterCssClasses(getClassVal(inAnchor));\n        var toAdd = getUniqueValues(endingClasses, startingClasses);\n        var toRemove = getUniqueValues(startingClasses, endingClasses);\n\n        var animator = $animateCss(clone, {\n          to: calculateAnchorStyles(inAnchor),\n          addClass: NG_IN_ANCHOR_CLASS_NAME + ' ' + toAdd,\n          removeClass: NG_OUT_ANCHOR_CLASS_NAME + ' ' + toRemove,\n          delay: true\n        });\n\n        // read the comment within `prepareRegularAnimation` to understand\n        // why this check is necessary\n        return animator.$$willAnimate ? animator : null;\n      }\n\n      function end() {\n        clone.remove();\n        outAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME);\n        inAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME);\n      }\n    }\n\n    function prepareFromToAnchorAnimation(from, to, classes, anchors) {\n      var fromAnimation = prepareRegularAnimation(from, noop);\n      var toAnimation = prepareRegularAnimation(to, noop);\n\n      var anchorAnimations = [];\n      forEach(anchors, function(anchor) {\n        var outElement = anchor['out'];\n        var inElement = anchor['in'];\n        var animator = prepareAnchoredAnimation(classes, outElement, inElement);\n        if (animator) {\n          anchorAnimations.push(animator);\n        }\n      });\n\n      // no point in doing anything when there are no elements to animate\n      if (!fromAnimation && !toAnimation && anchorAnimations.length === 0) return;\n\n      return {\n        start: function() {\n          var animationRunners = [];\n\n          if (fromAnimation) {\n            animationRunners.push(fromAnimation.start());\n          }\n\n          if (toAnimation) {\n            animationRunners.push(toAnimation.start());\n          }\n\n          forEach(anchorAnimations, function(animation) {\n            animationRunners.push(animation.start());\n          });\n\n          var runner = new $$AnimateRunner({\n            end: endFn,\n            cancel: endFn // CSS-driven animations cannot be cancelled, only ended\n          });\n\n          $$AnimateRunner.all(animationRunners, function(status) {\n            runner.complete(status);\n          });\n\n          return runner;\n\n          function endFn() {\n            forEach(animationRunners, function(runner) {\n              runner.end();\n            });\n          }\n        }\n      };\n    }\n\n    function prepareRegularAnimation(animationDetails) {\n      var element = animationDetails.element;\n      var options = animationDetails.options || {};\n\n      if (animationDetails.structural) {\n        options.event = animationDetails.event;\n        options.structural = true;\n        options.applyClassesEarly = true;\n\n        // we special case the leave animation since we want to ensure that\n        // the element is removed as soon as the animation is over. Otherwise\n        // a flicker might appear or the element may not be removed at all\n        if (animationDetails.event === 'leave') {\n          options.onDone = options.domOperation;\n        }\n      }\n\n      // We assign the preparationClasses as the actual animation event since\n      // the internals of $animateCss will just suffix the event token values\n      // with `-active` to trigger the animation.\n      if (options.preparationClasses) {\n        options.event = concatWithSpace(options.event, options.preparationClasses);\n      }\n\n      var animator = $animateCss(element, options);\n\n      // the driver lookup code inside of $$animation attempts to spawn a\n      // driver one by one until a driver returns a.$$willAnimate animator object.\n      // $animateCss will always return an object, however, it will pass in\n      // a flag as a hint as to whether an animation was detected or not\n      return animator.$$willAnimate ? animator : null;\n    }\n  }];\n}];\n\n// TODO(matsko): use caching here to speed things up for detection\n// TODO(matsko): add documentation\n//  by the time...\n\nvar $$AnimateJsProvider = ['$animateProvider', function($animateProvider) {\n  this.$get = ['$injector', '$$AnimateRunner', '$$jqLite',\n       function($injector,   $$AnimateRunner,   $$jqLite) {\n\n    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);\n         // $animateJs(element, 'enter');\n    return function(element, event, classes, options) {\n      var animationClosed = false;\n\n      // the `classes` argument is optional and if it is not used\n      // then the classes will be resolved from the element's className\n      // property as well as options.addClass/options.removeClass.\n      if (arguments.length === 3 && isObject(classes)) {\n        options = classes;\n        classes = null;\n      }\n\n      options = prepareAnimationOptions(options);\n      if (!classes) {\n        classes = element.attr('class') || '';\n        if (options.addClass) {\n          classes += ' ' + options.addClass;\n        }\n        if (options.removeClass) {\n          classes += ' ' + options.removeClass;\n        }\n      }\n\n      var classesToAdd = options.addClass;\n      var classesToRemove = options.removeClass;\n\n      // the lookupAnimations function returns a series of animation objects that are\n      // matched up with one or more of the CSS classes. These animation objects are\n      // defined via the module.animation factory function. If nothing is detected then\n      // we don't return anything which then makes $animation query the next driver.\n      var animations = lookupAnimations(classes);\n      var before, after;\n      if (animations.length) {\n        var afterFn, beforeFn;\n        if (event == 'leave') {\n          beforeFn = 'leave';\n          afterFn = 'afterLeave'; // TODO(matsko): get rid of this\n        } else {\n          beforeFn = 'before' + event.charAt(0).toUpperCase() + event.substr(1);\n          afterFn = event;\n        }\n\n        if (event !== 'enter' && event !== 'move') {\n          before = packageAnimations(element, event, options, animations, beforeFn);\n        }\n        after  = packageAnimations(element, event, options, animations, afterFn);\n      }\n\n      // no matching animations\n      if (!before && !after) return;\n\n      function applyOptions() {\n        options.domOperation();\n        applyAnimationClasses(element, options);\n      }\n\n      function close() {\n        animationClosed = true;\n        applyOptions();\n        applyAnimationStyles(element, options);\n      }\n\n      var runner;\n\n      return {\n        $$willAnimate: true,\n        end: function() {\n          if (runner) {\n            runner.end();\n          } else {\n            close();\n            runner = new $$AnimateRunner();\n            runner.complete(true);\n          }\n          return runner;\n        },\n        start: function() {\n          if (runner) {\n            return runner;\n          }\n\n          runner = new $$AnimateRunner();\n          var closeActiveAnimations;\n          var chain = [];\n\n          if (before) {\n            chain.push(function(fn) {\n              closeActiveAnimations = before(fn);\n            });\n          }\n\n          if (chain.length) {\n            chain.push(function(fn) {\n              applyOptions();\n              fn(true);\n            });\n          } else {\n            applyOptions();\n          }\n\n          if (after) {\n            chain.push(function(fn) {\n              closeActiveAnimations = after(fn);\n            });\n          }\n\n          runner.setHost({\n            end: function() {\n              endAnimations();\n            },\n            cancel: function() {\n              endAnimations(true);\n            }\n          });\n\n          $$AnimateRunner.chain(chain, onComplete);\n          return runner;\n\n          function onComplete(success) {\n            close(success);\n            runner.complete(success);\n          }\n\n          function endAnimations(cancelled) {\n            if (!animationClosed) {\n              (closeActiveAnimations || noop)(cancelled);\n              onComplete(cancelled);\n            }\n          }\n        }\n      };\n\n      function executeAnimationFn(fn, element, event, options, onDone) {\n        var args;\n        switch (event) {\n          case 'animate':\n            args = [element, options.from, options.to, onDone];\n            break;\n\n          case 'setClass':\n            args = [element, classesToAdd, classesToRemove, onDone];\n            break;\n\n          case 'addClass':\n            args = [element, classesToAdd, onDone];\n            break;\n\n          case 'removeClass':\n            args = [element, classesToRemove, onDone];\n            break;\n\n          default:\n            args = [element, onDone];\n            break;\n        }\n\n        args.push(options);\n\n        var value = fn.apply(fn, args);\n        if (value) {\n          if (isFunction(value.start)) {\n            value = value.start();\n          }\n\n          if (value instanceof $$AnimateRunner) {\n            value.done(onDone);\n          } else if (isFunction(value)) {\n            // optional onEnd / onCancel callback\n            return value;\n          }\n        }\n\n        return noop;\n      }\n\n      function groupEventedAnimations(element, event, options, animations, fnName) {\n        var operations = [];\n        forEach(animations, function(ani) {\n          var animation = ani[fnName];\n          if (!animation) return;\n\n          // note that all of these animations will run in parallel\n          operations.push(function() {\n            var runner;\n            var endProgressCb;\n\n            var resolved = false;\n            var onAnimationComplete = function(rejected) {\n              if (!resolved) {\n                resolved = true;\n                (endProgressCb || noop)(rejected);\n                runner.complete(!rejected);\n              }\n            };\n\n            runner = new $$AnimateRunner({\n              end: function() {\n                onAnimationComplete();\n              },\n              cancel: function() {\n                onAnimationComplete(true);\n              }\n            });\n\n            endProgressCb = executeAnimationFn(animation, element, event, options, function(result) {\n              var cancelled = result === false;\n              onAnimationComplete(cancelled);\n            });\n\n            return runner;\n          });\n        });\n\n        return operations;\n      }\n\n      function packageAnimations(element, event, options, animations, fnName) {\n        var operations = groupEventedAnimations(element, event, options, animations, fnName);\n        if (operations.length === 0) {\n          var a,b;\n          if (fnName === 'beforeSetClass') {\n            a = groupEventedAnimations(element, 'removeClass', options, animations, 'beforeRemoveClass');\n            b = groupEventedAnimations(element, 'addClass', options, animations, 'beforeAddClass');\n          } else if (fnName === 'setClass') {\n            a = groupEventedAnimations(element, 'removeClass', options, animations, 'removeClass');\n            b = groupEventedAnimations(element, 'addClass', options, animations, 'addClass');\n          }\n\n          if (a) {\n            operations = operations.concat(a);\n          }\n          if (b) {\n            operations = operations.concat(b);\n          }\n        }\n\n        if (operations.length === 0) return;\n\n        // TODO(matsko): add documentation\n        return function startAnimation(callback) {\n          var runners = [];\n          if (operations.length) {\n            forEach(operations, function(animateFn) {\n              runners.push(animateFn());\n            });\n          }\n\n          runners.length ? $$AnimateRunner.all(runners, callback) : callback();\n\n          return function endFn(reject) {\n            forEach(runners, function(runner) {\n              reject ? runner.cancel() : runner.end();\n            });\n          };\n        };\n      }\n    };\n\n    function lookupAnimations(classes) {\n      classes = isArray(classes) ? classes : classes.split(' ');\n      var matches = [], flagMap = {};\n      for (var i=0; i < classes.length; i++) {\n        var klass = classes[i],\n            animationFactory = $animateProvider.$$registeredAnimations[klass];\n        if (animationFactory && !flagMap[klass]) {\n          matches.push($injector.get(animationFactory));\n          flagMap[klass] = true;\n        }\n      }\n      return matches;\n    }\n  }];\n}];\n\nvar $$AnimateJsDriverProvider = ['$$animationProvider', function($$animationProvider) {\n  $$animationProvider.drivers.push('$$animateJsDriver');\n  this.$get = ['$$animateJs', '$$AnimateRunner', function($$animateJs, $$AnimateRunner) {\n    return function initDriverFn(animationDetails) {\n      if (animationDetails.from && animationDetails.to) {\n        var fromAnimation = prepareAnimation(animationDetails.from);\n        var toAnimation = prepareAnimation(animationDetails.to);\n        if (!fromAnimation && !toAnimation) return;\n\n        return {\n          start: function() {\n            var animationRunners = [];\n\n            if (fromAnimation) {\n              animationRunners.push(fromAnimation.start());\n            }\n\n            if (toAnimation) {\n              animationRunners.push(toAnimation.start());\n            }\n\n            $$AnimateRunner.all(animationRunners, done);\n\n            var runner = new $$AnimateRunner({\n              end: endFnFactory(),\n              cancel: endFnFactory()\n            });\n\n            return runner;\n\n            function endFnFactory() {\n              return function() {\n                forEach(animationRunners, function(runner) {\n                  // at this point we cannot cancel animations for groups just yet. 1.5+\n                  runner.end();\n                });\n              };\n            }\n\n            function done(status) {\n              runner.complete(status);\n            }\n          }\n        };\n      } else {\n        return prepareAnimation(animationDetails);\n      }\n    };\n\n    function prepareAnimation(animationDetails) {\n      // TODO(matsko): make sure to check for grouped animations and delegate down to normal animations\n      var element = animationDetails.element;\n      var event = animationDetails.event;\n      var options = animationDetails.options;\n      var classes = animationDetails.classes;\n      return $$animateJs(element, event, classes, options);\n    }\n  }];\n}];\n\nvar NG_ANIMATE_ATTR_NAME = 'data-ng-animate';\nvar NG_ANIMATE_PIN_DATA = '$ngAnimatePin';\nvar $$AnimateQueueProvider = ['$animateProvider', function($animateProvider) {\n  var PRE_DIGEST_STATE = 1;\n  var RUNNING_STATE = 2;\n  var ONE_SPACE = ' ';\n\n  var rules = this.rules = {\n    skip: [],\n    cancel: [],\n    join: []\n  };\n\n  function makeTruthyCssClassMap(classString) {\n    if (!classString) {\n      return null;\n    }\n\n    var keys = classString.split(ONE_SPACE);\n    var map = Object.create(null);\n\n    forEach(keys, function(key) {\n      map[key] = true;\n    });\n    return map;\n  }\n\n  function hasMatchingClasses(newClassString, currentClassString) {\n    if (newClassString && currentClassString) {\n      var currentClassMap = makeTruthyCssClassMap(currentClassString);\n      return newClassString.split(ONE_SPACE).some(function(className) {\n        return currentClassMap[className];\n      });\n    }\n  }\n\n  function isAllowed(ruleType, element, currentAnimation, previousAnimation) {\n    return rules[ruleType].some(function(fn) {\n      return fn(element, currentAnimation, previousAnimation);\n    });\n  }\n\n  function hasAnimationClasses(animation, and) {\n    var a = (animation.addClass || '').length > 0;\n    var b = (animation.removeClass || '').length > 0;\n    return and ? a && b : a || b;\n  }\n\n  rules.join.push(function(element, newAnimation, currentAnimation) {\n    // if the new animation is class-based then we can just tack that on\n    return !newAnimation.structural && hasAnimationClasses(newAnimation);\n  });\n\n  rules.skip.push(function(element, newAnimation, currentAnimation) {\n    // there is no need to animate anything if no classes are being added and\n    // there is no structural animation that will be triggered\n    return !newAnimation.structural && !hasAnimationClasses(newAnimation);\n  });\n\n  rules.skip.push(function(element, newAnimation, currentAnimation) {\n    // why should we trigger a new structural animation if the element will\n    // be removed from the DOM anyway?\n    return currentAnimation.event == 'leave' && newAnimation.structural;\n  });\n\n  rules.skip.push(function(element, newAnimation, currentAnimation) {\n    // if there is an ongoing current animation then don't even bother running the class-based animation\n    return currentAnimation.structural && currentAnimation.state === RUNNING_STATE && !newAnimation.structural;\n  });\n\n  rules.cancel.push(function(element, newAnimation, currentAnimation) {\n    // there can never be two structural animations running at the same time\n    return currentAnimation.structural && newAnimation.structural;\n  });\n\n  rules.cancel.push(function(element, newAnimation, currentAnimation) {\n    // if the previous animation is already running, but the new animation will\n    // be triggered, but the new animation is structural\n    return currentAnimation.state === RUNNING_STATE && newAnimation.structural;\n  });\n\n  rules.cancel.push(function(element, newAnimation, currentAnimation) {\n    // cancel the animation if classes added / removed in both animation cancel each other out,\n    // but only if the current animation isn't structural\n\n    if (currentAnimation.structural) return false;\n\n    var nA = newAnimation.addClass;\n    var nR = newAnimation.removeClass;\n    var cA = currentAnimation.addClass;\n    var cR = currentAnimation.removeClass;\n\n    // early detection to save the global CPU shortage :)\n    if ((isUndefined(nA) && isUndefined(nR)) || (isUndefined(cA) && isUndefined(cR))) {\n      return false;\n    }\n\n    return hasMatchingClasses(nA, cR) || hasMatchingClasses(nR, cA);\n  });\n\n  this.$get = ['$$rAF', '$rootScope', '$rootElement', '$document', '$$HashMap',\n               '$$animation', '$$AnimateRunner', '$templateRequest', '$$jqLite', '$$forceReflow',\n       function($$rAF,   $rootScope,   $rootElement,   $document,   $$HashMap,\n                $$animation,   $$AnimateRunner,   $templateRequest,   $$jqLite,   $$forceReflow) {\n\n    var activeAnimationsLookup = new $$HashMap();\n    var disabledElementsLookup = new $$HashMap();\n    var animationsEnabled = null;\n\n    function postDigestTaskFactory() {\n      var postDigestCalled = false;\n      return function(fn) {\n        // we only issue a call to postDigest before\n        // it has first passed. This prevents any callbacks\n        // from not firing once the animation has completed\n        // since it will be out of the digest cycle.\n        if (postDigestCalled) {\n          fn();\n        } else {\n          $rootScope.$$postDigest(function() {\n            postDigestCalled = true;\n            fn();\n          });\n        }\n      };\n    }\n\n    // Wait until all directive and route-related templates are downloaded and\n    // compiled. The $templateRequest.totalPendingRequests variable keeps track of\n    // all of the remote templates being currently downloaded. If there are no\n    // templates currently downloading then the watcher will still fire anyway.\n    var deregisterWatch = $rootScope.$watch(\n      function() { return $templateRequest.totalPendingRequests === 0; },\n      function(isEmpty) {\n        if (!isEmpty) return;\n        deregisterWatch();\n\n        // Now that all templates have been downloaded, $animate will wait until\n        // the post digest queue is empty before enabling animations. By having two\n        // calls to $postDigest calls we can ensure that the flag is enabled at the\n        // very end of the post digest queue. Since all of the animations in $animate\n        // use $postDigest, it's important that the code below executes at the end.\n        // This basically means that the page is fully downloaded and compiled before\n        // any animations are triggered.\n        $rootScope.$$postDigest(function() {\n          $rootScope.$$postDigest(function() {\n            // we check for null directly in the event that the application already called\n            // .enabled() with whatever arguments that it provided it with\n            if (animationsEnabled === null) {\n              animationsEnabled = true;\n            }\n          });\n        });\n      }\n    );\n\n    var callbackRegistry = Object.create(null);\n\n    // remember that the classNameFilter is set during the provider/config\n    // stage therefore we can optimize here and setup a helper function\n    var classNameFilter = $animateProvider.classNameFilter();\n    var isAnimatableClassName = !classNameFilter\n              ? function() { return true; }\n              : function(className) {\n                return classNameFilter.test(className);\n              };\n\n    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);\n\n    function normalizeAnimationDetails(element, animation) {\n      return mergeAnimationDetails(element, animation, {});\n    }\n\n    // IE9-11 has no method \"contains\" in SVG element and in Node.prototype. Bug #10259.\n    var contains = window.Node.prototype.contains || function(arg) {\n      // jshint bitwise: false\n      return this === arg || !!(this.compareDocumentPosition(arg) & 16);\n      // jshint bitwise: true\n    };\n\n    function findCallbacks(parent, element, event) {\n      var targetNode = getDomNode(element);\n      var targetParentNode = getDomNode(parent);\n\n      var matches = [];\n      var entries = callbackRegistry[event];\n      if (entries) {\n        forEach(entries, function(entry) {\n          if (contains.call(entry.node, targetNode)) {\n            matches.push(entry.callback);\n          } else if (event === 'leave' && contains.call(entry.node, targetParentNode)) {\n            matches.push(entry.callback);\n          }\n        });\n      }\n\n      return matches;\n    }\n\n    function filterFromRegistry(list, matchContainer, matchCallback) {\n      var containerNode = extractElementNode(matchContainer);\n      return list.filter(function(entry) {\n        var isMatch = entry.node === containerNode &&\n                        (!matchCallback || entry.callback === matchCallback);\n        return !isMatch;\n      });\n    }\n\n    function cleanupEventListeners(phase, element) {\n      if (phase === 'close' && !element[0].parentNode) {\n        // If the element is not attached to a parentNode, it has been removed by\n        // the domOperation, and we can safely remove the event callbacks\n        $animate.off(element);\n      }\n    }\n\n    var $animate = {\n      on: function(event, container, callback) {\n        var node = extractElementNode(container);\n        callbackRegistry[event] = callbackRegistry[event] || [];\n        callbackRegistry[event].push({\n          node: node,\n          callback: callback\n        });\n\n        // Remove the callback when the element is removed from the DOM\n        jqLite(container).on('$destroy', function() {\n          var animationDetails = activeAnimationsLookup.get(node);\n\n          if (!animationDetails) {\n            // If there's an animation ongoing, the callback calling code will remove\n            // the event listeners. If we'd remove here, the callbacks would be removed\n            // before the animation ends\n            $animate.off(event, container, callback);\n          }\n        });\n      },\n\n      off: function(event, container, callback) {\n        if (arguments.length === 1 && !isString(arguments[0])) {\n          container = arguments[0];\n          for (var eventType in callbackRegistry) {\n            callbackRegistry[eventType] = filterFromRegistry(callbackRegistry[eventType], container);\n          }\n\n          return;\n        }\n\n        var entries = callbackRegistry[event];\n        if (!entries) return;\n\n        callbackRegistry[event] = arguments.length === 1\n            ? null\n            : filterFromRegistry(entries, container, callback);\n      },\n\n      pin: function(element, parentElement) {\n        assertArg(isElement(element), 'element', 'not an element');\n        assertArg(isElement(parentElement), 'parentElement', 'not an element');\n        element.data(NG_ANIMATE_PIN_DATA, parentElement);\n      },\n\n      push: function(element, event, options, domOperation) {\n        options = options || {};\n        options.domOperation = domOperation;\n        return queueAnimation(element, event, options);\n      },\n\n      // this method has four signatures:\n      //  () - global getter\n      //  (bool) - global setter\n      //  (element) - element getter\n      //  (element, bool) - element setter<F37>\n      enabled: function(element, bool) {\n        var argCount = arguments.length;\n\n        if (argCount === 0) {\n          // () - Global getter\n          bool = !!animationsEnabled;\n        } else {\n          var hasElement = isElement(element);\n\n          if (!hasElement) {\n            // (bool) - Global setter\n            bool = animationsEnabled = !!element;\n          } else {\n            var node = getDomNode(element);\n\n            if (argCount === 1) {\n              // (element) - Element getter\n              bool = !disabledElementsLookup.get(node);\n            } else {\n              // (element, bool) - Element setter\n              disabledElementsLookup.put(node, !bool);\n            }\n          }\n        }\n\n        return bool;\n      }\n    };\n\n    return $animate;\n\n    function queueAnimation(element, event, initialOptions) {\n      // we always make a copy of the options since\n      // there should never be any side effects on\n      // the input data when running `$animateCss`.\n      var options = copy(initialOptions);\n\n      var node, parent;\n      element = stripCommentsFromElement(element);\n      if (element) {\n        node = getDomNode(element);\n        parent = element.parent();\n      }\n\n      options = prepareAnimationOptions(options);\n\n      // we create a fake runner with a working promise.\n      // These methods will become available after the digest has passed\n      var runner = new $$AnimateRunner();\n\n      // this is used to trigger callbacks in postDigest mode\n      var runInNextPostDigestOrNow = postDigestTaskFactory();\n\n      if (isArray(options.addClass)) {\n        options.addClass = options.addClass.join(' ');\n      }\n\n      if (options.addClass && !isString(options.addClass)) {\n        options.addClass = null;\n      }\n\n      if (isArray(options.removeClass)) {\n        options.removeClass = options.removeClass.join(' ');\n      }\n\n      if (options.removeClass && !isString(options.removeClass)) {\n        options.removeClass = null;\n      }\n\n      if (options.from && !isObject(options.from)) {\n        options.from = null;\n      }\n\n      if (options.to && !isObject(options.to)) {\n        options.to = null;\n      }\n\n      // there are situations where a directive issues an animation for\n      // a jqLite wrapper that contains only comment nodes... If this\n      // happens then there is no way we can perform an animation\n      if (!node) {\n        close();\n        return runner;\n      }\n\n      var className = [node.className, options.addClass, options.removeClass].join(' ');\n      if (!isAnimatableClassName(className)) {\n        close();\n        return runner;\n      }\n\n      var isStructural = ['enter', 'move', 'leave'].indexOf(event) >= 0;\n\n      var documentHidden = $document[0].hidden;\n\n      // this is a hard disable of all animations for the application or on\n      // the element itself, therefore  there is no need to continue further\n      // past this point if not enabled\n      // Animations are also disabled if the document is currently hidden (page is not visible\n      // to the user), because browsers slow down or do not flush calls to requestAnimationFrame\n      var skipAnimations = !animationsEnabled || documentHidden || disabledElementsLookup.get(node);\n      var existingAnimation = (!skipAnimations && activeAnimationsLookup.get(node)) || {};\n      var hasExistingAnimation = !!existingAnimation.state;\n\n      // there is no point in traversing the same collection of parent ancestors if a followup\n      // animation will be run on the same element that already did all that checking work\n      if (!skipAnimations && (!hasExistingAnimation || existingAnimation.state != PRE_DIGEST_STATE)) {\n        skipAnimations = !areAnimationsAllowed(element, parent, event);\n      }\n\n      if (skipAnimations) {\n        // Callbacks should fire even if the document is hidden (regression fix for issue #14120)\n        if (documentHidden) notifyProgress(runner, event, 'start');\n        close();\n        if (documentHidden) notifyProgress(runner, event, 'close');\n        return runner;\n      }\n\n      if (isStructural) {\n        closeChildAnimations(element);\n      }\n\n      var newAnimation = {\n        structural: isStructural,\n        element: element,\n        event: event,\n        addClass: options.addClass,\n        removeClass: options.removeClass,\n        close: close,\n        options: options,\n        runner: runner\n      };\n\n      if (hasExistingAnimation) {\n        var skipAnimationFlag = isAllowed('skip', element, newAnimation, existingAnimation);\n        if (skipAnimationFlag) {\n          if (existingAnimation.state === RUNNING_STATE) {\n            close();\n            return runner;\n          } else {\n            mergeAnimationDetails(element, existingAnimation, newAnimation);\n            return existingAnimation.runner;\n          }\n        }\n        var cancelAnimationFlag = isAllowed('cancel', element, newAnimation, existingAnimation);\n        if (cancelAnimationFlag) {\n          if (existingAnimation.state === RUNNING_STATE) {\n            // this will end the animation right away and it is safe\n            // to do so since the animation is already running and the\n            // runner callback code will run in async\n            existingAnimation.runner.end();\n          } else if (existingAnimation.structural) {\n            // this means that the animation is queued into a digest, but\n            // hasn't started yet. Therefore it is safe to run the close\n            // method which will call the runner methods in async.\n            existingAnimation.close();\n          } else {\n            // this will merge the new animation options into existing animation options\n            mergeAnimationDetails(element, existingAnimation, newAnimation);\n\n            return existingAnimation.runner;\n          }\n        } else {\n          // a joined animation means that this animation will take over the existing one\n          // so an example would involve a leave animation taking over an enter. Then when\n          // the postDigest kicks in the enter will be ignored.\n          var joinAnimationFlag = isAllowed('join', element, newAnimation, existingAnimation);\n          if (joinAnimationFlag) {\n            if (existingAnimation.state === RUNNING_STATE) {\n              normalizeAnimationDetails(element, newAnimation);\n            } else {\n              applyGeneratedPreparationClasses(element, isStructural ? event : null, options);\n\n              event = newAnimation.event = existingAnimation.event;\n              options = mergeAnimationDetails(element, existingAnimation, newAnimation);\n\n              //we return the same runner since only the option values of this animation will\n              //be fed into the `existingAnimation`.\n              return existingAnimation.runner;\n            }\n          }\n        }\n      } else {\n        // normalization in this case means that it removes redundant CSS classes that\n        // already exist (addClass) or do not exist (removeClass) on the element\n        normalizeAnimationDetails(element, newAnimation);\n      }\n\n      // when the options are merged and cleaned up we may end up not having to do\n      // an animation at all, therefore we should check this before issuing a post\n      // digest callback. Structural animations will always run no matter what.\n      var isValidAnimation = newAnimation.structural;\n      if (!isValidAnimation) {\n        // animate (from/to) can be quickly checked first, otherwise we check if any classes are present\n        isValidAnimation = (newAnimation.event === 'animate' && Object.keys(newAnimation.options.to || {}).length > 0)\n                            || hasAnimationClasses(newAnimation);\n      }\n\n      if (!isValidAnimation) {\n        close();\n        clearElementAnimationState(element);\n        return runner;\n      }\n\n      // the counter keeps track of cancelled animations\n      var counter = (existingAnimation.counter || 0) + 1;\n      newAnimation.counter = counter;\n\n      markElementAnimationState(element, PRE_DIGEST_STATE, newAnimation);\n\n      $rootScope.$$postDigest(function() {\n        var animationDetails = activeAnimationsLookup.get(node);\n        var animationCancelled = !animationDetails;\n        animationDetails = animationDetails || {};\n\n        // if addClass/removeClass is called before something like enter then the\n        // registered parent element may not be present. The code below will ensure\n        // that a final value for parent element is obtained\n        var parentElement = element.parent() || [];\n\n        // animate/structural/class-based animations all have requirements. Otherwise there\n        // is no point in performing an animation. The parent node must also be set.\n        var isValidAnimation = parentElement.length > 0\n                                && (animationDetails.event === 'animate'\n                                    || animationDetails.structural\n                                    || hasAnimationClasses(animationDetails));\n\n        // this means that the previous animation was cancelled\n        // even if the follow-up animation is the same event\n        if (animationCancelled || animationDetails.counter !== counter || !isValidAnimation) {\n          // if another animation did not take over then we need\n          // to make sure that the domOperation and options are\n          // handled accordingly\n          if (animationCancelled) {\n            applyAnimationClasses(element, options);\n            applyAnimationStyles(element, options);\n          }\n\n          // if the event changed from something like enter to leave then we do\n          // it, otherwise if it's the same then the end result will be the same too\n          if (animationCancelled || (isStructural && animationDetails.event !== event)) {\n            options.domOperation();\n            runner.end();\n          }\n\n          // in the event that the element animation was not cancelled or a follow-up animation\n          // isn't allowed to animate from here then we need to clear the state of the element\n          // so that any future animations won't read the expired animation data.\n          if (!isValidAnimation) {\n            clearElementAnimationState(element);\n          }\n\n          return;\n        }\n\n        // this combined multiple class to addClass / removeClass into a setClass event\n        // so long as a structural event did not take over the animation\n        event = !animationDetails.structural && hasAnimationClasses(animationDetails, true)\n            ? 'setClass'\n            : animationDetails.event;\n\n        markElementAnimationState(element, RUNNING_STATE);\n        var realRunner = $$animation(element, event, animationDetails.options);\n\n        // this will update the runner's flow-control events based on\n        // the `realRunner` object.\n        runner.setHost(realRunner);\n        notifyProgress(runner, event, 'start', {});\n\n        realRunner.done(function(status) {\n          close(!status);\n          var animationDetails = activeAnimationsLookup.get(node);\n          if (animationDetails && animationDetails.counter === counter) {\n            clearElementAnimationState(getDomNode(element));\n          }\n          notifyProgress(runner, event, 'close', {});\n        });\n      });\n\n      return runner;\n\n      function notifyProgress(runner, event, phase, data) {\n        runInNextPostDigestOrNow(function() {\n          var callbacks = findCallbacks(parent, element, event);\n          if (callbacks.length) {\n            // do not optimize this call here to RAF because\n            // we don't know how heavy the callback code here will\n            // be and if this code is buffered then this can\n            // lead to a performance regression.\n            $$rAF(function() {\n              forEach(callbacks, function(callback) {\n                callback(element, phase, data);\n              });\n              cleanupEventListeners(phase, element);\n            });\n          } else {\n            cleanupEventListeners(phase, element);\n          }\n        });\n        runner.progress(event, phase, data);\n      }\n\n      function close(reject) { // jshint ignore:line\n        clearGeneratedClasses(element, options);\n        applyAnimationClasses(element, options);\n        applyAnimationStyles(element, options);\n        options.domOperation();\n        runner.complete(!reject);\n      }\n    }\n\n    function closeChildAnimations(element) {\n      var node = getDomNode(element);\n      var children = node.querySelectorAll('[' + NG_ANIMATE_ATTR_NAME + ']');\n      forEach(children, function(child) {\n        var state = parseInt(child.getAttribute(NG_ANIMATE_ATTR_NAME));\n        var animationDetails = activeAnimationsLookup.get(child);\n        if (animationDetails) {\n          switch (state) {\n            case RUNNING_STATE:\n              animationDetails.runner.end();\n              /* falls through */\n            case PRE_DIGEST_STATE:\n              activeAnimationsLookup.remove(child);\n              break;\n          }\n        }\n      });\n    }\n\n    function clearElementAnimationState(element) {\n      var node = getDomNode(element);\n      node.removeAttribute(NG_ANIMATE_ATTR_NAME);\n      activeAnimationsLookup.remove(node);\n    }\n\n    function isMatchingElement(nodeOrElmA, nodeOrElmB) {\n      return getDomNode(nodeOrElmA) === getDomNode(nodeOrElmB);\n    }\n\n    /**\n     * This fn returns false if any of the following is true:\n     * a) animations on any parent element are disabled, and animations on the element aren't explicitly allowed\n     * b) a parent element has an ongoing structural animation, and animateChildren is false\n     * c) the element is not a child of the body\n     * d) the element is not a child of the $rootElement\n     */\n    function areAnimationsAllowed(element, parentElement, event) {\n      var bodyElement = jqLite($document[0].body);\n      var bodyElementDetected = isMatchingElement(element, bodyElement) || element[0].nodeName === 'HTML';\n      var rootElementDetected = isMatchingElement(element, $rootElement);\n      var parentAnimationDetected = false;\n      var animateChildren;\n      var elementDisabled = disabledElementsLookup.get(getDomNode(element));\n\n      var parentHost = jqLite.data(element[0], NG_ANIMATE_PIN_DATA);\n      if (parentHost) {\n        parentElement = parentHost;\n      }\n\n      parentElement = getDomNode(parentElement);\n\n      while (parentElement) {\n        if (!rootElementDetected) {\n          // angular doesn't want to attempt to animate elements outside of the application\n          // therefore we need to ensure that the rootElement is an ancestor of the current element\n          rootElementDetected = isMatchingElement(parentElement, $rootElement);\n        }\n\n        if (parentElement.nodeType !== ELEMENT_NODE) {\n          // no point in inspecting the #document element\n          break;\n        }\n\n        var details = activeAnimationsLookup.get(parentElement) || {};\n        // either an enter, leave or move animation will commence\n        // therefore we can't allow any animations to take place\n        // but if a parent animation is class-based then that's ok\n        if (!parentAnimationDetected) {\n          var parentElementDisabled = disabledElementsLookup.get(parentElement);\n\n          if (parentElementDisabled === true && elementDisabled !== false) {\n            // disable animations if the user hasn't explicitly enabled animations on the\n            // current element\n            elementDisabled = true;\n            // element is disabled via parent element, no need to check anything else\n            break;\n          } else if (parentElementDisabled === false) {\n            elementDisabled = false;\n          }\n          parentAnimationDetected = details.structural;\n        }\n\n        if (isUndefined(animateChildren) || animateChildren === true) {\n          var value = jqLite.data(parentElement, NG_ANIMATE_CHILDREN_DATA);\n          if (isDefined(value)) {\n            animateChildren = value;\n          }\n        }\n\n        // there is no need to continue traversing at this point\n        if (parentAnimationDetected && animateChildren === false) break;\n\n        if (!bodyElementDetected) {\n          // we also need to ensure that the element is or will be a part of the body element\n          // otherwise it is pointless to even issue an animation to be rendered\n          bodyElementDetected = isMatchingElement(parentElement, bodyElement);\n        }\n\n        if (bodyElementDetected && rootElementDetected) {\n          // If both body and root have been found, any other checks are pointless,\n          // as no animation data should live outside the application\n          break;\n        }\n\n        if (!rootElementDetected) {\n          // If no rootElement is detected, check if the parentElement is pinned to another element\n          parentHost = jqLite.data(parentElement, NG_ANIMATE_PIN_DATA);\n          if (parentHost) {\n            // The pin target element becomes the next parent element\n            parentElement = getDomNode(parentHost);\n            continue;\n          }\n        }\n\n        parentElement = parentElement.parentNode;\n      }\n\n      var allowAnimation = (!parentAnimationDetected || animateChildren) && elementDisabled !== true;\n      return allowAnimation && rootElementDetected && bodyElementDetected;\n    }\n\n    function markElementAnimationState(element, state, details) {\n      details = details || {};\n      details.state = state;\n\n      var node = getDomNode(element);\n      node.setAttribute(NG_ANIMATE_ATTR_NAME, state);\n\n      var oldValue = activeAnimationsLookup.get(node);\n      var newValue = oldValue\n          ? extend(oldValue, details)\n          : details;\n      activeAnimationsLookup.put(node, newValue);\n    }\n  }];\n}];\n\nvar $$AnimationProvider = ['$animateProvider', function($animateProvider) {\n  var NG_ANIMATE_REF_ATTR = 'ng-animate-ref';\n\n  var drivers = this.drivers = [];\n\n  var RUNNER_STORAGE_KEY = '$$animationRunner';\n\n  function setRunner(element, runner) {\n    element.data(RUNNER_STORAGE_KEY, runner);\n  }\n\n  function removeRunner(element) {\n    element.removeData(RUNNER_STORAGE_KEY);\n  }\n\n  function getRunner(element) {\n    return element.data(RUNNER_STORAGE_KEY);\n  }\n\n  this.$get = ['$$jqLite', '$rootScope', '$injector', '$$AnimateRunner', '$$HashMap', '$$rAFScheduler',\n       function($$jqLite,   $rootScope,   $injector,   $$AnimateRunner,   $$HashMap,   $$rAFScheduler) {\n\n    var animationQueue = [];\n    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);\n\n    function sortAnimations(animations) {\n      var tree = { children: [] };\n      var i, lookup = new $$HashMap();\n\n      // this is done first beforehand so that the hashmap\n      // is filled with a list of the elements that will be animated\n      for (i = 0; i < animations.length; i++) {\n        var animation = animations[i];\n        lookup.put(animation.domNode, animations[i] = {\n          domNode: animation.domNode,\n          fn: animation.fn,\n          children: []\n        });\n      }\n\n      for (i = 0; i < animations.length; i++) {\n        processNode(animations[i]);\n      }\n\n      return flatten(tree);\n\n      function processNode(entry) {\n        if (entry.processed) return entry;\n        entry.processed = true;\n\n        var elementNode = entry.domNode;\n        var parentNode = elementNode.parentNode;\n        lookup.put(elementNode, entry);\n\n        var parentEntry;\n        while (parentNode) {\n          parentEntry = lookup.get(parentNode);\n          if (parentEntry) {\n            if (!parentEntry.processed) {\n              parentEntry = processNode(parentEntry);\n            }\n            break;\n          }\n          parentNode = parentNode.parentNode;\n        }\n\n        (parentEntry || tree).children.push(entry);\n        return entry;\n      }\n\n      function flatten(tree) {\n        var result = [];\n        var queue = [];\n        var i;\n\n        for (i = 0; i < tree.children.length; i++) {\n          queue.push(tree.children[i]);\n        }\n\n        var remainingLevelEntries = queue.length;\n        var nextLevelEntries = 0;\n        var row = [];\n\n        for (i = 0; i < queue.length; i++) {\n          var entry = queue[i];\n          if (remainingLevelEntries <= 0) {\n            remainingLevelEntries = nextLevelEntries;\n            nextLevelEntries = 0;\n            result.push(row);\n            row = [];\n          }\n          row.push(entry.fn);\n          entry.children.forEach(function(childEntry) {\n            nextLevelEntries++;\n            queue.push(childEntry);\n          });\n          remainingLevelEntries--;\n        }\n\n        if (row.length) {\n          result.push(row);\n        }\n\n        return result;\n      }\n    }\n\n    // TODO(matsko): document the signature in a better way\n    return function(element, event, options) {\n      options = prepareAnimationOptions(options);\n      var isStructural = ['enter', 'move', 'leave'].indexOf(event) >= 0;\n\n      // there is no animation at the current moment, however\n      // these runner methods will get later updated with the\n      // methods leading into the driver's end/cancel methods\n      // for now they just stop the animation from starting\n      var runner = new $$AnimateRunner({\n        end: function() { close(); },\n        cancel: function() { close(true); }\n      });\n\n      if (!drivers.length) {\n        close();\n        return runner;\n      }\n\n      setRunner(element, runner);\n\n      var classes = mergeClasses(element.attr('class'), mergeClasses(options.addClass, options.removeClass));\n      var tempClasses = options.tempClasses;\n      if (tempClasses) {\n        classes += ' ' + tempClasses;\n        options.tempClasses = null;\n      }\n\n      var prepareClassName;\n      if (isStructural) {\n        prepareClassName = 'ng-' + event + PREPARE_CLASS_SUFFIX;\n        $$jqLite.addClass(element, prepareClassName);\n      }\n\n      animationQueue.push({\n        // this data is used by the postDigest code and passed into\n        // the driver step function\n        element: element,\n        classes: classes,\n        event: event,\n        structural: isStructural,\n        options: options,\n        beforeStart: beforeStart,\n        close: close\n      });\n\n      element.on('$destroy', handleDestroyedElement);\n\n      // we only want there to be one function called within the post digest\n      // block. This way we can group animations for all the animations that\n      // were apart of the same postDigest flush call.\n      if (animationQueue.length > 1) return runner;\n\n      $rootScope.$$postDigest(function() {\n        var animations = [];\n        forEach(animationQueue, function(entry) {\n          // the element was destroyed early on which removed the runner\n          // form its storage. This means we can't animate this element\n          // at all and it already has been closed due to destruction.\n          if (getRunner(entry.element)) {\n            animations.push(entry);\n          } else {\n            entry.close();\n          }\n        });\n\n        // now any future animations will be in another postDigest\n        animationQueue.length = 0;\n\n        var groupedAnimations = groupAnimations(animations);\n        var toBeSortedAnimations = [];\n\n        forEach(groupedAnimations, function(animationEntry) {\n          toBeSortedAnimations.push({\n            domNode: getDomNode(animationEntry.from ? animationEntry.from.element : animationEntry.element),\n            fn: function triggerAnimationStart() {\n              // it's important that we apply the `ng-animate` CSS class and the\n              // temporary classes before we do any driver invoking since these\n              // CSS classes may be required for proper CSS detection.\n              animationEntry.beforeStart();\n\n              var startAnimationFn, closeFn = animationEntry.close;\n\n              // in the event that the element was removed before the digest runs or\n              // during the RAF sequencing then we should not trigger the animation.\n              var targetElement = animationEntry.anchors\n                  ? (animationEntry.from.element || animationEntry.to.element)\n                  : animationEntry.element;\n\n              if (getRunner(targetElement)) {\n                var operation = invokeFirstDriver(animationEntry);\n                if (operation) {\n                  startAnimationFn = operation.start;\n                }\n              }\n\n              if (!startAnimationFn) {\n                closeFn();\n              } else {\n                var animationRunner = startAnimationFn();\n                animationRunner.done(function(status) {\n                  closeFn(!status);\n                });\n                updateAnimationRunners(animationEntry, animationRunner);\n              }\n            }\n          });\n        });\n\n        // we need to sort each of the animations in order of parent to child\n        // relationships. This ensures that the child classes are applied at the\n        // right time.\n        $$rAFScheduler(sortAnimations(toBeSortedAnimations));\n      });\n\n      return runner;\n\n      // TODO(matsko): change to reference nodes\n      function getAnchorNodes(node) {\n        var SELECTOR = '[' + NG_ANIMATE_REF_ATTR + ']';\n        var items = node.hasAttribute(NG_ANIMATE_REF_ATTR)\n              ? [node]\n              : node.querySelectorAll(SELECTOR);\n        var anchors = [];\n        forEach(items, function(node) {\n          var attr = node.getAttribute(NG_ANIMATE_REF_ATTR);\n          if (attr && attr.length) {\n            anchors.push(node);\n          }\n        });\n        return anchors;\n      }\n\n      function groupAnimations(animations) {\n        var preparedAnimations = [];\n        var refLookup = {};\n        forEach(animations, function(animation, index) {\n          var element = animation.element;\n          var node = getDomNode(element);\n          var event = animation.event;\n          var enterOrMove = ['enter', 'move'].indexOf(event) >= 0;\n          var anchorNodes = animation.structural ? getAnchorNodes(node) : [];\n\n          if (anchorNodes.length) {\n            var direction = enterOrMove ? 'to' : 'from';\n\n            forEach(anchorNodes, function(anchor) {\n              var key = anchor.getAttribute(NG_ANIMATE_REF_ATTR);\n              refLookup[key] = refLookup[key] || {};\n              refLookup[key][direction] = {\n                animationID: index,\n                element: jqLite(anchor)\n              };\n            });\n          } else {\n            preparedAnimations.push(animation);\n          }\n        });\n\n        var usedIndicesLookup = {};\n        var anchorGroups = {};\n        forEach(refLookup, function(operations, key) {\n          var from = operations.from;\n          var to = operations.to;\n\n          if (!from || !to) {\n            // only one of these is set therefore we can't have an\n            // anchor animation since all three pieces are required\n            var index = from ? from.animationID : to.animationID;\n            var indexKey = index.toString();\n            if (!usedIndicesLookup[indexKey]) {\n              usedIndicesLookup[indexKey] = true;\n              preparedAnimations.push(animations[index]);\n            }\n            return;\n          }\n\n          var fromAnimation = animations[from.animationID];\n          var toAnimation = animations[to.animationID];\n          var lookupKey = from.animationID.toString();\n          if (!anchorGroups[lookupKey]) {\n            var group = anchorGroups[lookupKey] = {\n              structural: true,\n              beforeStart: function() {\n                fromAnimation.beforeStart();\n                toAnimation.beforeStart();\n              },\n              close: function() {\n                fromAnimation.close();\n                toAnimation.close();\n              },\n              classes: cssClassesIntersection(fromAnimation.classes, toAnimation.classes),\n              from: fromAnimation,\n              to: toAnimation,\n              anchors: [] // TODO(matsko): change to reference nodes\n            };\n\n            // the anchor animations require that the from and to elements both have at least\n            // one shared CSS class which effectively marries the two elements together to use\n            // the same animation driver and to properly sequence the anchor animation.\n            if (group.classes.length) {\n              preparedAnimations.push(group);\n            } else {\n              preparedAnimations.push(fromAnimation);\n              preparedAnimations.push(toAnimation);\n            }\n          }\n\n          anchorGroups[lookupKey].anchors.push({\n            'out': from.element, 'in': to.element\n          });\n        });\n\n        return preparedAnimations;\n      }\n\n      function cssClassesIntersection(a,b) {\n        a = a.split(' ');\n        b = b.split(' ');\n        var matches = [];\n\n        for (var i = 0; i < a.length; i++) {\n          var aa = a[i];\n          if (aa.substring(0,3) === 'ng-') continue;\n\n          for (var j = 0; j < b.length; j++) {\n            if (aa === b[j]) {\n              matches.push(aa);\n              break;\n            }\n          }\n        }\n\n        return matches.join(' ');\n      }\n\n      function invokeFirstDriver(animationDetails) {\n        // we loop in reverse order since the more general drivers (like CSS and JS)\n        // may attempt more elements, but custom drivers are more particular\n        for (var i = drivers.length - 1; i >= 0; i--) {\n          var driverName = drivers[i];\n          var factory = $injector.get(driverName);\n          var driver = factory(animationDetails);\n          if (driver) {\n            return driver;\n          }\n        }\n      }\n\n      function beforeStart() {\n        element.addClass(NG_ANIMATE_CLASSNAME);\n        if (tempClasses) {\n          $$jqLite.addClass(element, tempClasses);\n        }\n        if (prepareClassName) {\n          $$jqLite.removeClass(element, prepareClassName);\n          prepareClassName = null;\n        }\n      }\n\n      function updateAnimationRunners(animation, newRunner) {\n        if (animation.from && animation.to) {\n          update(animation.from.element);\n          update(animation.to.element);\n        } else {\n          update(animation.element);\n        }\n\n        function update(element) {\n          var runner = getRunner(element);\n          if (runner) runner.setHost(newRunner);\n        }\n      }\n\n      function handleDestroyedElement() {\n        var runner = getRunner(element);\n        if (runner && (event !== 'leave' || !options.$$domOperationFired)) {\n          runner.end();\n        }\n      }\n\n      function close(rejected) { // jshint ignore:line\n        element.off('$destroy', handleDestroyedElement);\n        removeRunner(element);\n\n        applyAnimationClasses(element, options);\n        applyAnimationStyles(element, options);\n        options.domOperation();\n\n        if (tempClasses) {\n          $$jqLite.removeClass(element, tempClasses);\n        }\n\n        element.removeClass(NG_ANIMATE_CLASSNAME);\n        runner.complete(!rejected);\n      }\n    };\n  }];\n}];\n\n/**\n * @ngdoc directive\n * @name ngAnimateSwap\n * @restrict A\n * @scope\n *\n * @description\n *\n * ngAnimateSwap is a animation-oriented directive that allows for the container to\n * be removed and entered in whenever the associated expression changes. A\n * common usecase for this directive is a rotating banner or slider component which\n * contains one image being present at a time. When the active image changes\n * then the old image will perform a `leave` animation and the new element\n * will be inserted via an `enter` animation.\n *\n * @animations\n * | Animation                        | Occurs                               |\n * |----------------------------------|--------------------------------------|\n * | {@link ng.$animate#enter enter}  | when the new element is inserted to the DOM  |\n * | {@link ng.$animate#leave leave}  | when the old element is removed from the DOM |\n *\n * @example\n * <example name=\"ngAnimateSwap-directive\" module=\"ngAnimateSwapExample\"\n *          deps=\"angular-animate.js\"\n *          animations=\"true\" fixBase=\"true\">\n *   <file name=\"index.html\">\n *     <div class=\"container\" ng-controller=\"AppCtrl\">\n *       <div ng-animate-swap=\"number\" class=\"cell swap-animation\" ng-class=\"colorClass(number)\">\n *         {{ number }}\n *       </div>\n *     </div>\n *   </file>\n *   <file name=\"script.js\">\n *     angular.module('ngAnimateSwapExample', ['ngAnimate'])\n *       .controller('AppCtrl', ['$scope', '$interval', function($scope, $interval) {\n *         $scope.number = 0;\n *         $interval(function() {\n *           $scope.number++;\n *         }, 1000);\n *\n *         var colors = ['red','blue','green','yellow','orange'];\n *         $scope.colorClass = function(number) {\n *           return colors[number % colors.length];\n *         };\n *       }]);\n *   </file>\n *  <file name=\"animations.css\">\n *  .container {\n *    height:250px;\n *    width:250px;\n *    position:relative;\n *    overflow:hidden;\n *    border:2px solid black;\n *  }\n *  .container .cell {\n *    font-size:150px;\n *    text-align:center;\n *    line-height:250px;\n *    position:absolute;\n *    top:0;\n *    left:0;\n *    right:0;\n *    border-bottom:2px solid black;\n *  }\n *  .swap-animation.ng-enter, .swap-animation.ng-leave {\n *    transition:0.5s linear all;\n *  }\n *  .swap-animation.ng-enter {\n *    top:-250px;\n *  }\n *  .swap-animation.ng-enter-active {\n *    top:0px;\n *  }\n *  .swap-animation.ng-leave {\n *    top:0px;\n *  }\n *  .swap-animation.ng-leave-active {\n *    top:250px;\n *  }\n *  .red { background:red; }\n *  .green { background:green; }\n *  .blue { background:blue; }\n *  .yellow { background:yellow; }\n *  .orange { background:orange; }\n *  </file>\n * </example>\n */\nvar ngAnimateSwapDirective = ['$animate', '$rootScope', function($animate, $rootScope) {\n  return {\n    restrict: 'A',\n    transclude: 'element',\n    terminal: true,\n    priority: 600, // we use 600 here to ensure that the directive is caught before others\n    link: function(scope, $element, attrs, ctrl, $transclude) {\n      var previousElement, previousScope;\n      scope.$watchCollection(attrs.ngAnimateSwap || attrs['for'], function(value) {\n        if (previousElement) {\n          $animate.leave(previousElement);\n        }\n        if (previousScope) {\n          previousScope.$destroy();\n          previousScope = null;\n        }\n        if (value || value === 0) {\n          previousScope = scope.$new();\n          $transclude(previousScope, function(element) {\n            previousElement = element;\n            $animate.enter(element, null, $element);\n          });\n        }\n      });\n    }\n  };\n}];\n\n/**\n * @ngdoc module\n * @name ngAnimate\n * @description\n *\n * The `ngAnimate` module provides support for CSS-based animations (keyframes and transitions) as well as JavaScript-based animations via\n * callback hooks. Animations are not enabled by default, however, by including `ngAnimate` the animation hooks are enabled for an Angular app.\n *\n * <div doc-module-components=\"ngAnimate\"></div>\n *\n * # Usage\n * Simply put, there are two ways to make use of animations when ngAnimate is used: by using **CSS** and **JavaScript**. The former works purely based\n * using CSS (by using matching CSS selectors/styles) and the latter triggers animations that are registered via `module.animation()`. For\n * both CSS and JS animations the sole requirement is to have a matching `CSS class` that exists both in the registered animation and within\n * the HTML element that the animation will be triggered on.\n *\n * ## Directive Support\n * The following directives are \"animation aware\":\n *\n * | Directive                                                                                                | Supported Animations                                                     |\n * |----------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------|\n * | {@link ng.directive:ngRepeat#animations ngRepeat}                                                        | enter, leave and move                                                    |\n * | {@link ngRoute.directive:ngView#animations ngView}                                                       | enter and leave                                                          |\n * | {@link ng.directive:ngInclude#animations ngInclude}                                                      | enter and leave                                                          |\n * | {@link ng.directive:ngSwitch#animations ngSwitch}                                                        | enter and leave                                                          |\n * | {@link ng.directive:ngIf#animations ngIf}                                                                | enter and leave                                                          |\n * | {@link ng.directive:ngClass#animations ngClass}                                                          | add and remove (the CSS class(es) present)                               |\n * | {@link ng.directive:ngShow#animations ngShow} & {@link ng.directive:ngHide#animations ngHide}            | add and remove (the ng-hide class value)                                 |\n * | {@link ng.directive:form#animation-hooks form} & {@link ng.directive:ngModel#animation-hooks ngModel}    | add and remove (dirty, pristine, valid, invalid & all other validations) |\n * | {@link module:ngMessages#animations ngMessages}                                                          | add and remove (ng-active & ng-inactive)                                 |\n * | {@link module:ngMessages#animations ngMessage}                                                           | enter and leave                                                          |\n *\n * (More information can be found by visiting each the documentation associated with each directive.)\n *\n * ## CSS-based Animations\n *\n * CSS-based animations with ngAnimate are unique since they require no JavaScript code at all. By using a CSS class that we reference between our HTML\n * and CSS code we can create an animation that will be picked up by Angular when an the underlying directive performs an operation.\n *\n * The example below shows how an `enter` animation can be made possible on an element using `ng-if`:\n *\n * ```html\n * <div ng-if=\"bool\" class=\"fade\">\n *    Fade me in out\n * </div>\n * <button ng-click=\"bool=true\">Fade In!</button>\n * <button ng-click=\"bool=false\">Fade Out!</button>\n * ```\n *\n * Notice the CSS class **fade**? We can now create the CSS transition code that references this class:\n *\n * ```css\n * /&#42; The starting CSS styles for the enter animation &#42;/\n * .fade.ng-enter {\n *   transition:0.5s linear all;\n *   opacity:0;\n * }\n *\n * /&#42; The finishing CSS styles for the enter animation &#42;/\n * .fade.ng-enter.ng-enter-active {\n *   opacity:1;\n * }\n * ```\n *\n * The key thing to remember here is that, depending on the animation event (which each of the directives above trigger depending on what's going on) two\n * generated CSS classes will be applied to the element; in the example above we have `.ng-enter` and `.ng-enter-active`. For CSS transitions, the transition\n * code **must** be defined within the starting CSS class (in this case `.ng-enter`). The destination class is what the transition will animate towards.\n *\n * If for example we wanted to create animations for `leave` and `move` (ngRepeat triggers move) then we can do so using the same CSS naming conventions:\n *\n * ```css\n * /&#42; now the element will fade out before it is removed from the DOM &#42;/\n * .fade.ng-leave {\n *   transition:0.5s linear all;\n *   opacity:1;\n * }\n * .fade.ng-leave.ng-leave-active {\n *   opacity:0;\n * }\n * ```\n *\n * We can also make use of **CSS Keyframes** by referencing the keyframe animation within the starting CSS class:\n *\n * ```css\n * /&#42; there is no need to define anything inside of the destination\n * CSS class since the keyframe will take charge of the animation &#42;/\n * .fade.ng-leave {\n *   animation: my_fade_animation 0.5s linear;\n *   -webkit-animation: my_fade_animation 0.5s linear;\n * }\n *\n * @keyframes my_fade_animation {\n *   from { opacity:1; }\n *   to { opacity:0; }\n * }\n *\n * @-webkit-keyframes my_fade_animation {\n *   from { opacity:1; }\n *   to { opacity:0; }\n * }\n * ```\n *\n * Feel free also mix transitions and keyframes together as well as any other CSS classes on the same element.\n *\n * ### CSS Class-based Animations\n *\n * Class-based animations (animations that are triggered via `ngClass`, `ngShow`, `ngHide` and some other directives) have a slightly different\n * naming convention. Class-based animations are basic enough that a standard transition or keyframe can be referenced on the class being added\n * and removed.\n *\n * For example if we wanted to do a CSS animation for `ngHide` then we place an animation on the `.ng-hide` CSS class:\n *\n * ```html\n * <div ng-show=\"bool\" class=\"fade\">\n *   Show and hide me\n * </div>\n * <button ng-click=\"bool=!bool\">Toggle</button>\n *\n * <style>\n * .fade.ng-hide {\n *   transition:0.5s linear all;\n *   opacity:0;\n * }\n * </style>\n * ```\n *\n * All that is going on here with ngShow/ngHide behind the scenes is the `.ng-hide` class is added/removed (when the hidden state is valid). Since\n * ngShow and ngHide are animation aware then we can match up a transition and ngAnimate handles the rest.\n *\n * In addition the addition and removal of the CSS class, ngAnimate also provides two helper methods that we can use to further decorate the animation\n * with CSS styles.\n *\n * ```html\n * <div ng-class=\"{on:onOff}\" class=\"highlight\">\n *   Highlight this box\n * </div>\n * <button ng-click=\"onOff=!onOff\">Toggle</button>\n *\n * <style>\n * .highlight {\n *   transition:0.5s linear all;\n * }\n * .highlight.on-add {\n *   background:white;\n * }\n * .highlight.on {\n *   background:yellow;\n * }\n * .highlight.on-remove {\n *   background:black;\n * }\n * </style>\n * ```\n *\n * We can also make use of CSS keyframes by placing them within the CSS classes.\n *\n *\n * ### CSS Staggering Animations\n * A Staggering animation is a collection of animations that are issued with a slight delay in between each successive operation resulting in a\n * curtain-like effect. The ngAnimate module (versions >=1.2) supports staggering animations and the stagger effect can be\n * performed by creating a **ng-EVENT-stagger** CSS class and attaching that class to the base CSS class used for\n * the animation. The style property expected within the stagger class can either be a **transition-delay** or an\n * **animation-delay** property (or both if your animation contains both transitions and keyframe animations).\n *\n * ```css\n * .my-animation.ng-enter {\n *   /&#42; standard transition code &#42;/\n *   transition: 1s linear all;\n *   opacity:0;\n * }\n * .my-animation.ng-enter-stagger {\n *   /&#42; this will have a 100ms delay between each successive leave animation &#42;/\n *   transition-delay: 0.1s;\n *\n *   /&#42; As of 1.4.4, this must always be set: it signals ngAnimate\n *     to not accidentally inherit a delay property from another CSS class &#42;/\n *   transition-duration: 0s;\n * }\n * .my-animation.ng-enter.ng-enter-active {\n *   /&#42; standard transition styles &#42;/\n *   opacity:1;\n * }\n * ```\n *\n * Staggering animations work by default in ngRepeat (so long as the CSS class is defined). Outside of ngRepeat, to use staggering animations\n * on your own, they can be triggered by firing multiple calls to the same event on $animate. However, the restrictions surrounding this\n * are that each of the elements must have the same CSS className value as well as the same parent element. A stagger operation\n * will also be reset if one or more animation frames have passed since the multiple calls to `$animate` were fired.\n *\n * The following code will issue the **ng-leave-stagger** event on the element provided:\n *\n * ```js\n * var kids = parent.children();\n *\n * $animate.leave(kids[0]); //stagger index=0\n * $animate.leave(kids[1]); //stagger index=1\n * $animate.leave(kids[2]); //stagger index=2\n * $animate.leave(kids[3]); //stagger index=3\n * $animate.leave(kids[4]); //stagger index=4\n *\n * window.requestAnimationFrame(function() {\n *   //stagger has reset itself\n *   $animate.leave(kids[5]); //stagger index=0\n *   $animate.leave(kids[6]); //stagger index=1\n *\n *   $scope.$digest();\n * });\n * ```\n *\n * Stagger animations are currently only supported within CSS-defined animations.\n *\n * ### The `ng-animate` CSS class\n *\n * When ngAnimate is animating an element it will apply the `ng-animate` CSS class to the element for the duration of the animation.\n * This is a temporary CSS class and it will be removed once the animation is over (for both JavaScript and CSS-based animations).\n *\n * Therefore, animations can be applied to an element using this temporary class directly via CSS.\n *\n * ```css\n * .zipper.ng-animate {\n *   transition:0.5s linear all;\n * }\n * .zipper.ng-enter {\n *   opacity:0;\n * }\n * .zipper.ng-enter.ng-enter-active {\n *   opacity:1;\n * }\n * .zipper.ng-leave {\n *   opacity:1;\n * }\n * .zipper.ng-leave.ng-leave-active {\n *   opacity:0;\n * }\n * ```\n *\n * (Note that the `ng-animate` CSS class is reserved and it cannot be applied on an element directly since ngAnimate will always remove\n * the CSS class once an animation has completed.)\n *\n *\n * ### The `ng-[event]-prepare` class\n *\n * This is a special class that can be used to prevent unwanted flickering / flash of content before\n * the actual animation starts. The class is added as soon as an animation is initialized, but removed\n * before the actual animation starts (after waiting for a $digest).\n * It is also only added for *structural* animations (`enter`, `move`, and `leave`).\n *\n * In practice, flickering can appear when nesting elements with structural animations such as `ngIf`\n * into elements that have class-based animations such as `ngClass`.\n *\n * ```html\n * <div ng-class=\"{red: myProp}\">\n *   <div ng-class=\"{blue: myProp}\">\n *     <div class=\"message\" ng-if=\"myProp\"></div>\n *   </div>\n * </div>\n * ```\n *\n * It is possible that during the `enter` animation, the `.message` div will be briefly visible before it starts animating.\n * In that case, you can add styles to the CSS that make sure the element stays hidden before the animation starts:\n *\n * ```css\n * .message.ng-enter-prepare {\n *   opacity: 0;\n * }\n *\n * ```\n *\n * ## JavaScript-based Animations\n *\n * ngAnimate also allows for animations to be consumed by JavaScript code. The approach is similar to CSS-based animations (where there is a shared\n * CSS class that is referenced in our HTML code) but in addition we need to register the JavaScript animation on the module. By making use of the\n * `module.animation()` module function we can register the animation.\n *\n * Let's see an example of a enter/leave animation using `ngRepeat`:\n *\n * ```html\n * <div ng-repeat=\"item in items\" class=\"slide\">\n *   {{ item }}\n * </div>\n * ```\n *\n * See the **slide** CSS class? Let's use that class to define an animation that we'll structure in our module code by using `module.animation`:\n *\n * ```js\n * myModule.animation('.slide', [function() {\n *   return {\n *     // make note that other events (like addClass/removeClass)\n *     // have different function input parameters\n *     enter: function(element, doneFn) {\n *       jQuery(element).fadeIn(1000, doneFn);\n *\n *       // remember to call doneFn so that angular\n *       // knows that the animation has concluded\n *     },\n *\n *     move: function(element, doneFn) {\n *       jQuery(element).fadeIn(1000, doneFn);\n *     },\n *\n *     leave: function(element, doneFn) {\n *       jQuery(element).fadeOut(1000, doneFn);\n *     }\n *   }\n * }]);\n * ```\n *\n * The nice thing about JS-based animations is that we can inject other services and make use of advanced animation libraries such as\n * greensock.js and velocity.js.\n *\n * If our animation code class-based (meaning that something like `ngClass`, `ngHide` and `ngShow` triggers it) then we can still define\n * our animations inside of the same registered animation, however, the function input arguments are a bit different:\n *\n * ```html\n * <div ng-class=\"color\" class=\"colorful\">\n *   this box is moody\n * </div>\n * <button ng-click=\"color='red'\">Change to red</button>\n * <button ng-click=\"color='blue'\">Change to blue</button>\n * <button ng-click=\"color='green'\">Change to green</button>\n * ```\n *\n * ```js\n * myModule.animation('.colorful', [function() {\n *   return {\n *     addClass: function(element, className, doneFn) {\n *       // do some cool animation and call the doneFn\n *     },\n *     removeClass: function(element, className, doneFn) {\n *       // do some cool animation and call the doneFn\n *     },\n *     setClass: function(element, addedClass, removedClass, doneFn) {\n *       // do some cool animation and call the doneFn\n *     }\n *   }\n * }]);\n * ```\n *\n * ## CSS + JS Animations Together\n *\n * AngularJS 1.4 and higher has taken steps to make the amalgamation of CSS and JS animations more flexible. However, unlike earlier versions of Angular,\n * defining CSS and JS animations to work off of the same CSS class will not work anymore. Therefore the example below will only result in **JS animations taking\n * charge of the animation**:\n *\n * ```html\n * <div ng-if=\"bool\" class=\"slide\">\n *   Slide in and out\n * </div>\n * ```\n *\n * ```js\n * myModule.animation('.slide', [function() {\n *   return {\n *     enter: function(element, doneFn) {\n *       jQuery(element).slideIn(1000, doneFn);\n *     }\n *   }\n * }]);\n * ```\n *\n * ```css\n * .slide.ng-enter {\n *   transition:0.5s linear all;\n *   transform:translateY(-100px);\n * }\n * .slide.ng-enter.ng-enter-active {\n *   transform:translateY(0);\n * }\n * ```\n *\n * Does this mean that CSS and JS animations cannot be used together? Do JS-based animations always have higher priority? We can make up for the\n * lack of CSS animations by using the `$animateCss` service to trigger our own tweaked-out, CSS-based animations directly from\n * our own JS-based animation code:\n *\n * ```js\n * myModule.animation('.slide', ['$animateCss', function($animateCss) {\n *   return {\n *     enter: function(element) {\n*        // this will trigger `.slide.ng-enter` and `.slide.ng-enter-active`.\n *       return $animateCss(element, {\n *         event: 'enter',\n *         structural: true\n *       });\n *     }\n *   }\n * }]);\n * ```\n *\n * The nice thing here is that we can save bandwidth by sticking to our CSS-based animation code and we don't need to rely on a 3rd-party animation framework.\n *\n * The `$animateCss` service is very powerful since we can feed in all kinds of extra properties that will be evaluated and fed into a CSS transition or\n * keyframe animation. For example if we wanted to animate the height of an element while adding and removing classes then we can do so by providing that\n * data into `$animateCss` directly:\n *\n * ```js\n * myModule.animation('.slide', ['$animateCss', function($animateCss) {\n *   return {\n *     enter: function(element) {\n *       return $animateCss(element, {\n *         event: 'enter',\n *         structural: true,\n *         addClass: 'maroon-setting',\n *         from: { height:0 },\n *         to: { height: 200 }\n *       });\n *     }\n *   }\n * }]);\n * ```\n *\n * Now we can fill in the rest via our transition CSS code:\n *\n * ```css\n * /&#42; the transition tells ngAnimate to make the animation happen &#42;/\n * .slide.ng-enter { transition:0.5s linear all; }\n *\n * /&#42; this extra CSS class will be absorbed into the transition\n * since the $animateCss code is adding the class &#42;/\n * .maroon-setting { background:red; }\n * ```\n *\n * And `$animateCss` will figure out the rest. Just make sure to have the `done()` callback fire the `doneFn` function to signal when the animation is over.\n *\n * To learn more about what's possible be sure to visit the {@link ngAnimate.$animateCss $animateCss service}.\n *\n * ## Animation Anchoring (via `ng-animate-ref`)\n *\n * ngAnimate in AngularJS 1.4 comes packed with the ability to cross-animate elements between\n * structural areas of an application (like views) by pairing up elements using an attribute\n * called `ng-animate-ref`.\n *\n * Let's say for example we have two views that are managed by `ng-view` and we want to show\n * that there is a relationship between two components situated in within these views. By using the\n * `ng-animate-ref` attribute we can identify that the two components are paired together and we\n * can then attach an animation, which is triggered when the view changes.\n *\n * Say for example we have the following template code:\n *\n * ```html\n * <!-- index.html -->\n * <div ng-view class=\"view-animation\">\n * </div>\n *\n * <!-- home.html -->\n * <a href=\"#/banner-page\">\n *   <img src=\"./banner.jpg\" class=\"banner\" ng-animate-ref=\"banner\">\n * </a>\n *\n * <!-- banner-page.html -->\n * <img src=\"./banner.jpg\" class=\"banner\" ng-animate-ref=\"banner\">\n * ```\n *\n * Now, when the view changes (once the link is clicked), ngAnimate will examine the\n * HTML contents to see if there is a match reference between any components in the view\n * that is leaving and the view that is entering. It will scan both the view which is being\n * removed (leave) and inserted (enter) to see if there are any paired DOM elements that\n * contain a matching ref value.\n *\n * The two images match since they share the same ref value. ngAnimate will now create a\n * transport element (which is a clone of the first image element) and it will then attempt\n * to animate to the position of the second image element in the next view. For the animation to\n * work a special CSS class called `ng-anchor` will be added to the transported element.\n *\n * We can now attach a transition onto the `.banner.ng-anchor` CSS class and then\n * ngAnimate will handle the entire transition for us as well as the addition and removal of\n * any changes of CSS classes between the elements:\n *\n * ```css\n * .banner.ng-anchor {\n *   /&#42; this animation will last for 1 second since there are\n *          two phases to the animation (an `in` and an `out` phase) &#42;/\n *   transition:0.5s linear all;\n * }\n * ```\n *\n * We also **must** include animations for the views that are being entered and removed\n * (otherwise anchoring wouldn't be possible since the new view would be inserted right away).\n *\n * ```css\n * .view-animation.ng-enter, .view-animation.ng-leave {\n *   transition:0.5s linear all;\n *   position:fixed;\n *   left:0;\n *   top:0;\n *   width:100%;\n * }\n * .view-animation.ng-enter {\n *   transform:translateX(100%);\n * }\n * .view-animation.ng-leave,\n * .view-animation.ng-enter.ng-enter-active {\n *   transform:translateX(0%);\n * }\n * .view-animation.ng-leave.ng-leave-active {\n *   transform:translateX(-100%);\n * }\n * ```\n *\n * Now we can jump back to the anchor animation. When the animation happens, there are two stages that occur:\n * an `out` and an `in` stage. The `out` stage happens first and that is when the element is animated away\n * from its origin. Once that animation is over then the `in` stage occurs which animates the\n * element to its destination. The reason why there are two animations is to give enough time\n * for the enter animation on the new element to be ready.\n *\n * The example above sets up a transition for both the in and out phases, but we can also target the out or\n * in phases directly via `ng-anchor-out` and `ng-anchor-in`.\n *\n * ```css\n * .banner.ng-anchor-out {\n *   transition: 0.5s linear all;\n *\n *   /&#42; the scale will be applied during the out animation,\n *          but will be animated away when the in animation runs &#42;/\n *   transform: scale(1.2);\n * }\n *\n * .banner.ng-anchor-in {\n *   transition: 1s linear all;\n * }\n * ```\n *\n *\n *\n *\n * ### Anchoring Demo\n *\n  <example module=\"anchoringExample\"\n           name=\"anchoringExample\"\n           id=\"anchoringExample\"\n           deps=\"angular-animate.js;angular-route.js\"\n           animations=\"true\">\n    <file name=\"index.html\">\n      <a href=\"#/\">Home</a>\n      <hr />\n      <div class=\"view-container\">\n        <div ng-view class=\"view\"></div>\n      </div>\n    </file>\n    <file name=\"script.js\">\n      angular.module('anchoringExample', ['ngAnimate', 'ngRoute'])\n        .config(['$routeProvider', function($routeProvider) {\n          $routeProvider.when('/', {\n            templateUrl: 'home.html',\n            controller: 'HomeController as home'\n          });\n          $routeProvider.when('/profile/:id', {\n            templateUrl: 'profile.html',\n            controller: 'ProfileController as profile'\n          });\n        }])\n        .run(['$rootScope', function($rootScope) {\n          $rootScope.records = [\n            { id:1, title: \"Miss Beulah Roob\" },\n            { id:2, title: \"Trent Morissette\" },\n            { id:3, title: \"Miss Ava Pouros\" },\n            { id:4, title: \"Rod Pouros\" },\n            { id:5, title: \"Abdul Rice\" },\n            { id:6, title: \"Laurie Rutherford Sr.\" },\n            { id:7, title: \"Nakia McLaughlin\" },\n            { id:8, title: \"Jordon Blanda DVM\" },\n            { id:9, title: \"Rhoda Hand\" },\n            { id:10, title: \"Alexandrea Sauer\" }\n          ];\n        }])\n        .controller('HomeController', [function() {\n          //empty\n        }])\n        .controller('ProfileController', ['$rootScope', '$routeParams', function($rootScope, $routeParams) {\n          var index = parseInt($routeParams.id, 10);\n          var record = $rootScope.records[index - 1];\n\n          this.title = record.title;\n          this.id = record.id;\n        }]);\n    </file>\n    <file name=\"home.html\">\n      <h2>Welcome to the home page</h1>\n      <p>Please click on an element</p>\n      <a class=\"record\"\n         ng-href=\"#/profile/{{ record.id }}\"\n         ng-animate-ref=\"{{ record.id }}\"\n         ng-repeat=\"record in records\">\n        {{ record.title }}\n      </a>\n    </file>\n    <file name=\"profile.html\">\n      <div class=\"profile record\" ng-animate-ref=\"{{ profile.id }}\">\n        {{ profile.title }}\n      </div>\n    </file>\n    <file name=\"animations.css\">\n      .record {\n        display:block;\n        font-size:20px;\n      }\n      .profile {\n        background:black;\n        color:white;\n        font-size:100px;\n      }\n      .view-container {\n        position:relative;\n      }\n      .view-container > .view.ng-animate {\n        position:absolute;\n        top:0;\n        left:0;\n        width:100%;\n        min-height:500px;\n      }\n      .view.ng-enter, .view.ng-leave,\n      .record.ng-anchor {\n        transition:0.5s linear all;\n      }\n      .view.ng-enter {\n        transform:translateX(100%);\n      }\n      .view.ng-enter.ng-enter-active, .view.ng-leave {\n        transform:translateX(0%);\n      }\n      .view.ng-leave.ng-leave-active {\n        transform:translateX(-100%);\n      }\n      .record.ng-anchor-out {\n        background:red;\n      }\n    </file>\n  </example>\n *\n * ### How is the element transported?\n *\n * When an anchor animation occurs, ngAnimate will clone the starting element and position it exactly where the starting\n * element is located on screen via absolute positioning. The cloned element will be placed inside of the root element\n * of the application (where ng-app was defined) and all of the CSS classes of the starting element will be applied. The\n * element will then animate into the `out` and `in` animations and will eventually reach the coordinates and match\n * the dimensions of the destination element. During the entire animation a CSS class of `.ng-animate-shim` will be applied\n * to both the starting and destination elements in order to hide them from being visible (the CSS styling for the class\n * is: `visibility:hidden`). Once the anchor reaches its destination then it will be removed and the destination element\n * will become visible since the shim class will be removed.\n *\n * ### How is the morphing handled?\n *\n * CSS Anchoring relies on transitions and keyframes and the internal code is intelligent enough to figure out\n * what CSS classes differ between the starting element and the destination element. These different CSS classes\n * will be added/removed on the anchor element and a transition will be applied (the transition that is provided\n * in the anchor class). Long story short, ngAnimate will figure out what classes to add and remove which will\n * make the transition of the element as smooth and automatic as possible. Be sure to use simple CSS classes that\n * do not rely on DOM nesting structure so that the anchor element appears the same as the starting element (since\n * the cloned element is placed inside of root element which is likely close to the body element).\n *\n * Note that if the root element is on the `<html>` element then the cloned node will be placed inside of body.\n *\n *\n * ## Using $animate in your directive code\n *\n * So far we've explored how to feed in animations into an Angular application, but how do we trigger animations within our own directives in our application?\n * By injecting the `$animate` service into our directive code, we can trigger structural and class-based hooks which can then be consumed by animations. Let's\n * imagine we have a greeting box that shows and hides itself when the data changes\n *\n * ```html\n * <greeting-box active=\"onOrOff\">Hi there</greeting-box>\n * ```\n *\n * ```js\n * ngModule.directive('greetingBox', ['$animate', function($animate) {\n *   return function(scope, element, attrs) {\n *     attrs.$observe('active', function(value) {\n *       value ? $animate.addClass(element, 'on') : $animate.removeClass(element, 'on');\n *     });\n *   });\n * }]);\n * ```\n *\n * Now the `on` CSS class is added and removed on the greeting box component. Now if we add a CSS class on top of the greeting box element\n * in our HTML code then we can trigger a CSS or JS animation to happen.\n *\n * ```css\n * /&#42; normally we would create a CSS class to reference on the element &#42;/\n * greeting-box.on { transition:0.5s linear all; background:green; color:white; }\n * ```\n *\n * The `$animate` service contains a variety of other methods like `enter`, `leave`, `animate` and `setClass`. To learn more about what's\n * possible be sure to visit the {@link ng.$animate $animate service API page}.\n *\n *\n * ## Callbacks and Promises\n *\n * When `$animate` is called it returns a promise that can be used to capture when the animation has ended. Therefore if we were to trigger\n * an animation (within our directive code) then we can continue performing directive and scope related activities after the animation has\n * ended by chaining onto the returned promise that animation method returns.\n *\n * ```js\n * // somewhere within the depths of the directive\n * $animate.enter(element, parent).then(function() {\n *   //the animation has completed\n * });\n * ```\n *\n * (Note that earlier versions of Angular prior to v1.4 required the promise code to be wrapped using `$scope.$apply(...)`. This is not the case\n * anymore.)\n *\n * In addition to the animation promise, we can also make use of animation-related callbacks within our directives and controller code by registering\n * an event listener using the `$animate` service. Let's say for example that an animation was triggered on our view\n * routing controller to hook into that:\n *\n * ```js\n * ngModule.controller('HomePageController', ['$animate', function($animate) {\n *   $animate.on('enter', ngViewElement, function(element) {\n *     // the animation for this route has completed\n *   }]);\n * }])\n * ```\n *\n * (Note that you will need to trigger a digest within the callback to get angular to notice any scope-related changes.)\n */\n\nvar copy;\nvar extend;\nvar forEach;\nvar isArray;\nvar isDefined;\nvar isElement;\nvar isFunction;\nvar isObject;\nvar isString;\nvar isUndefined;\nvar jqLite;\nvar noop;\n\n/**\n * @ngdoc service\n * @name $animate\n * @kind object\n *\n * @description\n * The ngAnimate `$animate` service documentation is the same for the core `$animate` service.\n *\n * Click here {@link ng.$animate to learn more about animations with `$animate`}.\n */\nangular.module('ngAnimate', [], function initAngularHelpers() {\n  // Access helpers from angular core.\n  // Do it inside a `config` block to ensure `window.angular` is available.\n  noop        = angular.noop;\n  copy        = angular.copy;\n  extend      = angular.extend;\n  jqLite      = angular.element;\n  forEach     = angular.forEach;\n  isArray     = angular.isArray;\n  isString    = angular.isString;\n  isObject    = angular.isObject;\n  isUndefined = angular.isUndefined;\n  isDefined   = angular.isDefined;\n  isFunction  = angular.isFunction;\n  isElement   = angular.isElement;\n})\n  .directive('ngAnimateSwap', ngAnimateSwapDirective)\n\n  .directive('ngAnimateChildren', $$AnimateChildrenDirective)\n  .factory('$$rAFScheduler', $$rAFSchedulerFactory)\n\n  .provider('$$animateQueue', $$AnimateQueueProvider)\n  .provider('$$animation', $$AnimationProvider)\n\n  .provider('$animateCss', $AnimateCssProvider)\n  .provider('$$animateCssDriver', $$AnimateCssDriverProvider)\n\n  .provider('$$animateJs', $$AnimateJsProvider)\n  .provider('$$animateJsDriver', $$AnimateJsDriverProvider);\n\n\n})(window, window.angular);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/angular-animate/angular-animate.js\n// module id = 6\n// module chunks = 0","require('./angular-sanitize');\nmodule.exports = 'ngSanitize';\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/angular-sanitize/index.js\n// module id = 7\n// module chunks = 0","/**\n * @license AngularJS v1.5.8\n * (c) 2010-2016 Google, Inc. http://angularjs.org\n * License: MIT\n */\n(function(window, angular) {'use strict';\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *     Any commits to this file should be reviewed with security in mind.  *\n *   Changes to this file can potentially create security vulnerabilities. *\n *          An approval from 2 Core members with history of modifying      *\n *                         this file is required.                          *\n *                                                                         *\n *  Does the change somehow allow for arbitrary javascript to be executed? *\n *    Or allows for someone to change the prototype of built-in objects?   *\n *     Or gives undesired access to variables likes document or window?    *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\nvar $sanitizeMinErr = angular.$$minErr('$sanitize');\nvar bind;\nvar extend;\nvar forEach;\nvar isDefined;\nvar lowercase;\nvar noop;\nvar htmlParser;\nvar htmlSanitizeWriter;\n\n/**\n * @ngdoc module\n * @name ngSanitize\n * @description\n *\n * # ngSanitize\n *\n * The `ngSanitize` module provides functionality to sanitize HTML.\n *\n *\n * <div doc-module-components=\"ngSanitize\"></div>\n *\n * See {@link ngSanitize.$sanitize `$sanitize`} for usage.\n */\n\n/**\n * @ngdoc service\n * @name $sanitize\n * @kind function\n *\n * @description\n *   Sanitizes an html string by stripping all potentially dangerous tokens.\n *\n *   The input is sanitized by parsing the HTML into tokens. All safe tokens (from a whitelist) are\n *   then serialized back to properly escaped html string. This means that no unsafe input can make\n *   it into the returned string.\n *\n *   The whitelist for URL sanitization of attribute values is configured using the functions\n *   `aHrefSanitizationWhitelist` and `imgSrcSanitizationWhitelist` of {@link ng.$compileProvider\n *   `$compileProvider`}.\n *\n *   The input may also contain SVG markup if this is enabled via {@link $sanitizeProvider}.\n *\n * @param {string} html HTML input.\n * @returns {string} Sanitized HTML.\n *\n * @example\n   <example module=\"sanitizeExample\" deps=\"angular-sanitize.js\">\n   <file name=\"index.html\">\n     <script>\n         angular.module('sanitizeExample', ['ngSanitize'])\n           .controller('ExampleController', ['$scope', '$sce', function($scope, $sce) {\n             $scope.snippet =\n               '<p style=\"color:blue\">an html\\n' +\n               '<em onmouseover=\"this.textContent=\\'PWN3D!\\'\">click here</em>\\n' +\n               'snippet</p>';\n             $scope.deliberatelyTrustDangerousSnippet = function() {\n               return $sce.trustAsHtml($scope.snippet);\n             };\n           }]);\n     </script>\n     <div ng-controller=\"ExampleController\">\n        Snippet: <textarea ng-model=\"snippet\" cols=\"60\" rows=\"3\"></textarea>\n       <table>\n         <tr>\n           <td>Directive</td>\n           <td>How</td>\n           <td>Source</td>\n           <td>Rendered</td>\n         </tr>\n         <tr id=\"bind-html-with-sanitize\">\n           <td>ng-bind-html</td>\n           <td>Automatically uses $sanitize</td>\n           <td><pre>&lt;div ng-bind-html=\"snippet\"&gt;<br/>&lt;/div&gt;</pre></td>\n           <td><div ng-bind-html=\"snippet\"></div></td>\n         </tr>\n         <tr id=\"bind-html-with-trust\">\n           <td>ng-bind-html</td>\n           <td>Bypass $sanitize by explicitly trusting the dangerous value</td>\n           <td>\n           <pre>&lt;div ng-bind-html=\"deliberatelyTrustDangerousSnippet()\"&gt;\n&lt;/div&gt;</pre>\n           </td>\n           <td><div ng-bind-html=\"deliberatelyTrustDangerousSnippet()\"></div></td>\n         </tr>\n         <tr id=\"bind-default\">\n           <td>ng-bind</td>\n           <td>Automatically escapes</td>\n           <td><pre>&lt;div ng-bind=\"snippet\"&gt;<br/>&lt;/div&gt;</pre></td>\n           <td><div ng-bind=\"snippet\"></div></td>\n         </tr>\n       </table>\n       </div>\n   </file>\n   <file name=\"protractor.js\" type=\"protractor\">\n     it('should sanitize the html snippet by default', function() {\n       expect(element(by.css('#bind-html-with-sanitize div')).getInnerHtml()).\n         toBe('<p>an html\\n<em>click here</em>\\nsnippet</p>');\n     });\n\n     it('should inline raw snippet if bound to a trusted value', function() {\n       expect(element(by.css('#bind-html-with-trust div')).getInnerHtml()).\n         toBe(\"<p style=\\\"color:blue\\\">an html\\n\" +\n              \"<em onmouseover=\\\"this.textContent='PWN3D!'\\\">click here</em>\\n\" +\n              \"snippet</p>\");\n     });\n\n     it('should escape snippet without any filter', function() {\n       expect(element(by.css('#bind-default div')).getInnerHtml()).\n         toBe(\"&lt;p style=\\\"color:blue\\\"&gt;an html\\n\" +\n              \"&lt;em onmouseover=\\\"this.textContent='PWN3D!'\\\"&gt;click here&lt;/em&gt;\\n\" +\n              \"snippet&lt;/p&gt;\");\n     });\n\n     it('should update', function() {\n       element(by.model('snippet')).clear();\n       element(by.model('snippet')).sendKeys('new <b onclick=\"alert(1)\">text</b>');\n       expect(element(by.css('#bind-html-with-sanitize div')).getInnerHtml()).\n         toBe('new <b>text</b>');\n       expect(element(by.css('#bind-html-with-trust div')).getInnerHtml()).toBe(\n         'new <b onclick=\"alert(1)\">text</b>');\n       expect(element(by.css('#bind-default div')).getInnerHtml()).toBe(\n         \"new &lt;b onclick=\\\"alert(1)\\\"&gt;text&lt;/b&gt;\");\n     });\n   </file>\n   </example>\n */\n\n\n/**\n * @ngdoc provider\n * @name $sanitizeProvider\n *\n * @description\n * Creates and configures {@link $sanitize} instance.\n */\nfunction $SanitizeProvider() {\n  var svgEnabled = false;\n\n  this.$get = ['$$sanitizeUri', function($$sanitizeUri) {\n    if (svgEnabled) {\n      extend(validElements, svgElements);\n    }\n    return function(html) {\n      var buf = [];\n      htmlParser(html, htmlSanitizeWriter(buf, function(uri, isImage) {\n        return !/^unsafe:/.test($$sanitizeUri(uri, isImage));\n      }));\n      return buf.join('');\n    };\n  }];\n\n\n  /**\n   * @ngdoc method\n   * @name $sanitizeProvider#enableSvg\n   * @kind function\n   *\n   * @description\n   * Enables a subset of svg to be supported by the sanitizer.\n   *\n   * <div class=\"alert alert-warning\">\n   *   <p>By enabling this setting without taking other precautions, you might expose your\n   *   application to click-hijacking attacks. In these attacks, sanitized svg elements could be positioned\n   *   outside of the containing element and be rendered over other elements on the page (e.g. a login\n   *   link). Such behavior can then result in phishing incidents.</p>\n   *\n   *   <p>To protect against these, explicitly setup `overflow: hidden` css rule for all potential svg\n   *   tags within the sanitized content:</p>\n   *\n   *   <br>\n   *\n   *   <pre><code>\n   *   .rootOfTheIncludedContent svg {\n   *     overflow: hidden !important;\n   *   }\n   *   </code></pre>\n   * </div>\n   *\n   * @param {boolean=} flag Enable or disable SVG support in the sanitizer.\n   * @returns {boolean|ng.$sanitizeProvider} Returns the currently configured value if called\n   *    without an argument or self for chaining otherwise.\n   */\n  this.enableSvg = function(enableSvg) {\n    if (isDefined(enableSvg)) {\n      svgEnabled = enableSvg;\n      return this;\n    } else {\n      return svgEnabled;\n    }\n  };\n\n  //////////////////////////////////////////////////////////////////////////////////////////////////\n  // Private stuff\n  //////////////////////////////////////////////////////////////////////////////////////////////////\n\n  bind = angular.bind;\n  extend = angular.extend;\n  forEach = angular.forEach;\n  isDefined = angular.isDefined;\n  lowercase = angular.lowercase;\n  noop = angular.noop;\n\n  htmlParser = htmlParserImpl;\n  htmlSanitizeWriter = htmlSanitizeWriterImpl;\n\n  // Regular Expressions for parsing tags and attributes\n  var SURROGATE_PAIR_REGEXP = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g,\n    // Match everything outside of normal chars and \" (quote character)\n    NON_ALPHANUMERIC_REGEXP = /([^\\#-~ |!])/g;\n\n\n  // Good source of info about elements and attributes\n  // http://dev.w3.org/html5/spec/Overview.html#semantics\n  // http://simon.html5.org/html-elements\n\n  // Safe Void Elements - HTML5\n  // http://dev.w3.org/html5/spec/Overview.html#void-elements\n  var voidElements = toMap(\"area,br,col,hr,img,wbr\");\n\n  // Elements that you can, intentionally, leave open (and which close themselves)\n  // http://dev.w3.org/html5/spec/Overview.html#optional-tags\n  var optionalEndTagBlockElements = toMap(\"colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr\"),\n      optionalEndTagInlineElements = toMap(\"rp,rt\"),\n      optionalEndTagElements = extend({},\n                                              optionalEndTagInlineElements,\n                                              optionalEndTagBlockElements);\n\n  // Safe Block Elements - HTML5\n  var blockElements = extend({}, optionalEndTagBlockElements, toMap(\"address,article,\" +\n          \"aside,blockquote,caption,center,del,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,\" +\n          \"h6,header,hgroup,hr,ins,map,menu,nav,ol,pre,section,table,ul\"));\n\n  // Inline Elements - HTML5\n  var inlineElements = extend({}, optionalEndTagInlineElements, toMap(\"a,abbr,acronym,b,\" +\n          \"bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,q,ruby,rp,rt,s,\" +\n          \"samp,small,span,strike,strong,sub,sup,time,tt,u,var\"));\n\n  // SVG Elements\n  // https://wiki.whatwg.org/wiki/Sanitization_rules#svg_Elements\n  // Note: the elements animate,animateColor,animateMotion,animateTransform,set are intentionally omitted.\n  // They can potentially allow for arbitrary javascript to be executed. See #11290\n  var svgElements = toMap(\"circle,defs,desc,ellipse,font-face,font-face-name,font-face-src,g,glyph,\" +\n          \"hkern,image,linearGradient,line,marker,metadata,missing-glyph,mpath,path,polygon,polyline,\" +\n          \"radialGradient,rect,stop,svg,switch,text,title,tspan\");\n\n  // Blocked Elements (will be stripped)\n  var blockedElements = toMap(\"script,style\");\n\n  var validElements = extend({},\n                                     voidElements,\n                                     blockElements,\n                                     inlineElements,\n                                     optionalEndTagElements);\n\n  //Attributes that have href and hence need to be sanitized\n  var uriAttrs = toMap(\"background,cite,href,longdesc,src,xlink:href\");\n\n  var htmlAttrs = toMap('abbr,align,alt,axis,bgcolor,border,cellpadding,cellspacing,class,clear,' +\n      'color,cols,colspan,compact,coords,dir,face,headers,height,hreflang,hspace,' +\n      'ismap,lang,language,nohref,nowrap,rel,rev,rows,rowspan,rules,' +\n      'scope,scrolling,shape,size,span,start,summary,tabindex,target,title,type,' +\n      'valign,value,vspace,width');\n\n  // SVG attributes (without \"id\" and \"name\" attributes)\n  // https://wiki.whatwg.org/wiki/Sanitization_rules#svg_Attributes\n  var svgAttrs = toMap('accent-height,accumulate,additive,alphabetic,arabic-form,ascent,' +\n      'baseProfile,bbox,begin,by,calcMode,cap-height,class,color,color-rendering,content,' +\n      'cx,cy,d,dx,dy,descent,display,dur,end,fill,fill-rule,font-family,font-size,font-stretch,' +\n      'font-style,font-variant,font-weight,from,fx,fy,g1,g2,glyph-name,gradientUnits,hanging,' +\n      'height,horiz-adv-x,horiz-origin-x,ideographic,k,keyPoints,keySplines,keyTimes,lang,' +\n      'marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mathematical,' +\n      'max,min,offset,opacity,orient,origin,overline-position,overline-thickness,panose-1,' +\n      'path,pathLength,points,preserveAspectRatio,r,refX,refY,repeatCount,repeatDur,' +\n      'requiredExtensions,requiredFeatures,restart,rotate,rx,ry,slope,stemh,stemv,stop-color,' +\n      'stop-opacity,strikethrough-position,strikethrough-thickness,stroke,stroke-dasharray,' +\n      'stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,' +\n      'stroke-width,systemLanguage,target,text-anchor,to,transform,type,u1,u2,underline-position,' +\n      'underline-thickness,unicode,unicode-range,units-per-em,values,version,viewBox,visibility,' +\n      'width,widths,x,x-height,x1,x2,xlink:actuate,xlink:arcrole,xlink:role,xlink:show,xlink:title,' +\n      'xlink:type,xml:base,xml:lang,xml:space,xmlns,xmlns:xlink,y,y1,y2,zoomAndPan', true);\n\n  var validAttrs = extend({},\n                                  uriAttrs,\n                                  svgAttrs,\n                                  htmlAttrs);\n\n  function toMap(str, lowercaseKeys) {\n    var obj = {}, items = str.split(','), i;\n    for (i = 0; i < items.length; i++) {\n      obj[lowercaseKeys ? lowercase(items[i]) : items[i]] = true;\n    }\n    return obj;\n  }\n\n  var inertBodyElement;\n  (function(window) {\n    var doc;\n    if (window.document && window.document.implementation) {\n      doc = window.document.implementation.createHTMLDocument(\"inert\");\n    } else {\n      throw $sanitizeMinErr('noinert', \"Can't create an inert html document\");\n    }\n    var docElement = doc.documentElement || doc.getDocumentElement();\n    var bodyElements = docElement.getElementsByTagName('body');\n\n    // usually there should be only one body element in the document, but IE doesn't have any, so we need to create one\n    if (bodyElements.length === 1) {\n      inertBodyElement = bodyElements[0];\n    } else {\n      var html = doc.createElement('html');\n      inertBodyElement = doc.createElement('body');\n      html.appendChild(inertBodyElement);\n      doc.appendChild(html);\n    }\n  })(window);\n\n  /**\n   * @example\n   * htmlParser(htmlString, {\n   *     start: function(tag, attrs) {},\n   *     end: function(tag) {},\n   *     chars: function(text) {},\n   *     comment: function(text) {}\n   * });\n   *\n   * @param {string} html string\n   * @param {object} handler\n   */\n  function htmlParserImpl(html, handler) {\n    if (html === null || html === undefined) {\n      html = '';\n    } else if (typeof html !== 'string') {\n      html = '' + html;\n    }\n    inertBodyElement.innerHTML = html;\n\n    //mXSS protection\n    var mXSSAttempts = 5;\n    do {\n      if (mXSSAttempts === 0) {\n        throw $sanitizeMinErr('uinput', \"Failed to sanitize html because the input is unstable\");\n      }\n      mXSSAttempts--;\n\n      // strip custom-namespaced attributes on IE<=11\n      if (window.document.documentMode) {\n        stripCustomNsAttrs(inertBodyElement);\n      }\n      html = inertBodyElement.innerHTML; //trigger mXSS\n      inertBodyElement.innerHTML = html;\n    } while (html !== inertBodyElement.innerHTML);\n\n    var node = inertBodyElement.firstChild;\n    while (node) {\n      switch (node.nodeType) {\n        case 1: // ELEMENT_NODE\n          handler.start(node.nodeName.toLowerCase(), attrToMap(node.attributes));\n          break;\n        case 3: // TEXT NODE\n          handler.chars(node.textContent);\n          break;\n      }\n\n      var nextNode;\n      if (!(nextNode = node.firstChild)) {\n      if (node.nodeType == 1) {\n          handler.end(node.nodeName.toLowerCase());\n        }\n        nextNode = node.nextSibling;\n        if (!nextNode) {\n          while (nextNode == null) {\n            node = node.parentNode;\n            if (node === inertBodyElement) break;\n            nextNode = node.nextSibling;\n          if (node.nodeType == 1) {\n              handler.end(node.nodeName.toLowerCase());\n            }\n          }\n        }\n      }\n      node = nextNode;\n    }\n\n    while (node = inertBodyElement.firstChild) {\n      inertBodyElement.removeChild(node);\n    }\n  }\n\n  function attrToMap(attrs) {\n    var map = {};\n    for (var i = 0, ii = attrs.length; i < ii; i++) {\n      var attr = attrs[i];\n      map[attr.name] = attr.value;\n    }\n    return map;\n  }\n\n\n  /**\n   * Escapes all potentially dangerous characters, so that the\n   * resulting string can be safely inserted into attribute or\n   * element text.\n   * @param value\n   * @returns {string} escaped text\n   */\n  function encodeEntities(value) {\n    return value.\n      replace(/&/g, '&amp;').\n      replace(SURROGATE_PAIR_REGEXP, function(value) {\n        var hi = value.charCodeAt(0);\n        var low = value.charCodeAt(1);\n        return '&#' + (((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000) + ';';\n      }).\n      replace(NON_ALPHANUMERIC_REGEXP, function(value) {\n        return '&#' + value.charCodeAt(0) + ';';\n      }).\n      replace(/</g, '&lt;').\n      replace(/>/g, '&gt;');\n  }\n\n  /**\n   * create an HTML/XML writer which writes to buffer\n   * @param {Array} buf use buf.join('') to get out sanitized html string\n   * @returns {object} in the form of {\n   *     start: function(tag, attrs) {},\n   *     end: function(tag) {},\n   *     chars: function(text) {},\n   *     comment: function(text) {}\n   * }\n   */\n  function htmlSanitizeWriterImpl(buf, uriValidator) {\n    var ignoreCurrentElement = false;\n    var out = bind(buf, buf.push);\n    return {\n      start: function(tag, attrs) {\n        tag = lowercase(tag);\n        if (!ignoreCurrentElement && blockedElements[tag]) {\n          ignoreCurrentElement = tag;\n        }\n        if (!ignoreCurrentElement && validElements[tag] === true) {\n          out('<');\n          out(tag);\n          forEach(attrs, function(value, key) {\n            var lkey = lowercase(key);\n            var isImage = (tag === 'img' && lkey === 'src') || (lkey === 'background');\n            if (validAttrs[lkey] === true &&\n              (uriAttrs[lkey] !== true || uriValidator(value, isImage))) {\n              out(' ');\n              out(key);\n              out('=\"');\n              out(encodeEntities(value));\n              out('\"');\n            }\n          });\n          out('>');\n        }\n      },\n      end: function(tag) {\n        tag = lowercase(tag);\n        if (!ignoreCurrentElement && validElements[tag] === true && voidElements[tag] !== true) {\n          out('</');\n          out(tag);\n          out('>');\n        }\n        if (tag == ignoreCurrentElement) {\n          ignoreCurrentElement = false;\n        }\n      },\n      chars: function(chars) {\n        if (!ignoreCurrentElement) {\n          out(encodeEntities(chars));\n        }\n      }\n    };\n  }\n\n\n  /**\n   * When IE9-11 comes across an unknown namespaced attribute e.g. 'xlink:foo' it adds 'xmlns:ns1' attribute to declare\n   * ns1 namespace and prefixes the attribute with 'ns1' (e.g. 'ns1:xlink:foo'). This is undesirable since we don't want\n   * to allow any of these custom attributes. This method strips them all.\n   *\n   * @param node Root element to process\n   */\n  function stripCustomNsAttrs(node) {\n    if (node.nodeType === window.Node.ELEMENT_NODE) {\n      var attrs = node.attributes;\n      for (var i = 0, l = attrs.length; i < l; i++) {\n        var attrNode = attrs[i];\n        var attrName = attrNode.name.toLowerCase();\n        if (attrName === 'xmlns:ns1' || attrName.lastIndexOf('ns1:', 0) === 0) {\n          node.removeAttributeNode(attrNode);\n          i--;\n          l--;\n        }\n      }\n    }\n\n    var nextNode = node.firstChild;\n    if (nextNode) {\n      stripCustomNsAttrs(nextNode);\n    }\n\n    nextNode = node.nextSibling;\n    if (nextNode) {\n      stripCustomNsAttrs(nextNode);\n    }\n  }\n}\n\nfunction sanitizeText(chars) {\n  var buf = [];\n  var writer = htmlSanitizeWriter(buf, noop);\n  writer.chars(chars);\n  return buf.join('');\n}\n\n\n// define ngSanitize module and register $sanitize service\nangular.module('ngSanitize', []).provider('$sanitize', $SanitizeProvider);\n\n/**\n * @ngdoc filter\n * @name linky\n * @kind function\n *\n * @description\n * Finds links in text input and turns them into html links. Supports `http/https/ftp/mailto` and\n * plain email address links.\n *\n * Requires the {@link ngSanitize `ngSanitize`} module to be installed.\n *\n * @param {string} text Input text.\n * @param {string} target Window (`_blank|_self|_parent|_top`) or named frame to open links in.\n * @param {object|function(url)} [attributes] Add custom attributes to the link element.\n *\n *    Can be one of:\n *\n *    - `object`: A map of attributes\n *    - `function`: Takes the url as a parameter and returns a map of attributes\n *\n *    If the map of attributes contains a value for `target`, it overrides the value of\n *    the target parameter.\n *\n *\n * @returns {string} Html-linkified and {@link $sanitize sanitized} text.\n *\n * @usage\n   <span ng-bind-html=\"linky_expression | linky\"></span>\n *\n * @example\n   <example module=\"linkyExample\" deps=\"angular-sanitize.js\">\n     <file name=\"index.html\">\n       <div ng-controller=\"ExampleController\">\n       Snippet: <textarea ng-model=\"snippet\" cols=\"60\" rows=\"3\"></textarea>\n       <table>\n         <tr>\n           <th>Filter</th>\n           <th>Source</th>\n           <th>Rendered</th>\n         </tr>\n         <tr id=\"linky-filter\">\n           <td>linky filter</td>\n           <td>\n             <pre>&lt;div ng-bind-html=\"snippet | linky\"&gt;<br>&lt;/div&gt;</pre>\n           </td>\n           <td>\n             <div ng-bind-html=\"snippet | linky\"></div>\n           </td>\n         </tr>\n         <tr id=\"linky-target\">\n          <td>linky target</td>\n          <td>\n            <pre>&lt;div ng-bind-html=\"snippetWithSingleURL | linky:'_blank'\"&gt;<br>&lt;/div&gt;</pre>\n          </td>\n          <td>\n            <div ng-bind-html=\"snippetWithSingleURL | linky:'_blank'\"></div>\n          </td>\n         </tr>\n         <tr id=\"linky-custom-attributes\">\n          <td>linky custom attributes</td>\n          <td>\n            <pre>&lt;div ng-bind-html=\"snippetWithSingleURL | linky:'_self':{rel: 'nofollow'}\"&gt;<br>&lt;/div&gt;</pre>\n          </td>\n          <td>\n            <div ng-bind-html=\"snippetWithSingleURL | linky:'_self':{rel: 'nofollow'}\"></div>\n          </td>\n         </tr>\n         <tr id=\"escaped-html\">\n           <td>no filter</td>\n           <td><pre>&lt;div ng-bind=\"snippet\"&gt;<br>&lt;/div&gt;</pre></td>\n           <td><div ng-bind=\"snippet\"></div></td>\n         </tr>\n       </table>\n     </file>\n     <file name=\"script.js\">\n       angular.module('linkyExample', ['ngSanitize'])\n         .controller('ExampleController', ['$scope', function($scope) {\n           $scope.snippet =\n             'Pretty text with some links:\\n'+\n             'http://angularjs.org/,\\n'+\n             'mailto:us@somewhere.org,\\n'+\n             'another@somewhere.org,\\n'+\n             'and one more: ftp://127.0.0.1/.';\n           $scope.snippetWithSingleURL = 'http://angularjs.org/';\n         }]);\n     </file>\n     <file name=\"protractor.js\" type=\"protractor\">\n       it('should linkify the snippet with urls', function() {\n         expect(element(by.id('linky-filter')).element(by.binding('snippet | linky')).getText()).\n             toBe('Pretty text with some links: http://angularjs.org/, us@somewhere.org, ' +\n                  'another@somewhere.org, and one more: ftp://127.0.0.1/.');\n         expect(element.all(by.css('#linky-filter a')).count()).toEqual(4);\n       });\n\n       it('should not linkify snippet without the linky filter', function() {\n         expect(element(by.id('escaped-html')).element(by.binding('snippet')).getText()).\n             toBe('Pretty text with some links: http://angularjs.org/, mailto:us@somewhere.org, ' +\n                  'another@somewhere.org, and one more: ftp://127.0.0.1/.');\n         expect(element.all(by.css('#escaped-html a')).count()).toEqual(0);\n       });\n\n       it('should update', function() {\n         element(by.model('snippet')).clear();\n         element(by.model('snippet')).sendKeys('new http://link.');\n         expect(element(by.id('linky-filter')).element(by.binding('snippet | linky')).getText()).\n             toBe('new http://link.');\n         expect(element.all(by.css('#linky-filter a')).count()).toEqual(1);\n         expect(element(by.id('escaped-html')).element(by.binding('snippet')).getText())\n             .toBe('new http://link.');\n       });\n\n       it('should work with the target property', function() {\n        expect(element(by.id('linky-target')).\n            element(by.binding(\"snippetWithSingleURL | linky:'_blank'\")).getText()).\n            toBe('http://angularjs.org/');\n        expect(element(by.css('#linky-target a')).getAttribute('target')).toEqual('_blank');\n       });\n\n       it('should optionally add custom attributes', function() {\n        expect(element(by.id('linky-custom-attributes')).\n            element(by.binding(\"snippetWithSingleURL | linky:'_self':{rel: 'nofollow'}\")).getText()).\n            toBe('http://angularjs.org/');\n        expect(element(by.css('#linky-custom-attributes a')).getAttribute('rel')).toEqual('nofollow');\n       });\n     </file>\n   </example>\n */\nangular.module('ngSanitize').filter('linky', ['$sanitize', function($sanitize) {\n  var LINKY_URL_REGEXP =\n        /((ftp|https?):\\/\\/|(www\\.)|(mailto:)?[A-Za-z0-9._%+-]+@)\\S*[^\\s.;,(){}<>\"\\u201d\\u2019]/i,\n      MAILTO_REGEXP = /^mailto:/i;\n\n  var linkyMinErr = angular.$$minErr('linky');\n  var isDefined = angular.isDefined;\n  var isFunction = angular.isFunction;\n  var isObject = angular.isObject;\n  var isString = angular.isString;\n\n  return function(text, target, attributes) {\n    if (text == null || text === '') return text;\n    if (!isString(text)) throw linkyMinErr('notstring', 'Expected string but received: {0}', text);\n\n    var attributesFn =\n      isFunction(attributes) ? attributes :\n      isObject(attributes) ? function getAttributesObject() {return attributes;} :\n      function getEmptyAttributesObject() {return {};};\n\n    var match;\n    var raw = text;\n    var html = [];\n    var url;\n    var i;\n    while ((match = raw.match(LINKY_URL_REGEXP))) {\n      // We can not end in these as they are sometimes found at the end of the sentence\n      url = match[0];\n      // if we did not match ftp/http/www/mailto then assume mailto\n      if (!match[2] && !match[4]) {\n        url = (match[3] ? 'http://' : 'mailto:') + url;\n      }\n      i = match.index;\n      addText(raw.substr(0, i));\n      addLink(url, match[0].replace(MAILTO_REGEXP, ''));\n      raw = raw.substring(i + match[0].length);\n    }\n    addText(raw);\n    return $sanitize(html.join(''));\n\n    function addText(text) {\n      if (!text) {\n        return;\n      }\n      html.push(sanitizeText(text));\n    }\n\n    function addLink(url, text) {\n      var key, linkAttributes = attributesFn(url);\n      html.push('<a ');\n\n      for (key in linkAttributes) {\n        html.push(key + '=\"' + linkAttributes[key] + '\" ');\n      }\n\n      if (isDefined(target) && !('target' in linkAttributes)) {\n        html.push('target=\"',\n                  target,\n                  '\" ');\n      }\n      html.push('href=\"',\n                url.replace(/\"/g, '&quot;'),\n                '\">');\n      addText(text);\n      html.push('</a>');\n    }\n  };\n}]);\n\n\n})(window, window.angular);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/angular-sanitize/angular-sanitize.js\n// module id = 8\n// module chunks = 0","import uiRouter from 'angular-ui-router';\r\nimport 'ui-router-extras';\r\nimport ocLazyLoad from 'oclazyload';\r\n\r\n$ProjectProvider.$inject = ['$futureStateProvider'];\r\nfunction $ProjectProvider($futureStateProvider) {\r\n\r\n  /**\r\n   * @param {String} html 项目入口 html 模板\r\n   *\r\n   * @typedef {Object} ProjectInfo\r\n   * @prop {Array} scripts\r\n   * @prop {String} template\r\n   *\r\n   * @returns {ProjectInfo}\r\n   */\r\n  function getProjectInfo(html) {\r\n    const SCRIPT_TAG_REGEX = /<script\\s+((?!type=('|\")text\\/ng-template('|\")).)*>.*<\\/script>/gi;\r\n    const SCRIPT_SRC_REGEX = /.*\\ssrc=(\"|')(\\S+)\\1.*/;\r\n    const SCRIPT_SEQ_REGEX = /.*\\sseq=(\"|')(\\S+)\\1.*/;\r\n    const scripts = [];\r\n    const template = html.replace(SCRIPT_TAG_REGEX, match => {\r\n      const matchedScriptSeq = match.match(SCRIPT_SEQ_REGEX);\r\n      const matchedScriptSrc = match.match(SCRIPT_SRC_REGEX);\r\n      const seq = (matchedScriptSeq && matchedScriptSeq[2]) || 0;\r\n\r\n      scripts[seq] = scripts[seq] || [];\r\n\r\n      if (matchedScriptSrc && matchedScriptSrc[2]) {\r\n        scripts[seq].push(matchedScriptSrc[2]);\r\n      }\r\n\r\n      return '<!-- script replaced -->';\r\n    });\r\n\r\n    return {\r\n      scripts: scripts.filter(script => !!script),\r\n      template\r\n    };\r\n  }\r\n\r\n  stateFactory.$inject = ['$q', '$http', '$ocLazyLoad', '$log', 'futureState'];\r\n  function stateFactory($q, $http, $ocLazyLoad, $log, futureState) {\r\n\r\n    const loadScripts = scripts => {\r\n      const errorHandle = err => {\r\n        $log.error(err);\r\n        return $q.reject(err);\r\n      };\r\n      let promise = $ocLazyLoad.load(scripts.shift());\r\n      let nextGroup;\r\n\r\n      while (scripts.length) {\r\n        nextGroup = scripts.shift();\r\n        promise = promise.then(() => {\r\n          return $ocLazyLoad.load(nextGroup);\r\n        });\r\n      }\r\n\r\n      return promise.catch(errorHandle);\r\n    };\r\n\r\n    const deferred = $q.defer();\r\n\r\n    $http.get(futureState.templateUrl).then(response => {\r\n      const projectInfo = getProjectInfo(response.data);\r\n\r\n      const state = {\r\n        name: futureState.name,\r\n        url: futureState.url,\r\n        template: projectInfo.template\r\n      };\r\n\r\n      if (projectInfo.scripts.length) {\r\n        loadScripts(projectInfo.scripts).then(() => {\r\n          deferred.resolve(state);\r\n        });\r\n      } else {\r\n        deferred.resolve(state);\r\n      }\r\n    }).catch(err => {\r\n      console.error(`Not found: ${futureState.templateUrl}`, err);\r\n      deferred.reject(err);\r\n    });\r\n\r\n    return deferred.promise;\r\n  }\r\n\r\n  $futureStateProvider.stateFactory('project', stateFactory);\r\n\r\n  this.state = (name, definition) => {\r\n    $futureStateProvider.futureState({\r\n      type: 'project',\r\n      name,\r\n      url: definition.url,\r\n      templateUrl: definition.templateUrl\r\n    });\r\n\r\n    return this;\r\n  };\r\n\r\n  this.$get = () => {};\r\n}\r\n\r\nexport default angular\r\n  .module('ccms.projectRouter', [\r\n    uiRouter,\r\n    'ct.ui.router.extras',\r\n    ocLazyLoad\r\n  ])\r\n  .provider('$project', $ProjectProvider)\r\n  .name;\r\n\n\n\n// WEBPACK FOOTER //\n// ./common/project-router/project.js","/**\n * UI-Router Extras: Sticky states, Future States, Deep State Redirect, Transition promise\n * Monolithic build (all modules)\n * @version 0.1.3\n * @link http://christopherthielen.github.io/ui-router-extras/\n * @license MIT License, http://www.opensource.org/licenses/MIT\n */\n(function (root, factory) {\n    'use strict';\n\n    if (typeof define === 'function' && define.amd) {\n        define(['angular'], function (angular) {\n            factory(angular);\n        });\n    } else if (typeof exports === 'object') {\n        factory(require('angular'));\n    } else {\n        factory(root.angular);\n    }\n}(this, function (angular, undefined) {\n    var mod_core = angular.module(\"ct.ui.router.extras.core\", [ \"ui.router\" ]);\n\nvar internalStates = {}, stateRegisteredCallbacks = [];\nmod_core.config([ '$stateProvider', '$injector', function ($stateProvider, $injector) {\n  // Decorate any state attribute in order to get access to the internal state representation.\n  $stateProvider.decorator('parent', function (state, parentFn) {\n    // Capture each internal UI-Router state representations as opposed to the user-defined state object.\n    // The internal state is, e.g., the state returned by $state.$current as opposed to $state.current\n    internalStates[state.self.name] = state;\n    // Add an accessor for the internal state from the user defined state\n    state.self.$$state = function () {\n      return internalStates[state.self.name];\n    };\n\n    angular.forEach(stateRegisteredCallbacks, function(callback) { callback(state); });\n    return parentFn(state);\n  });\n}]);\n\nvar DEBUG = false;\n\nvar forEach = angular.forEach;\nvar extend = angular.extend;\nvar isArray = angular.isArray;\n\nvar map = function (collection, callback) {\n  \"use strict\";\n  var result = [];\n  forEach(collection, function (item, index) {\n    result.push(callback(item, index));\n  });\n  return result;\n};\n\nvar keys = function (collection) {\n  \"use strict\";\n  return map(collection, function (collection, key) {\n    return key;\n  });\n};\n\nvar filter = function (collection, callback) {\n  \"use strict\";\n  var result = [];\n  forEach(collection, function (item, index) {\n    if (callback(item, index)) {\n      result.push(item);\n    }\n  });\n  return result;\n};\n\nvar filterObj = function (collection, callback) {\n  \"use strict\";\n  var result = {};\n  forEach(collection, function (item, index) {\n    if (callback(item, index)) {\n      result[index] = item;\n    }\n  });\n  return result;\n};\n\n// Duplicates code in UI-Router common.js\nfunction ancestors(first, second) {\n  var path = [];\n\n  for (var n in first.path) {\n    if (first.path[n] !== second.path[n]) break;\n    path.push(first.path[n]);\n  }\n  return path;\n}\n\n// Duplicates code in UI-Router common.js\nfunction objectKeys(object) {\n  if (Object.keys) {\n    return Object.keys(object);\n  }\n  var result = [];\n\n  angular.forEach(object, function (val, key) {\n    result.push(key);\n  });\n  return result;\n}\n\n/**\n * like objectKeys, but includes keys from prototype chain.\n * @param object the object whose prototypal keys will be returned\n * @param ignoreKeys an array of keys to ignore\n */\n// Duplicates code in UI-Router common.js\nfunction protoKeys(object, ignoreKeys) {\n  var result = [];\n  for (var key in object) {\n    if (!ignoreKeys || ignoreKeys.indexOf(key) === -1)\n      result.push(key);\n  }\n  return result;\n}\n\n// Duplicates code in UI-Router common.js\nfunction arraySearch(array, value) {\n  if (Array.prototype.indexOf) {\n    return array.indexOf(value, Number(arguments[2]) || 0);\n  }\n  var len = array.length >>> 0, from = Number(arguments[2]) || 0;\n  from = (from < 0) ? Math.ceil(from) : Math.floor(from);\n\n  if (from < 0) from += len;\n\n  for (; from < len; from++) {\n    if (from in array && array[from] === value) return from;\n  }\n  return -1;\n}\n\n// Duplicates code in UI-Router common.js\n// Added compatibility code  (isArray check) to support both 0.2.x and 0.3.x series of UI-Router.\nfunction inheritParams(currentParams, newParams, $current, $to) {\n  var parents = ancestors($current, $to), parentParams, inherited = {}, inheritList = [];\n\n  for (var i in parents) {\n    if (!parents[i].params) continue;\n    // This test allows compatibility with 0.2.x and 0.3.x (optional and object params)\n    parentParams = isArray(parents[i].params) ? parents[i].params : objectKeys(parents[i].params);\n    if (!parentParams.length) continue;\n\n    for (var j in parentParams) {\n      if (arraySearch(inheritList, parentParams[j]) >= 0) continue;\n      inheritList.push(parentParams[j]);\n      inherited[parentParams[j]] = currentParams[parentParams[j]];\n    }\n  }\n  return extend({}, inherited, newParams);\n}\n\nfunction inherit(parent, extra) {\n  return extend(new (extend(function () { }, {prototype: parent}))(), extra);\n}\n\nfunction onStateRegistered(callback) { stateRegisteredCallbacks.push(callback); }\n\nmod_core.provider(\"uirextras_core\", function() {\n  var core = {\n    internalStates: internalStates,\n    onStateRegistered: onStateRegistered,\n    forEach: forEach,\n    extend: extend,\n    isArray: isArray,\n    map: map,\n    keys: keys,\n    filter: filter,\n    filterObj: filterObj,\n    ancestors: ancestors,\n    objectKeys: objectKeys,\n    protoKeys: protoKeys,\n    arraySearch: arraySearch,\n    inheritParams: inheritParams,\n    inherit: inherit\n  };\n\n  angular.extend(this, core);\n\n  this.$get = function() {\n    return core;\n  };\n});\n\n\nvar ignoreDsr;\nfunction resetIgnoreDsr() {\n  ignoreDsr = undefined;\n}\n\n// Decorate $state.transitionTo to gain access to the last transition.options variable.\n// This is used to process the options.ignoreDsr option\nangular.module('ct.ui.router.extras.dsr', [ 'ct.ui.router.extras.core' ]).config([ \"$provide\", function ($provide) {\n  var $state_transitionTo;\n  $provide.decorator(\"$state\", ['$delegate', '$q', function ($state, $q) {\n    $state_transitionTo = $state.transitionTo;\n    $state.transitionTo = function (to, toParams, options) {\n      if (options && options.ignoreDsr) {\n        ignoreDsr = options.ignoreDsr;\n      }\n\n      return $state_transitionTo.apply($state, arguments).then(\n        function (result) {\n          resetIgnoreDsr();\n          return result;\n        },\n        function (err) {\n          resetIgnoreDsr();\n          return $q.reject(err);\n        }\n      );\n    };\n    return $state;\n  }]);\n}]);\n\nangular.module('ct.ui.router.extras.dsr').service(\"$deepStateRedirect\", [ '$rootScope', '$state', '$injector', function ($rootScope, $state, $injector) {\n  var lastSubstate = {};\n  var deepStateRedirectsByName = {};\n\n  var REDIRECT = \"Redirect\", ANCESTOR_REDIRECT = \"AncestorRedirect\";\n\n  function computeDeepStateStatus(state) {\n    var name = state.name;\n    if (deepStateRedirectsByName.hasOwnProperty(name))\n      return deepStateRedirectsByName[name];\n    recordDeepStateRedirectStatus(name);\n  }\n\n  function getConfig(state) {\n    var declaration = state.deepStateRedirect || state.dsr;\n    if (!declaration) return { dsr: false };\n    var dsrCfg = { dsr: true };\n\n    if (angular.isFunction(declaration)) {\n      dsrCfg.fn = declaration;\n    } else if (angular.isObject(declaration)) {\n      dsrCfg = angular.extend(dsrCfg, declaration);\n    }\n\n    if (angular.isString(dsrCfg['default'])) {\n      dsrCfg['default'] = { state: dsrCfg['default'] };\n    }\n\n    if (!dsrCfg.fn) {\n      dsrCfg.fn = [ '$dsr$', function($dsr$) {\n        return $dsr$.redirect.state != $dsr$.to.state;\n      } ];\n    }\n    return dsrCfg;\n  }\n\n  function recordDeepStateRedirectStatus(stateName) {\n    var state = $state.get(stateName);\n    if (!state) return false;\n    var cfg = getConfig(state);\n    if (cfg.dsr) {\n      deepStateRedirectsByName[state.name] = REDIRECT;\n      if (lastSubstate[stateName] === undefined)\n        lastSubstate[stateName] = {};\n    }\n\n    var parent = state.$$state && state.$$state().parent;\n    if (parent) {\n      var parentStatus = recordDeepStateRedirectStatus(parent.self.name);\n      if (parentStatus && deepStateRedirectsByName[state.name] === undefined) {\n        deepStateRedirectsByName[state.name] = ANCESTOR_REDIRECT;\n      }\n    }\n    return deepStateRedirectsByName[state.name] || false;\n  }\n\n  function getMatchParams(params, dsrParams) {\n    if (dsrParams === true) dsrParams = Object.keys(params);\n    if (dsrParams === null || dsrParams === undefined) dsrParams = [];\n\n    var matchParams = {};\n    angular.forEach(dsrParams.sort(), function(name) { matchParams[name] = params[name]; });\n    return matchParams;\n  }\n\n  function getParamsString(params, dsrParams) {\n    var matchParams = getMatchParams(params, dsrParams);\n    function safeString(input) { return !input ? input : input.toString(); }\n    var paramsToString = {};\n    angular.forEach(matchParams, function(val, name) { paramsToString[name] = safeString(val); });\n    return angular.toJson(paramsToString);\n  }\n\n  $rootScope.$on(\"$stateChangeStart\", function (event, toState, toParams, fromState, fromParams) {\n    var cfg = getConfig(toState);\n    if (ignoreDsr || (computeDeepStateStatus(toState) !== REDIRECT) && !cfg['default']) return;\n    // We're changing directly to one of the redirect (tab) states.\n    // Get the DSR key for this state by calculating the DSRParams option\n    var key = getParamsString(toParams, cfg.params);\n    var redirect = lastSubstate[toState.name][key] || cfg['default'];\n    if (!redirect) return;\n\n    // we have a last substate recorded\n    var $dsr$ = { redirect: { state: redirect.state, params: redirect.params}, to: { state: toState.name, params: toParams } };\n    var result = $injector.invoke(cfg.fn, toState, { $dsr$: $dsr$ });\n    if (!result) return;\n    if (result.state) redirect = result;\n    event.preventDefault();\n    var redirectParams = getMatchParams(toParams, cfg.params);\n    $state.go(redirect.state, angular.extend(redirectParams, redirect.params));\n  });\n\n  $rootScope.$on(\"$stateChangeSuccess\", function (event, toState, toParams, fromState, fromParams) {\n    var deepStateStatus = computeDeepStateStatus(toState);\n    if (deepStateStatus) {\n      var name = toState.name;\n      angular.forEach(lastSubstate, function (redirect, dsrState) {\n        // update Last-SubState&params for each DSR that this transition matches.\n        var cfg = getConfig($state.get(dsrState));\n        var key = getParamsString(toParams, cfg.params);\n        if (toState.$$state().includes[dsrState]) {\n          lastSubstate[dsrState][key] = { state: name, params: angular.copy(toParams) };\n        }\n      });\n    }\n  });\n\n  return {\n    getRedirect: function(dsrState, params) {\n      var state = $state.get(dsrState);\n      computeDeepStateStatus(state)\n      var cfg = getConfig(state);\n      var key = getParamsString(params, cfg.params);\n      var redirect = lastSubstate[state.name];\n      if (redirect && redirect[key]) {\n        redirect = redirect[key];\n      } else {\n        redirect = cfg['default'];\n      }\n      return redirect;\n    },\n    reset: function(stateOrName, params) {\n      if (!stateOrName) {\n        angular.forEach(lastSubstate, function(redirect, dsrState) { lastSubstate[dsrState] = {}; });\n      } else {\n        var state = $state.get(stateOrName);\n        if (!state) throw new Error(\"Unknown state: \" + stateOrName);\n        if (lastSubstate[state.name]) {\n          if (params) {\n            var key = getParamsString(params, getConfig(state).params);\n            delete lastSubstate[state.name][key];\n          } else {\n            lastSubstate[state.name] = {};\n          }\n        }\n      }\n    }\n  };\n}]);\n\nangular.module('ct.ui.router.extras.dsr').run(['$deepStateRedirect', function ($deepStateRedirect) {\n  // Make sure $deepStateRedirect is instantiated\n}]);\n\nangular.module(\"ct.ui.router.extras.sticky\", [ 'ct.ui.router.extras.core' ]);\n\nvar mod_sticky = angular.module(\"ct.ui.router.extras.sticky\");\n\n$StickyStateProvider.$inject = [ '$stateProvider', 'uirextras_coreProvider' ];\nfunction $StickyStateProvider($stateProvider, uirextras_coreProvider) {\n  var core = uirextras_coreProvider;\n  var inheritParams = core.inheritParams;\n  var objectKeys = core.objectKeys;\n  var protoKeys = core.protoKeys;\n  var forEach = core.forEach;\n  var map = core.map;\n\n  // Holds all the states which are inactivated.  Inactivated states can be either sticky states, or descendants of sticky states.\n  var inactiveStates = {}; // state.name -> (state)\n  var stickyStates = {}; // state.name -> true\n  var $state;\n  var DEBUG = false;\n\n  // Called by $stateProvider.registerState();\n  // registers a sticky state with $stickyStateProvider\n  this.registerStickyState = function (state) {\n    stickyStates[state.name] = state;\n    // console.log(\"Registered sticky state: \", state);\n  };\n\n  this.enableDebug = this.debugMode = function (enabled) {\n    if (angular.isDefined(enabled))\n      DEBUG = enabled;\n    return DEBUG;\n  };\n\n  this.$get = [  '$rootScope', '$state', '$stateParams', '$injector', '$log',\n    function ($rootScope, $state, $stateParams, $injector, $log) {\n      // Each inactive states is either a sticky state, or a child of a sticky state.\n      // This function finds the closest ancestor sticky state, then find that state's parent.\n      // Map all inactive states to their closest parent-to-sticky state.\n      function mapInactives() {\n        var mappedStates = {};\n        angular.forEach(inactiveStates, function (state, name) {\n          var stickyAncestors = getStickyStateStack(state);\n          for (var i = 0; i < stickyAncestors.length; i++) {\n            var parent = stickyAncestors[i].parent;\n            mappedStates[parent.name] = mappedStates[parent.name] || [];\n            mappedStates[parent.name].push(state);\n          }\n          if (mappedStates['']) {\n            // This is necessary to compute Transition.inactives when there are sticky states are children to root state.\n            mappedStates['__inactives'] = mappedStates[''];  // jshint ignore:line\n          }\n        });\n        return mappedStates;\n      }\n\n      function mapInactivesByImmediateParent() {\n        var inactivesByAllParents ={};\n        forEach(inactiveStates, function(state) {\n          forEach(state.path, function(ancestor) {\n            if (ancestor === state) return;\n            inactivesByAllParents[ancestor.name] = inactivesByAllParents[ancestor.name] || [];\n            inactivesByAllParents[ancestor.name].push(state);\n          });\n        });\n        return inactivesByAllParents;\n      }\n\n      // Given a state, returns all ancestor states which are sticky.\n      // Walks up the view's state's ancestry tree and locates each ancestor state which is marked as sticky.\n      // Returns an array populated with only those ancestor sticky states.\n      function getStickyStateStack(state) {\n        var stack = [];\n        if (!state) return stack;\n        do {\n          if (state.sticky) stack.push(state);\n          state = state.parent;\n        } while (state);\n        stack.reverse();\n        return stack;\n      }\n\n      // Returns a sticky transition type necessary to enter the state.\n      // Transition can be: reactivate, reload, or enter\n\n      // Note: if a state is being reactivated but params dont match, we treat\n      // it as a Exit/Enter, thus the special \"reload\" transition.\n      // If a parent inactivated state has \"reload\" transition type, then\n      // all descendant states must also be exit/entered, thus the first line of this function.\n      function getEnterTransition(state, stateParams, reloadStateTree, ancestorReloaded) {\n        if (ancestorReloaded) return \"reload\";\n        var inactiveState = inactiveStates[state.self.name];\n        if (!inactiveState) return \"enter\";\n        if (state.self === reloadStateTree) return \"reload\";\n        var paramsMatch = paramsEqualForState(state.ownParams, stateParams, inactiveState.locals.globals.$stateParams);\n        return paramsMatch ? \"reactivate\" : \"reload\";\n      }\n\n      // Given a state and (optional) stateParams, returns the inactivated state from the inactive sticky state registry.\n      function getInactivatedState(state, stateParams) {\n        var inactiveState = inactiveStates[state.name];\n        if (!inactiveState) return null;\n        if (!stateParams) return inactiveState;\n        var paramsMatch = paramsEqualForState(state.ownParams, stateParams, inactiveState.locals.globals.$stateParams);\n        return paramsMatch ? inactiveState : null;\n      }\n\n      function paramsEqualForState(ownParams, stateParams, stateParams2) {\n        if (typeof ownParams.$$equals === 'function')\n          return ownParams.$$equals(stateParams, stateParams2);\n        return equalForKeys(stateParams, stateParams2, ownParams);\n      }\n\n      // Duplicates logic in $state.transitionTo, primarily to find the pivot state (i.e., the \"keep\" value)\n      function equalForKeys(a, b, keys) {\n        if (!angular.isArray(keys) && angular.isObject(keys)) {\n          keys = protoKeys(keys, [\"$$keys\", \"$$values\", \"$$equals\", \"$$validates\", \"$$new\", \"$$parent\"]);\n        }\n        if (!keys) {\n          keys = [];\n          for (var n in a) keys.push(n); // Used instead of Object.keys() for IE8 compatibility\n        }\n\n        for (var i = 0; i < keys.length; i++) {\n          var k = keys[i];\n          if (a[k] != b[k]) return false; // Not '===', values aren't necessarily normalized\n        }\n        return true;\n      }\n\n      function calcTreeChanges(transition) {\n        var fromPath = transition.fromState.path;\n        var toPath = transition.toState.path;\n        var toParams = transition.toParams;\n        var keep = 0, state = toPath[keep];\n\n        if (transition.options && transition.options.inherit) {\n          toParams = transition.toParams =\n              inheritParams($stateParams, toParams || {}, $state.$current, transition.toState);\n        }\n\n        while (state && state === fromPath[keep] && paramsEqualForState(state.ownParams, toParams, transition.fromParams)) {\n          // We're \"keeping\" this state. bump keep var and get the next state in toPath for the next iteration.\n          state = toPath[++keep];\n        }\n\n        return {\n          keep: keep,\n          retained: fromPath.slice(0, keep),\n          exiting: fromPath.slice(keep),\n          entering: toPath.slice(keep)\n        };\n      }\n\n      function sortByStateDepth(a,b) {\n        return a.name.split(\".\").length - b.name.split(\".\").length;\n      }\n\n      var stickySupport = {\n        getInactiveStates: function () {\n          return map(inactiveStates, angular.identity).sort(sortByStateDepth);\n        },\n        getInactiveStatesByParent: function () {\n          return mapInactives();\n        },\n        // Main API for $stickyState, used by $state.\n        // Processes a potential transition, returns an object with the following attributes:\n        // {\n        //    keep: The number of states being \"kept\"\n        //    inactives: Array of all states which will be inactive if the transition is completed.\n        //    reactivatingStates: Array of all states which will be reactivated if the transition is completed.\n        //    orphans: Array of previously inactive states, which are being orphaned by the transition\n        //        Note: Transitioning directly to an inactive state with inactive children will reactivate the state, but exit all the inactive children.\n        //    enter: Enter transition type for all added states.  This is a parallel array to \"toStates\" array in $state.transitionTo.\n        //    exit: Exit transition type for all removed states.  This is a parallel array to \"fromStates\" array in $state.transitionTo.\n        // }\n        processTransition: function (transition) {\n          var treeChanges = calcTreeChanges(transition);\n          var currentInactives = stickySupport.getInactiveStates();\n          var futureInactives, exitingTypes, enteringTypes;\n          var keep = treeChanges.keep;\n\n\n          /////////////////////////////////////////\n          // helper functions\n          function notIn(array) { return function (elem) { return array.indexOf(elem) === -1; }; }\n          function flattenReduce(memo, list) { return memo.concat(list); }\n          function uniqReduce(memo, orphan) { if (notIn(memo)(orphan)) memo.push(orphan); return memo; }\n          function prop(attr) { return function(obj) { return obj[attr]; } }\n          function typeIs(type) { return function(obj) { return obj.type === type; } }\n          function isChildOf(state) { return function(other) { return other.parent === state; }; }\n          var notEntering = notIn(treeChanges.entering);\n          function notSticky(state) { return !state.sticky; }\n          ////////////////////////////////////\n\n\n          // Calculate the \"exit\" transition types for states being exited in fromPath\n          // Exit types will be either \"inactivate\" or \"exit\"\n          // Two things must be satisfied in order to inactivate the \"exiting\" states (instead of exit them):\n          // - The first element of the exiting path must be sticky\n          // - We must be entering any sibling state of the sticky (we can check this using entering.length)\n          var shouldInactivate = treeChanges.exiting[0] && treeChanges.exiting[0].sticky && treeChanges.entering.length > 0;\n          exitingTypes = treeChanges.exiting.map(function (state) {\n              var stateRentering = treeChanges.entering.indexOf(state) !== -1;\n              var type = shouldInactivate && !stateRentering ? \"inactivate\" : \"exit\";\n              return { type: type, state: state };\n          });\n\n\n          // Calculate the \"enter\" transition types for states being entered in toPath\n          // Enter types will be either \"enter\", \"reactivate\", or \"reload\" where:\n          //   enter: full resolve, no special logic\n          //   reactivate: use previous locals\n          //   reload: like 'enter', except exit the inactive state before entering it.\n          var reloaded = transition.options && !!transition.options.reload;\n          enteringTypes = treeChanges.entering.map(function(state) {\n            var type = getEnterTransition(state, transition.toParams, transition.reloadStateTree, reloaded);\n            reloaded = reloaded || type === 'reload';\n            return { type: type, state: state };\n          });\n\n          // Find all the \"orphaned\" states.  those states that are :\n          //  - are siblings of the entering states\n          //  - previously inactive\n          //  - are not being reactivated (entered)\n          //  - are not sticky\n          // unioned with:\n          //  - children of the toState\n          //  - previously inactive\n          //\n          // Given:\n          //   - states A (sticky: true), B, A.foo, A.bar\n          //   - A.foo is currently inactive\n          //   - B is currently active\n          // Orphan case 1)\n          //   - Transition to A.bar orphans the inactive state A.foo; it should be exited\n          // Orphan case 2)\n          //   - Transition directly to A orphans the inactive state A.foo; it should be exited\n          //\n          // Given:\n          //   - states A (sticky: true), B, A.foo (sticky), A.bar\n          //   - A.foo is currently inactive\n          //   - B is currently active\n          // Orphan case 3)\n          //   - Transition directly to A orphans the inactive sticky state A.foo; it should be exited\n          // Note: transition from B to A.bar does not orphan A.foo\n          // Note 2: each orphaned state might be the parent of a larger inactive subtree.\n          var orphanedRoots = treeChanges.entering\n              // For each entering state in the path, find all sibling states which are currently inactive\n              .map(function (entering) { return currentInactives.filter(isChildOf(entering.parent)); })\n              // Flatten nested arrays. Now we have an array of inactive states that are children of the ones being entered.\n              .reduce(flattenReduce, [])\n              // Consider \"orphaned\": only those children that are themselves not currently being entered\n              .filter(notEntering)\n              // Consider \"orphaned\": only those children that are not themselves sticky states.\n              .filter(notSticky)\n              // Finally, union that set with any inactive children of the \"to state\"\n              .concat(currentInactives.filter(isChildOf(transition.toState)));\n\n          var currentInactivesByParent = mapInactivesByImmediateParent();\n          var allOrphans = orphanedRoots\n              .map(function(root) { return currentInactivesByParent[root.name] })\n              .filter(angular.isDefined)\n              .reduce(flattenReduce, [])\n              .concat(orphanedRoots)\n              // Sort by depth to exit orphans in proper order\n              .sort(sortByStateDepth);\n\n          // Add them to the list of states being exited.\n          var exitOrOrphaned = exitingTypes\n              .filter(typeIs(\"exit\"))\n              .map(prop(\"state\"))\n              .concat(allOrphans);\n\n          // Now calculate the states that will be inactive if this transition succeeds.\n          // We have already pushed the transitionType == \"inactivate\" states to 'inactives'.\n          // Second, add all the existing inactive states\n          futureInactives = currentInactives\n              .filter(notIn(exitOrOrphaned))\n              .filter(notIn(treeChanges.entering))\n              .concat(exitingTypes.filter(typeIs(\"inactivate\")).map(prop(\"state\")))\n              .sort(sortByStateDepth);\n\n          return {\n            keep: keep,\n            enter: new Array(keep).concat(enteringTypes.map(prop(\"type\"))),\n            exit: new Array(keep).concat(exitingTypes.map(prop(\"type\"))),\n            inactives: futureInactives,\n            reactivatingStates: enteringTypes.filter(typeIs(\"reactivate\")).map(prop(\"state\")),\n            orphans: allOrphans\n          };\n        },\n\n        // Adds a state to the inactivated sticky state registry.\n        stateInactivated: function (state) {\n          // Keep locals around.\n          inactiveStates[state.self.name] = state;\n          // Notify states they are being Inactivated (i.e., a different\n          // sticky state tree is now active).\n          state.self.status = 'inactive';\n          if (state.self.onInactivate)\n            $injector.invoke(state.self.onInactivate, state.self, state.locals.globals);\n        },\n\n        // Removes a previously inactivated state from the inactive sticky state registry\n        stateReactivated: function (state) {\n          if (inactiveStates[state.self.name]) {\n            delete inactiveStates[state.self.name];\n          }\n          state.self.status = 'entered';\n//        if (state.locals == null || state.locals.globals == null) debugger;\n          if (state.self.onReactivate)\n            $injector.invoke(state.self.onReactivate, state.self, state.locals.globals);\n        },\n\n        // Exits all inactivated descendant substates when the ancestor state is exited.\n        // When transitionTo is exiting a state, this function is called with the state being exited.  It checks the\n        // registry of inactivated states for descendants of the exited state and also exits those descendants.  It then\n        // removes the locals and de-registers the state from the inactivated registry.\n        stateExiting: function (exiting, exitQueue, onExit) {\n          var exitingNames = {};\n          angular.forEach(exitQueue, function (state) {\n            exitingNames[state.self.name] = true;\n          });\n\n          angular.forEach(inactiveStates, function (inactiveExiting, name) {\n            // TODO: Might need to run the inactivations in the proper depth-first order?\n            if (!exitingNames[name] && inactiveExiting.includes[exiting.name]) {\n              if (DEBUG) $log.debug(\"Exiting \" + name + \" because it's a substate of \" + exiting.name + \" and wasn't found in \", exitingNames);\n              if (inactiveExiting.self.onExit)\n                $injector.invoke(inactiveExiting.self.onExit, inactiveExiting.self, inactiveExiting.locals.globals);\n              angular.forEach(inactiveExiting.locals, function(localval, key) {\n                delete inactivePseudoState.locals[key];\n              });\n              inactiveExiting.locals = null;\n              inactiveExiting.self.status = 'exited';\n              delete inactiveStates[name];\n            }\n          });\n\n          if (onExit)\n            $injector.invoke(onExit, exiting.self, exiting.locals.globals);\n          exiting.locals = null;\n          exiting.self.status = 'exited';\n          delete inactiveStates[exiting.self.name];\n        },\n\n        // Removes a previously inactivated state from the inactive sticky state registry\n        stateEntering: function (entering, params, onEnter, updateParams) {\n          var inactivatedState = getInactivatedState(entering);\n          if (inactivatedState && (updateParams || !getInactivatedState(entering, params))) {\n            var savedLocals = entering.locals;\n            this.stateExiting(inactivatedState);\n            entering.locals = savedLocals;\n          }\n          entering.self.status = 'entered';\n\n          if (onEnter)\n            $injector.invoke(onEnter, entering.self, entering.locals.globals);\n        },\n        reset: function reset(inactiveState, params) {\n          function resetOne(state) { stickySupport.reset(state); }\n          if (inactiveState === \"*\") {\n            angular.forEach(stickySupport.getInactiveStates(), resetOne);\n            return true;\n          }\n          var state = $state.get(inactiveState);\n          if (!state) return false;\n          var exiting = getInactivatedState(state, params);\n          if (!exiting) return false;\n          stickySupport.stateExiting(exiting);\n          $rootScope.$broadcast(\"$viewContentLoading\");\n          return true;\n        }\n      };\n\n      return stickySupport;\n    }];\n}\n\nmod_sticky.provider(\"$stickyState\", $StickyStateProvider);\n\n/**\n * Sticky States makes entire state trees \"sticky\". Sticky state trees are retained until their parent state is\n * exited. This can be useful to allow multiple modules, peers to each other, each module having its own independent\n * state tree.  The peer modules can be activated and inactivated without any loss of their internal context, including\n * DOM content such as unvalidated/partially filled in forms, and even scroll position.\n *\n * DOM content is retained by declaring a named ui-view in the parent state, and filling it in with a named view from the\n * sticky state.\n *\n * Technical overview:\n *\n * ---PATHS---\n * UI-Router uses state paths to manage entering and exiting of individual states.  Each state \"A.B.C.X\" has its own path, starting\n * from the root state (\"\") and ending at the state \"X\".  The path is composed the final state \"X\"'s ancestors, e.g.,\n * [ \"\", \"A\", \"B\", \"C\", \"X\" ].\n *\n * When a transition is processed, the previous path (fromState.path) is compared with the requested destination path\n * (toState.path).  All states that the from and to paths have in common are \"kept\" during the transition.  The last\n * \"kept\" element in the path is the \"pivot\".\n *\n * ---VIEWS---\n * A View in UI-Router consists of a controller and a template.  Each view belongs to one state, and a state can have many\n * views.  Each view plugs into a ui-view element in the DOM of one of the parent state's view(s).\n *\n * View context is managed in UI-Router using a 'state locals' concept. When a state's views are fully loaded, those views\n * are placed on the states 'locals' object.  Each locals object prototypally inherits from its parent state's locals object.\n * This means that state \"A.B.C.X\"'s locals object also has all of state \"A.B.C\"'s locals as well as those from \"A.B\" and \"A\".\n * The root state (\"\") defines no views, but it is included in the protypal inheritance chain.\n *\n * The locals object is used by the ui-view directive to load the template, render the content, create the child scope,\n * initialize the controller, etc.  The ui-view directives caches the locals in a closure variable.  If the locals are\n * identical (===), then the ui-view directive exits early, and does no rendering.\n *\n * In stock UI-Router, when a state is exited, that state's locals object is deleted and those views are cleaned up by\n * the ui-view directive shortly.\n *\n * ---Sticky States---\n * UI-Router Extras keeps views for inactive states live, even when UI-Router thinks it has exited them.  It does this\n * by creating a pseudo state called \"__inactives\" that is the parent of the root state.  It also then defines a locals\n * object on the \"__inactives\" state, which the root state protoypally inherits from.  By doing this, views for inactive\n * states are accessible through locals object's protoypal inheritance chain from any state in the system.\n *\n * ---Transitions---\n * UI-Router Extras decorates the $state.transitionTo function.  While a transition is in progress, the toState and\n * fromState internal state representations are modified in order to coerce stock UI-Router's transitionTo() into performing\n * the appropriate operations.  When the transition promise is completed, the original toState and fromState values are\n * restored.\n *\n * Stock UI-Router's $state.transitionTo function uses toState.path and fromState.path to manage entering and exiting\n * states.  UI-Router Extras takes advantage of those internal implementation details and prepares a toState.path and\n * fromState.path which coerces UI-Router into entering and exiting the correct states, or more importantly, not entering\n * and not exiting inactive or sticky states.  It also replaces state.self.onEnter and state.self.onExit for elements in\n * the paths when they are being inactivated or reactivated.\n */\n\n\n\n// ------------------------ Sticky State module-level variables -----------------------------------------------\nvar _StickyState; // internal reference to $stickyStateProvider\nvar internalStates = {}; // Map { statename -> InternalStateObj } holds internal representation of all states\nvar root, // Root state, internal representation\n  pendingTransitions = [], // One transition may supersede another.  This holds references to all pending transitions\n  pendingRestore, // The restore function from the superseded transition\n  inactivePseudoState, // This pseudo state holds all the inactive states' locals (resolved state data, such as views etc)\n  reactivatingLocals = { }, // This is a prent locals to the inactivePseudoState locals, used to hold locals for states being reactivated\n  versionHeuristics = { // Heuristics used to guess the current UI-Router Version\n    hasParamSet: false\n  };\n\n// Creates a blank surrogate state\nfunction SurrogateState(type) {\n  return {\n    resolve: { },\n    locals: {\n      globals: root && root.locals && root.locals.globals\n    },\n    views: { },\n    self: { },\n    params: { },\n    ownParams: ( versionHeuristics.hasParamSet ? { $$equals: function() { return true; } } : []),\n    surrogateType: type\n  };\n}\n\n// ------------------------ Sticky State registration and initialization code ----------------------------------\n// Grab a copy of the $stickyState service for use by the transition management code\nangular.module(\"ct.ui.router.extras.sticky\").run([\"$stickyState\", function ($stickyState) {\n  _StickyState = $stickyState;\n}]);\n\nangular.module(\"ct.ui.router.extras.sticky\").config(\n  [ \"$provide\", \"$stateProvider\", '$stickyStateProvider', '$urlMatcherFactoryProvider', 'uirextras_coreProvider',\n    function ($provide, $stateProvider, $stickyStateProvider, $urlMatcherFactoryProvider, uirextras_coreProvider) {\n      var core = uirextras_coreProvider;\n      var internalStates = core.internalStates;\n      var inherit = core.inherit;\n      var inheritParams = core.inheritParams;\n      var forEach = core.forEach;\n      var map = core.map;\n      var filterObj = core.filterObj;\n\n      versionHeuristics.hasParamSet = !!$urlMatcherFactoryProvider.ParamSet;\n      // inactivePseudoState (__inactives) holds all the inactive locals which includes resolved states data, i.e., views, scope, etc\n      inactivePseudoState = angular.extend(new SurrogateState(\"__inactives\"), { self: {  name: '__inactives'  } });\n      // Reset other module scoped variables.  This is to primarily to flush any previous state during karma runs.\n      root = pendingRestore = undefined;\n      pendingTransitions = [];\n\n      uirextras_coreProvider.onStateRegistered(function(state) {\n        // Register the ones marked as \"sticky\"\n        if (state.self.sticky === true) {\n          $stickyStateProvider.registerStickyState(state.self);\n        }\n      });\n\n      var $state_transitionTo; // internal reference to the real $state.transitionTo function\n      // Decorate the $state service, so we can decorate the $state.transitionTo() function with sticky state stuff.\n      $provide.decorator(\"$state\", ['$delegate', '$log', '$q', function ($state, $log, $q) {\n        // Note: this code gets run only on the first state that is decorated\n        root = $state.$current;\n        internalStates[\"\"] = root;\n        root.parent = inactivePseudoState; // Make inactivePsuedoState the parent of root.  \"wat\"\n        inactivePseudoState.parent = undefined; // Make inactivePsuedoState the real root.\n        // Add another locals bucket, as a parent to inactivatePseudoState locals.\n        // This is for temporary storage of locals of states being reactivated while a transition is pending\n        // This is necessary in some cases where $viewContentLoading is triggered before the $state.$current is updated to the toState.\n        inactivePseudoState.locals = inherit(reactivatingLocals, inactivePseudoState.locals);\n        root.locals = inherit(inactivePseudoState.locals, root.locals); // make root locals extend the __inactives locals.\n        delete inactivePseudoState.locals.globals;\n\n        // Hold on to the real $state.transitionTo in a module-scope variable.\n        $state_transitionTo = $state.transitionTo;\n\n        // ------------------------ Decorated transitionTo implementation begins here ---------------------------\n        $state.transitionTo = function (to, toParams, options) {\n          var DEBUG = $stickyStateProvider.debugMode();\n          // TODO: Move this to module.run?\n          // TODO: I'd rather have root.locals prototypally inherit from inactivePseudoState.locals\n          // Link root.locals and inactives.locals.  Do this at runtime, after root.locals has been set.\n          if (!inactivePseudoState.locals)\n            inactivePseudoState.locals = root.locals;\n          var idx = pendingTransitions.length;\n          if (pendingRestore) {\n            pendingRestore();\n            if (DEBUG) {\n              $log.debug(\"Restored paths from pending transition\");\n            }\n          }\n\n          var fromState = $state.$current, fromParams = $state.params;\n          var rel = options && options.relative || $state.$current; // Not sure if/when $state.$current is appropriate here.\n          var toStateSelf = $state.get(to, rel); // exposes findState relative path functionality, returns state.self\n          var savedToStatePath, savedFromStatePath, stickyTransitions;\n          var reactivated = [], exited = [], terminalReactivatedState;\n          toParams = toParams || {};\n          arguments[1] = toParams;\n\n          var noop = function () {\n          };\n          // Sticky states works by modifying the internal state objects of toState and fromState, especially their .path(s).\n          // The restore() function is a closure scoped function that restores those states' definitions to their original values.\n          var restore = function () {\n            if (savedToStatePath) {\n              toState.path = savedToStatePath;\n              savedToStatePath = null;\n            }\n\n            if (savedFromStatePath) {\n              fromState.path = savedFromStatePath;\n              savedFromStatePath = null;\n            }\n\n            angular.forEach(restore.restoreFunctions, function (restoreFunction) {\n              restoreFunction();\n            });\n            // Restore is done, now set the restore function to noop in case it gets called again.\n            restore = noop;\n            // pendingRestore keeps track of a transition that is in progress.  It allows the decorated transitionTo\n            // method to be re-entrant (for example, when superceding a transition, i.e., redirect).  The decorated\n            // transitionTo checks right away if there is a pending transition in progress and restores the paths\n            // if so using pendingRestore.\n            pendingRestore = null;\n            pendingTransitions.splice(idx, 1); // Remove this transition from the list\n          };\n\n          // All decorated transitions have their toState.path and fromState.path replaced.  Surrogate states also make\n          // additional changes to the states definition before handing the transition off to UI-Router. In particular,\n          // certain types of surrogate states modify the state.self object's onEnter or onExit callbacks.\n          // Those surrogate states must then register additional restore steps using restore.addRestoreFunction(fn)\n          restore.restoreFunctions = [];\n          restore.addRestoreFunction = function addRestoreFunction(fn) {\n            this.restoreFunctions.push(fn);\n          };\n\n\n          // --------------------- Surrogate State Functions ------------------------\n          // During a transition, the .path arrays in toState and fromState are replaced.  Individual path elements\n          // (states) which aren't being \"kept\" are replaced with surrogate elements (states).  This section of the code\n          // has factory functions for all the different types of surrogate states.\n\n\n          function stateReactivatedSurrogatePhase1(state) {\n            var surrogate = angular.extend(new SurrogateState(\"reactivate_phase1\"), { locals: state.locals });\n            surrogate.self = angular.extend({}, state.self);\n            return surrogate;\n          }\n\n          function stateReactivatedSurrogatePhase2(state) {\n            var surrogate = angular.extend(new SurrogateState(\"reactivate_phase2\"), state);\n            var oldOnEnter = surrogate.self.onEnter;\n            surrogate.resolve = {}; // Don't re-resolve when reactivating states (fixes issue #22)\n            // TODO: Not 100% sure if this is necessary.  I think resolveState will load the views if I don't do this.\n            surrogate.views = {}; // Don't re-activate controllers when reactivating states (fixes issue #22)\n            surrogate.self.onEnter = function () {\n              // ui-router sets locals on the surrogate to a blank locals (because we gave it nothing to resolve)\n              // Re-set it back to the already loaded state.locals here.\n              surrogate.locals = state.locals;\n              _StickyState.stateReactivated(state);\n            };\n            restore.addRestoreFunction(function () {\n              state.self.onEnter = oldOnEnter;\n            });\n            return surrogate;\n          }\n\n          function stateInactivatedSurrogate(state) {\n            var surrogate = new SurrogateState(\"inactivate\");\n            surrogate.self = state.self;\n            var oldOnExit = state.self.onExit;\n            surrogate.self.onExit = function () {\n              _StickyState.stateInactivated(state);\n            };\n            restore.addRestoreFunction(function () {\n              state.self.onExit = oldOnExit;\n            });\n            return surrogate;\n          }\n\n          function stateEnteredSurrogate(state, toParams) {\n            var oldOnEnter = state.self.onEnter;\n            state.self.onEnter = function () {\n              _StickyState.stateEntering(state, toParams, oldOnEnter);\n            };\n            restore.addRestoreFunction(function () {\n              state.self.onEnter = oldOnEnter;\n            });\n\n            return state;\n          }\n\n          // TODO: This may be completely unnecessary now that we're using $$uirouterextrasreload temp param\n          function stateUpdateParamsSurrogate(state, toParams) {\n            var oldOnEnter = state.self.onEnter;\n            state.self.onEnter = function () {\n              _StickyState.stateEntering(state, toParams, oldOnEnter, true);\n            };\n            restore.addRestoreFunction(function () {\n              state.self.onEnter = oldOnEnter;\n            });\n\n            return state;\n          }\n\n          function stateExitedSurrogate(state) {\n            var oldOnExit = state.self.onExit;\n            state.self.onExit = function () {\n              _StickyState.stateExiting(state, exited, oldOnExit);\n            };\n            restore.addRestoreFunction(function () {\n              state.self.onExit = oldOnExit;\n            });\n\n            return state;\n          }\n\n\n          // --------------------- decorated .transitionTo() logic starts here ------------------------\n          if (toStateSelf) {\n            var toState = internalStates[toStateSelf.name]; // have the state, now grab the internal state representation\n            if (toState) {\n              // Save the toState and fromState paths to be restored using restore()\n              savedToStatePath = toState.path;\n              savedFromStatePath = fromState.path;\n\n              // Try to resolve options.reload to a state.  If so, we'll reload only up to the given state.\n              var reload = options && options.reload || false;\n              var reloadStateTree = reload && (reload === true ? savedToStatePath[0].self : $state.get(reload, rel));\n              // If options.reload is a string or a state, we want to handle reload ourselves and not\n              // let ui-router reload the entire toPath.\n              if (options && reload && reload !== true)\n                delete options.reload;\n\n              var currentTransition = {\n                toState: toState,\n                toParams: toParams || {},\n                fromState: fromState,\n                fromParams: fromParams || {},\n                options: options,\n                reloadStateTree: reloadStateTree\n              };\n\n              pendingTransitions.push(currentTransition); // TODO: See if a list of pending transitions is necessary.\n              pendingRestore = restore;\n\n              // If we're reloading from a state and below, temporarily add a param to the top of the state tree\n              // being reloaded, and add a param value to the transition.  This will cause the \"has params changed\n              // for state\" check to return true, and the states will be reloaded.\n              if (reloadStateTree) {\n                currentTransition.toParams.$$uirouterextrasreload = Math.random();\n                var params = reloadStateTree.$$state().params;\n                var ownParams = reloadStateTree.$$state().ownParams;\n\n                if (versionHeuristics.hasParamSet) {\n                  var tempParam = new $urlMatcherFactoryProvider.Param('$$uirouterextrasreload');\n                  params.$$uirouterextrasreload = ownParams.$$uirouterextrasreload = tempParam;\n                  restore.restoreFunctions.push(function() {\n                    delete params.$$uirouterextrasreload;\n                    delete ownParams.$$uirouterextrasreload;\n                  });\n                } else {\n                  params.push('$$uirouterextrasreload');\n                  ownParams.push('$$uirouterextrasreload');\n                  restore.restoreFunctions.push(function() {\n                    params.length = params.length -1;\n                    ownParams.length = ownParams.length -1;\n                  });\n                }\n              }\n\n              // $StickyStateProvider.processTransition analyzes the states involved in the pending transition.  It\n              // returns an object that tells us:\n              // 1) if we're involved in a sticky-type transition\n              // 2) what types of exit transitions will occur for each \"exited\" path element\n              // 3) what types of enter transitions will occur for each \"entered\" path element\n              // 4) which states will be inactive if the transition succeeds.\n              stickyTransitions = _StickyState.processTransition(currentTransition);\n\n              if (DEBUG) debugTransition($log, currentTransition, stickyTransitions);\n\n              // Begin processing of surrogate to and from paths.\n              var surrogateToPath = toState.path.slice(0, stickyTransitions.keep);\n              var surrogateFromPath = fromState.path.slice(0, stickyTransitions.keep);\n\n              // Clear out and reload inactivePseudoState.locals each time transitionTo is called\n              angular.forEach(inactivePseudoState.locals, function (local, name) {\n                if (name.indexOf(\"@\") != -1) delete inactivePseudoState.locals[name];\n              });\n\n              var saveViewsToLocals = function (targetObj) {\n                return function(view, name) {\n                  if (name.indexOf(\"@\") !== -1) { // Only grab this state's \"view\" locals\n                    targetObj[name] = view; // Add all inactive views not already included.\n                  }\n                }\n              };\n\n              // For each state that will be inactive when the transition is complete, place its view-locals on the\n              // __inactives pseudostate's .locals.  This allows the ui-view directive to access them and\n              // render the inactive views.\n              forEach(stickyTransitions.inactives, function(state) {\n                forEach(state.locals, saveViewsToLocals(inactivePseudoState.locals))\n              });\n\n              // For each state that will be reactivated during the transition, place its view-locals on a separate\n              // locals object (prototypal parent of __inactives.locals, and remove them when the transition is complete.\n              // This is necessary when we a transition will reactivate one state, but enter a second.\n              // Gory details:\n              //   - the entering of a new state causes $view.load() to fire $viewContentLoading while the transition is\n              //     still in process\n              //   - all ui-view(s) check if they should re-render themselves in response to this event.\n              //   - ui-view checks if previousLocals is equal to currentLocals\n              //     - it uses $state.$current.locals[myViewName] for previousLocals\n              //   - Because the transition is not completed, $state.$current is set to the from state, and\n              //     the ui-view for a reactivated state cannot find its previous locals.\n              forEach(stickyTransitions.reactivatingStates, function(state) {\n                forEach(state.locals, saveViewsToLocals(reactivatingLocals));\n              });\n\n              // When the transition is complete, remove the copies of the view locals from reactivatingLocals.\n              restore.addRestoreFunction(function clearReactivatingLocals() {\n                forEach(reactivatingLocals, function (val, viewname) {\n                  delete reactivatingLocals[viewname];\n                })\n              });\n\n              // Find all the states the transition will be entering.  For each entered state, check entered-state-transition-type\n              // Depending on the entered-state transition type, place the proper surrogate state on the surrogate toPath.\n              angular.forEach(stickyTransitions.enter, function (value, idx) {\n                var surrogate;\n                var enteringState = toState.path[idx];\n                if (value === \"reactivate\") {\n                  // Reactivated states require TWO surrogates.  The \"phase 1 reactivated surrogates\" are added to both\n                  // to.path and from.path, and as such, are considered to be \"kept\" by UI-Router.\n                  // This is required to get UI-Router to add the surrogate locals to the protoypal locals object\n                  surrogate = stateReactivatedSurrogatePhase1(enteringState);\n                  surrogateToPath.push(surrogate);\n                  surrogateFromPath.push(surrogate);  // so toPath[i] === fromPath[i]\n\n                  // The \"phase 2 reactivated surrogate\" is added to the END of the .path, after all the phase 1\n                  // surrogates have been added.\n                  reactivated.push(stateReactivatedSurrogatePhase2(enteringState));\n                  terminalReactivatedState = enteringState;\n                } else if (value === \"reload\") {\n                  // If the state params have been changed, we need to exit any inactive states and re-enter them.\n                  surrogateToPath.push(stateUpdateParamsSurrogate(enteringState));\n                  terminalReactivatedState = enteringState;\n                } else if (value === \"enter\") {\n                  // Standard enter transition.  We still wrap it in a surrogate.\n                  surrogateToPath.push(stateEnteredSurrogate(enteringState));\n                }\n              });\n\n              // Find all the states the transition will be exiting.  For each exited state, check the exited-state-transition-type.\n              // Depending on the exited-state transition type, place a surrogate state on the surrogate fromPath.\n              angular.forEach(stickyTransitions.exit, function (value, idx) {\n                var exiting = fromState.path[idx];\n                if (value === \"inactivate\") {\n                  surrogateFromPath.push(stateInactivatedSurrogate(exiting));\n                  exited.push(exiting);\n                } else if (value === \"exit\") {\n                  surrogateFromPath.push(stateExitedSurrogate(exiting));\n                  exited.push(exiting);\n                }\n              });\n\n              // Add surrogate states for reactivated to ToPath again (phase 2), this time without a matching FromPath entry\n              // This is to get ui-router to call the surrogate's onEnter callback.\n              if (reactivated.length) {\n                angular.forEach(reactivated, function (surrogate) {\n                  surrogateToPath.push(surrogate);\n                });\n              }\n\n              // We may transition directly to an inactivated state, reactivating it.  In this case, we should\n              // exit all of that state's inactivated children.\n              var orphans = stickyTransitions.orphans;\n              // Add surrogate exited states for all orphaned descendants of the Deepest Reactivated State\n              surrogateFromPath = surrogateFromPath.concat(map(orphans, function (exiting) {\n                return stateExitedSurrogate(exiting);\n              }));\n              exited = exited.concat(orphans);\n\n              // Replace the .path variables.  toState.path and fromState.path are now ready for a sticky transition.\n              fromState.path = surrogateFromPath;\n              toState.path = surrogateToPath;\n\n              var pathMessage = function (state) {\n                return (state.surrogateType ? state.surrogateType + \":\" : \"\") + state.self.name;\n              };\n              if (DEBUG) $log.debug(\"SurrogateFromPath: \", map(surrogateFromPath, pathMessage));\n              if (DEBUG) $log.debug(\"SurrogateToPath:   \", map(surrogateToPath, pathMessage));\n            }\n          }\n\n          // toState and fromState are all set up; now run stock UI-Router's $state.transitionTo().\n          var transitionPromise = $state_transitionTo.apply($state, arguments);\n\n          // Add post-transition promise handlers, then return the promise to the original caller.\n          return transitionPromise.then(function transitionSuccess(state) {\n            // First, restore toState and fromState to their original values.\n            restore();\n            if (DEBUG)  debugViewsAfterSuccess($log, internalStates[state.name], $state);\n\n            state.status = 'active';  // TODO: This status is used in statevis.js, and almost certainly belongs elsewhere.\n\n            return state;\n          }, function transitionFailed(err) {\n            restore();\n            if (DEBUG &&\n              err.message !== \"transition prevented\" &&\n              err.message !== \"transition aborted\" &&\n              err.message !== \"transition superseded\") {\n              $log.debug(\"transition failed\", err);\n              $log.debug(err.stack);\n            }\n            return $q.reject(err);\n          });\n        };\n        return $state;\n      }]);\n\n\n\n      function debugTransition($log, currentTransition, stickyTransition) {\n        function message(path, index, state) {\n          return (path[index] ? path[index].toUpperCase() + \": \" + state.self.name : \"(\" + state.self.name + \")\");\n        }\n\n        var inactiveLogVar = map(stickyTransition.inactives, function (state) {\n          return state.self.name;\n        });\n        var enterLogVar = map(currentTransition.toState.path, function (state, index) {\n          return message(stickyTransition.enter, index, state);\n        });\n        var exitLogVar = map(currentTransition.fromState.path, function (state, index) {\n          return message(stickyTransition.exit, index, state);\n        });\n\n        var transitionMessage = currentTransition.fromState.self.name + \": \" +\n          angular.toJson(currentTransition.fromParams) + \": \" +\n          \" -> \" +\n          currentTransition.toState.self.name + \": \" +\n          angular.toJson(currentTransition.toParams);\n\n        $log.debug(\"------------------------------------------------------\");\n        $log.debug(\"   Current transition: \", transitionMessage);\n        $log.debug(\"Before transition, inactives are:   : \", map(_StickyState.getInactiveStates(), function (s) {\n          return s.self.name;\n        }));\n        $log.debug(\"After transition,  inactives will be: \", inactiveLogVar);\n        $log.debug(\"Transition will exit:  \", exitLogVar);\n        $log.debug(\"Transition will enter: \", enterLogVar);\n      }\n\n      function debugViewsAfterSuccess($log, currentState, $state) {\n        $log.debug(\"Current state: \" + currentState.self.name + \", inactive states: \", map(_StickyState.getInactiveStates(), function (s) {\n          return s.self.name;\n        }));\n\n        var statesOnly = function (local, name) {\n          return name != 'globals' && name != 'resolve';\n        };\n\n        var viewsForState = function (state) {\n          var viewLocals = filterObj(state.locals, statesOnly);\n\n          if (!Object.keys(viewLocals).length) {\n            viewLocals[''] = { $$state: { name: null } };\n          }\n\n          return map(viewLocals, function(local, name) {\n            return {\n              localsFor: state.self.name ? state.self.name : \"(root)\",\n              uiViewName: name || null,\n              filledByState: local.$$state.name\n            };\n          });\n        };\n\n        var viewsByState = viewsForState(currentState);\n        var parent = currentState.parent;\n        while (parent && parent !== currentState) {\n          viewsByState = viewsByState.concat(viewsForState(parent));\n          currentState = parent;\n          parent = currentState.parent;\n        }\n\n        $log.debug(\"Views active on each state:\");\n        console.table(viewsByState.reverse());\n      }\n    }\n  ]\n);\n\n(function(angular, undefined) {\n  var app = angular.module('ct.ui.router.extras.future', [ 'ct.ui.router.extras.core' ]);\n\n  _futureStateProvider.$inject = [ '$stateProvider', '$urlRouterProvider', '$urlMatcherFactoryProvider', 'uirextras_coreProvider' ];\n  function _futureStateProvider($stateProvider, $urlRouterProvider, $urlMatcherFactory, uirextras_coreProvider) {\n    var core = uirextras_coreProvider;\n    var internalStates = core.internalStates;\n    var stateFactories = {}, futureStates = {};\n    var lazyloadInProgress = false, resolveFunctions = [], initPromise, initDone = false;\n    var provider = this;\n\n    // This function registers a promiseFn, to be resolved before the url/state matching code\n    // will reject a route.  The promiseFn is injected/executed using the runtime $injector.\n    // The function should return a promise.\n    // When all registered promises are resolved, then the route is re-sync'ed.\n\n    // Example: function($http) {\n    //  return $http.get('//server.com/api/DynamicFutureStates').then(function(data) {\n    //    angular.forEach(data.futureStates, function(fstate) { $futureStateProvider.futureState(fstate); });\n    //  };\n    // }\n    this.addResolve = function (promiseFn) {\n      resolveFunctions.push(promiseFn);\n    };\n\n    // Register a state factory function for a particular future-state type.  This factory, given a future-state object,\n    // should create a ui-router state.\n    // The factory function is injected/executed using the runtime $injector.  The future-state is injected as 'futureState'.\n\n    // Example:\n    //    $futureStateProvider.stateFactory('test', function(futureState) {\n    //      return {\n    //        name: futureState.stateName,\n    //        url: futureState.urlFragment,\n    //        template: '<h3>Future State Template</h3>',\n    //        controller: function() {\n    //          console.log(\"Entered state \" + futureState.stateName);\n    //        }\n    //      }\n    //    });\n    this.stateFactory = function (futureStateType, factory) {\n      stateFactories[futureStateType] = factory;\n    };\n\n    this.futureState = function (futureState) {\n      if (futureState.stateName)  // backwards compat for now\n        futureState.name = futureState.stateName;\n      if (futureState.urlPrefix)  // backwards compat for now\n        futureState.url = \"^\" + futureState.urlPrefix;\n\n      futureStates[futureState.name] = futureState;\n      var parentMatcher,  parentName = futureState.name.split(/\\./).slice(0, -1).join(\".\"),\n        realParent = findState(futureState.parent || parentName);\n      if (realParent) {\n        parentMatcher = realParent.url || realParent.navigable && realParent.navigable.url;\n      } else if (parentName === \"\") {\n        parentMatcher = $urlMatcherFactory.compile(\"\");\n      } else {\n        var futureParent = findState((futureState.parent || parentName), true);\n        if (!futureParent) throw new Error(\"Couldn't determine parent state of future state. FutureState:\" + angular.toJson(futureState));\n        var pattern;\n        if (futureParent.urlMatcher) {\n          pattern = futureParent.urlMatcher.source.replace(/\\*rest$/, \"\");\n        }\n        else {\n          // if the futureParent doesn't have a urlMatcher, then we are still\n          // starting from the beginning of the path\n          pattern = \"\";\n        }\n        parentMatcher = $urlMatcherFactory.compile(pattern);\n        futureState.parentFutureState = futureParent;\n      }\n      if (futureState.url) {\n        futureState.urlMatcher = futureState.url.charAt(0) === \"^\" ?\n          $urlMatcherFactory.compile(futureState.url.substring(1) + \"*rest\") :\n          parentMatcher.concat(futureState.url + \"*rest\");\n      }\n    };\n\n    this.get = function () {\n      return angular.extend({}, futureStates);\n    };\n\n    function findState(stateOrName, findFutureState) {\n      var statename = angular.isObject(stateOrName) ? stateOrName.name : stateOrName;\n      return !findFutureState ? internalStates[statename] : futureStates[statename];\n    }\n\n    /* options is an object with at least a name or url attribute */\n    function findFutureState($state, options) {\n      if (options.name) {\n        var nameComponents = options.name.split(/\\./);\n        if (options.name.charAt(0) === '.')\n          nameComponents[0] = $state.current.name;\n        while (nameComponents.length) {\n          var stateName = nameComponents.join(\".\");\n          if ($state.get(stateName, { relative: $state.current }))\n            return null; // State is already defined; nothing to do\n          if (futureStates[stateName])\n            return futureStates[stateName];\n          nameComponents.pop();\n        }\n      }\n\n      if (options.url) {\n        var matches = [];\n        for(var future in futureStates) {\n          var matcher = futureStates[future].urlMatcher;\n          if (matcher && matcher.exec(options.url)) {\n            matches.push(futureStates[future]);\n          }\n        }\n        // Find most specific by ignoring matching parents from matches\n        var copy = matches.slice(0);\n        for (var i = matches.length - 1; i >= 0; i--) {\n          for (var j = 0; j < copy.length; j++) {\n            if (matches[i] === copy[j].parentFutureState) matches.splice(i, 1);\n          }\n        }\n        return matches[0];\n      }\n    }\n\n    function lazyLoadState($injector, futureState) {\n      lazyloadInProgress = true;\n      var $q = $injector.get(\"$q\");\n      if (!futureState) {\n        var deferred = $q.defer();\n        deferred.reject(\"No lazyState passed in \" + futureState);\n        return deferred.promise;\n      }\n\n      var parentPromises = $q.when([]), parentFuture = futureState.parentFutureState;\n      if (parentFuture && futureStates[parentFuture.name]) {\n        parentPromises = lazyLoadState($injector, futureStates[parentFuture.name]);\n      }\n\n      var type = futureState.type;\n      var factory = stateFactories[type];\n      if (!factory) throw Error(\"No state factory for futureState.type: \" + (futureState && futureState.type));\n\n      var failedLoadPolicy = factory.$options && factory.$options.failedLazyLoadPolicy || \"remove\";\n      function deregisterFutureState() { delete(futureStates[futureState.name]); }\n      function errorHandler(err) {\n        if (failedLoadPolicy === \"remove\") deregisterFutureState();\n        return $q.reject(err);\n      }\n\n      return parentPromises.then(function(array) {\n        var factoryPromise = $injector.invoke(factory, factory, { futureState: futureState });\n\n        return factoryPromise.then(function(fullState) {\n          deregisterFutureState(); // Success; remove future state\n          if (fullState) { array.push(fullState); } // Pass a chain of realized states back\n          return array;\n        });\n      }).catch(errorHandler)\n    }\n\n    var otherwiseFunc = [ '$log', '$location',\n      function otherwiseFunc($log, $location) {\n        //$log.debug(\"Unable to map \" + $location.path());\n      }];\n\n    function futureState_otherwise($injector, $location) {\n      var resyncing = false;\n\n      var lazyLoadMissingState =\n        ['$rootScope', '$urlRouter', '$state',\n          function lazyLoadMissingState($rootScope, $urlRouter, $state) {\n            function resync() {\n              resyncing = true; $urlRouter.sync(); resyncing = false;\n            }\n            if (!initDone) {\n              // Asynchronously load state definitions, then resync URL\n              initPromise().then(resync);\n              initDone = true;\n              return;\n            }\n\n            var futureState = findFutureState($state, { url: $location.path() });\n            if (!futureState) {\n              return $injector.invoke(otherwiseFunc);\n            }\n\n            // Config loaded.  Asynchronously lazy-load state definition from URL fragment, if mapped.\n            lazyLoadState($injector, futureState).then(function lazyLoadedStateCallback(states) {\n              states.forEach(function (state) {\n                if (state && (!$state.get(state) || (state.name && !$state.get(state.name))))\n                  $stateProvider.state(state);\n              });\n              lazyloadInProgress = false;\n              resync();\n            }, function lazyLoadStateAborted() {\n              lazyloadInProgress = false;\n              resync();\n            });\n          }];\n      if (lazyloadInProgress) return;\n\n      var nextFn = resyncing ? otherwiseFunc : lazyLoadMissingState;\n      return $injector.invoke(nextFn);\n    }\n\n    $urlRouterProvider.otherwise(futureState_otherwise);\n\n    $urlRouterProvider.otherwise = function(rule) {\n      if (angular.isString(rule)) {\n        var redirect = rule;\n        rule = function () { return redirect; };\n      }\n      else if (!angular.isFunction(rule)) throw new Error(\"'rule' must be a function\");\n      otherwiseFunc = ['$injector', '$location', rule];\n      return $urlRouterProvider;\n    };\n\n    var serviceObject = {\n      getResolvePromise: function () {\n        return initPromise();\n      }\n    };\n\n    // Used in .run() block to init\n    this.$get = [ '$injector', '$state', '$q', '$rootScope', '$urlRouter', '$timeout', '$log',\n      function futureStateProvider_get($injector, $state, $q, $rootScope, $urlRouter, $timeout, $log) {\n        function init() {\n          $rootScope.$on(\"$stateNotFound\", function futureState_notFound(event, unfoundState, fromState, fromParams) {\n            if (lazyloadInProgress) return;\n            //$log.debug(\"event, unfoundState, fromState, fromParams\", event, unfoundState, fromState, fromParams);\n\n            var futureState = findFutureState($state, { name: unfoundState.to });\n            if (!futureState) return;\n\n            event.preventDefault();\n            var promise = lazyLoadState($injector, futureState);\n            promise.then(function (states) {\n              states.forEach(function (state) {\n                if (state && (!$state.get(state) || (state.name && !$state.get(state.name))))\n                  $stateProvider.state(state);\n              });\n              $state.go(unfoundState.to, unfoundState.toParams, unfoundState.options);\n              lazyloadInProgress = false;\n            }, function (error) {\n              console.log(\"failed to lazy load state \", error);\n              if (fromState.name) $state.go(fromState, fromParams);\n              lazyloadInProgress = false;\n            });\n          });\n\n          // Do this better.  Want to load remote config once, before everything else\n          if (!initPromise) {\n            var promises = [];\n            angular.forEach(resolveFunctions, function (promiseFn) {\n              promises.push($injector.invoke(promiseFn));\n            });\n            initPromise = function () {\n              return $q.all(promises);\n            };\n          }\n\n          // TODO: analyze this. I'm calling $urlRouter.sync() in two places for retry-initial-transition.\n          // TODO: I should only need to do this once.  Pick the better place and remove the extra resync.\n          initPromise().then(function retryInitialState() {\n            $timeout(function () {\n              if ($state.transition) {\n                $state.transition.then(retryInitialState, retryInitialState);\n              } else {\n                $urlRouter.sync();\n              }\n            });\n          });\n        }\n\n        init();\n\n        serviceObject.state = $stateProvider.state;\n        serviceObject.futureState = provider.futureState;\n        serviceObject.get = provider.get;\n\n        return serviceObject;\n      }\n    ];\n  }\n\n  app.provider('$futureState', _futureStateProvider);\n\n  var statesAddedQueue = {\n    state: function(state) {\n      if (statesAddedQueue.$rootScope)\n        statesAddedQueue.$rootScope.$broadcast(\"$stateAdded\", state);\n    },\n    itsNowRuntimeOhWhatAHappyDay: function($rootScope) {\n      statesAddedQueue.$rootScope = $rootScope;\n    },\n    $rootScope: undefined\n  };\n\n  app.config([ '$stateProvider', function($stateProvider) {\n    // decorate $stateProvider.state so we can broadcast when a real state was added\n    var realStateFn = $stateProvider.state;\n    $stateProvider.state = function state_announce() {\n      var val = realStateFn.apply($stateProvider, arguments);\n\n      var state = angular.isObject(arguments[0]) ? arguments[0] : arguments[1];\n      statesAddedQueue.state(state);\n      return val;\n    };\n  }]);\n\n  // inject $futureState so the service gets initialized via $get();\n  app.run(['$futureState', function ($futureState, $rootScope) {\n    statesAddedQueue.itsNowRuntimeOhWhatAHappyDay($rootScope);\n  } ]);\n\n})(angular);\n\nangular.module('ct.ui.router.extras.previous', [ 'ct.ui.router.extras.core', 'ct.ui.router.extras.transition' ]).service(\"$previousState\",\n  [ '$rootScope', '$state', '$q',\n    function ($rootScope, $state, $q) {\n      var previous = null, lastPrevious = null, memos = {};\n\n      $rootScope.$on(\"$transitionStart\", function(evt, $transition$) {\n        var from = $transition$.from;\n        // Check if the fromState is navigable before tracking it.\n        // Root state doesn't get decorated with $$state().  Doh.\n        var fromState = from.state && from.state.$$state && from.state.$$state();\n        function commit() { lastPrevious = null; }\n        function revert() { previous = lastPrevious; }\n        if (fromState) {\n          lastPrevious = previous;\n          previous = $transition$.from;\n\n          $transition$.promise.then(commit)['catch'](revert);\n        }\n      });\n\n      var $previousState = {\n        get: function (memoName) {\n          return memoName ? memos[memoName] : previous;\n        },\n        set: function (memoName, previousState, previousParams) {\n          memos[memoName] = { state: $state.get(previousState), params: previousParams };\n        },\n        go: function (memoName, options) {\n          var to = $previousState.get(memoName);\n          if (!to) {\n            return $q.reject(new Error('no previous state ' + (memoName ? 'for memo: ' + memoName : '')));\n          }\n          return $state.go(to.state, to.params, options);\n        },\n        memo: function (memoName, defaultStateName, defaultStateParams) {\n          memos[memoName] = previous || { state: $state.get(defaultStateName), params: defaultStateParams };\n        },\n        forget: function (memoName) {\n          if (memoName) {\n            delete memos[memoName];\n          } else {\n            previous = undefined;\n          }\n        }\n      };\n\n      return $previousState;\n    }\n  ]\n);\n\nangular.module('ct.ui.router.extras.previous').run(['$previousState', function ($previousState) {\n  // Inject $previousState so it can register $rootScope events\n}]);\n\n\nangular.module(\"ct.ui.router.extras.transition\", [ 'ct.ui.router.extras.core' ]).config( [ \"$provide\",  function ($provide) {\n      // Decorate the $state service, so we can replace $state.transitionTo()\n      $provide.decorator(\"$state\", ['$delegate', '$rootScope', '$q', '$injector',\n        function ($state, $rootScope, $q, $injector) {\n          // Keep an internal reference to the real $state.transitionTo function\n          var $state_transitionTo = $state.transitionTo;\n          // $state.transitionTo can be re-entered.  Keep track of re-entrant stack\n          var transitionDepth = -1;\n          var tDataStack = [];\n          var restoreFnStack = [];\n\n          // This function decorates the $injector, adding { $transition$: tData } to invoke() and instantiate() locals.\n          // It returns a function that restores $injector to its previous state.\n          function decorateInjector(tData) {\n            var oldinvoke = $injector.invoke;\n            var oldinstantiate = $injector.instantiate;\n            $injector.invoke = function (fn, self, locals) {\n              return oldinvoke(fn, self, angular.extend({$transition$: tData}, locals));\n            };\n            $injector.instantiate = function (fn, locals) {\n              return oldinstantiate(fn, angular.extend({$transition$: tData}, locals));\n            };\n\n            return function restoreItems() {\n              $injector.invoke = oldinvoke;\n              $injector.instantiate = oldinstantiate;\n            };\n          }\n\n          function popStack() {\n            restoreFnStack.pop()();\n            tDataStack.pop();\n            transitionDepth--;\n          }\n\n          // This promise callback (for when the real transitionTo is successful) runs the restore function for the\n          // current stack level, then broadcasts the $transitionSuccess event.\n          function transitionSuccess(deferred, tSuccess) {\n            return function successFn(data) {\n              popStack();\n              $rootScope.$broadcast(\"$transitionSuccess\", tSuccess);\n              deferred.resolve(data); // $transition$ deferred\n              return data;\n            };\n          }\n\n          // This promise callback (for when the real transitionTo fails) runs the restore function for the\n          // current stack level, then broadcasts the $transitionError event.\n          function transitionFailure(deferred, tFail) {\n            return function failureFn(error) {\n              popStack();\n              $rootScope.$broadcast(\"$transitionError\", tFail, error);\n              deferred.reject(error);  // $transition$ deferred\n              return $q.reject(error);\n            };\n          }\n\n          // Decorate $state.transitionTo.\n          $state.transitionTo = function (to, toParams, options) {\n            // Create a deferred/promise which can be used earlier than UI-Router's transition promise.\n            var deferred = $q.defer();\n            // Place the promise in a transition data, and place it on the stack to be used in $stateChangeStart\n            var tData = tDataStack[++transitionDepth] = {\n              promise: deferred.promise\n            };\n            // placeholder restoreFn in case transitionTo doesn't reach $stateChangeStart (state not found, etc)\n            restoreFnStack[transitionDepth] = function() { };\n            // Invoke the real $state.transitionTo\n            var tPromise = $state_transitionTo.apply($state, arguments);\n\n            // insert our promise callbacks into the chain.\n            return tPromise.then(transitionSuccess(deferred, tData), transitionFailure(deferred, tData));\n          };\n\n          // This event is handled synchronously in transitionTo call stack\n          $rootScope.$on(\"$stateChangeStart\", function (evt, toState, toParams, fromState, fromParams) {\n              if (transitionDepth >= tDataStack.length) return;\n              var depth = transitionDepth;\n              // To/From is now normalized by ui-router.  Add this information to the transition data object.\n              var tData = angular.extend(tDataStack[depth], {\n                to: { state: toState, params: toParams },\n                from: { state: fromState, params: fromParams }\n              });\n\n              var restoreFn = decorateInjector(tData);\n              restoreFnStack[depth] = restoreFn;\n              $rootScope.$broadcast(\"$transitionStart\", tData);\n            }\n          );\n\n          return $state;\n        }]);\n    }\n  ]\n);\n\n// statevis requires d3.\n(function () {\n  \"use strict\";\n  var app = angular.module(\"ct.ui.router.extras.statevis\", [ 'ct.ui.router.extras.core', 'ct.ui.router.extras.sticky'  ]);\n\n  app.directive('stateVis', [ '$state', '$timeout', '$interval', stateVisDirective ]);\n\n  /**\n   * This directive gets all the current states using $state.get() and displays them in a tree using D3 lib.\n   * It then listens for state events and updates the tree.\n   *\n   * Usage:\n   * <state-vis height=\"1000px\" width=\"1000px\"></state-vis>\n   */\n  function stateVisDirective($state, $timeout, $interval) {\n    return {\n      scope: {\n        width: '@',\n        height: '@'\n      },\n      restrict: 'AE',\n      template: '<svg></svg>',\n      link: function (_scope, _elem, _attrs) {\n        var stateMap = {};\n        var width = _scope.width || 400,\n          height = _scope.height || 400;\n\n        var tree = d3.layout.tree()\n            .size([width - 20, height - 20])\n            .separation(function (a, b) {\n              return a.parent == b.parent ? 10 : 25;\n            });\n\n        var root = $state.get().filter(function (state) { return state.name === \"\"; })[0];\n        var nodes = tree(root);\n\n        root.parent = root;\n        root.px = root.x = width / 2;\n        root.py = root.y = height / 2;\n\n        var activeNode = { };\n        activeNode.px = activeNode.x = root.px;\n        activeNode.py = activeNode.y = root.py;\n\n        var diagonal = d3.svg.diagonal();\n\n        var svg = d3.select(_elem.find(\"svg\")[0])\n          .attr(\"width\", width)\n          .attr(\"height\", height)\n          .append(\"g\")\n          .attr(\"transform\", \"translate(10, 10)\");\n\n        var node = svg.selectAll(\".node\"),\n          link = svg.selectAll(\".link\"),\n          active = svg.selectAll(\".active\")\n          ;\n\n        var updateInterval = 200,\n          transLength = 200,\n          timer = setInterval(update, updateInterval);\n\n        function addStates(data) {\n          // *********** Convert flat data into a nice tree ***************\n          data = data.map(function (node) {\n            return node.name === \"\" ? root : angular.copy(node);\n          });\n          angular.extend(stateMap, data.reduce(function (map, node) {\n            map[node.name] = node;\n            return map;\n          }, {}));\n\n          data.forEach(function (node) {\n            // add to parent\n            var parentName = node.name.split(/\\./).slice(0, -1).join(\".\");\n            var parent = node.name != parentName && stateMap[parentName];\n            if (parent) {\n              (parent.children || (parent.children = [])).push(node); // create child array if it doesn't exist\n              node.px = parent.px;\n              node.py = parent.py;\n              nodes.push(node);\n            }\n          });\n        }\n\n        $interval(function () {\n          _scope.states = $state.get();\n          angular.forEach(nodes, function (n) {\n            var s = $state.get(n.name);\n            if (s) {\n              n.status = s.status || 'exited';\n            }\n          });\n//          _scope.futureStates = $futureState.get();\n        }, 250);\n\n        _scope.$watchCollection(\"states\", function (newval, oldval) {\n          var oldstates = (oldval || []).map(function (s) { return s.name; });\n          addStates((newval || []).filter(function(state) { return oldstates.indexOf(state.name) == -1; } ));\n//          addStates(_.reject(newval, function (state) { return _.contains(oldstates, state.name); }));\n        });\n\n//        addStates($state.get());\n        update(updateInterval);\n\n        function update() {\n          // Recompute the layout and data join.\n          node = node.data(tree.nodes(root), function (d) { return d.name; });\n          link = link.data(tree.links(nodes), function (d) { return d.target.name; });\n          active = active.data(activeNode);\n\n          nodes.forEach(function (d) { d.y = d.depth * 70; });\n\n          // Add entering nodes in the parent’s old position.\n          var nodeEnter = node.enter();\n\n          function stateName(node) {\n            var name = node.name.split(\".\").pop();\n            if (node.sticky) { name += \" (STICKY)\"; }\n            if (node.deepStateRedirect) { name += \" (DSR)\"; }\n            return name;\n          }\n\n          active.enter()\n            .append(\"circle\")\n            .attr(\"class\", \"active\")\n            .attr(\"r\", 13)\n            .attr(\"cx\", function (d) { return d.parent.px || 100; })\n            .attr(\"cy\", function (d) { return d.parent.py || 100; })\n          ;\n\n          nodeEnter.append(\"circle\")\n            .attr(\"class\", \"node\")\n            .attr(\"r\", 9)\n            .attr(\"cx\", function (d) { return d.parent.px; })\n            .attr(\"cy\", function (d) { return d.parent.py; });\n\n          nodeEnter.append(\"text\")\n            .attr(\"class\", \"label\")\n            .attr(\"x\", function (d) { return d.parent.px; })\n            .attr(\"y\", function (d) { return d.parent.py; })\n            .attr(\"text-anchor\", function (d) { return \"middle\"; })\n            .text(stateName)\n            .style(\"fill-opacity\", 1);\n\n\n          // Add entering links in the parent’s old position.\n          link.enter().insert(\"path\", \".node\")\n            .attr(\"class\", \"link\")\n            .attr(\"d\", function (d) {\n              var o = {x: d.source.px, y: d.source.py};\n              return diagonal({source: o, target: o});\n            });\n\n          // Transition nodes and links to their new positions.\n          var t = svg.transition()\n            .duration(transLength);\n\n          t.selectAll(\".link\")\n            .attr(\"d\", diagonal);\n\n          /* jshint -W093 */\n          var circleColors = { entered: '#AF0', exited: '#777', active: '#0f0', inactive: '#55F', future: '#009' };\n          t.selectAll(\".node\")\n            .attr(\"cx\", function (d) { return d.px = d.x; })\n            .attr(\"cy\", function (d) { return d.py = d.y; })\n            .attr(\"r\", function (d) { return d.status === 'active' ? 15 : 10; })\n            .style(\"fill\", function (d) { return circleColors[d.status] || \"#FFF\"; });\n\n          t.selectAll(\".label\")\n            .attr(\"x\", function (d) { return d.px = d.x; })\n            .attr(\"y\", function (d) { return d.py = d.y - 15; })\n            .attr(\"transform\", function (d) { return \"rotate(-25 \" + d.x + \" \" + d.y + \")\"; })\n          ;\n\n          t.selectAll(\".active\")\n            .attr(\"x\", function (d) { return d.px = d.x; })\n            .attr(\"y\", function (d) { return d.py = d.y - 15; });\n        }\n      }\n    };\n  }\n})();\n\n\nangular.module(\"ct.ui.router.extras\",\n  [\n    'ct.ui.router.extras.core',\n    'ct.ui.router.extras.dsr',\n    'ct.ui.router.extras.future',\n    'ct.ui.router.extras.previous',\n    'ct.ui.router.extras.statevis',\n    'ct.ui.router.extras.sticky',\n    'ct.ui.router.extras.transition'\n  ]);\n\n\n}));\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/ui-router-extras/release/ct-ui-router-extras.js\n// module id = 14\n// module chunks = 0","/**\n * oclazyload - Load modules on demand (lazy load) with angularJS\n * @version v1.0.9\n * @link https://github.com/ocombe/ocLazyLoad\n * @license MIT\n * @author Olivier Combe <olivier.combe@gmail.com>\n */\n(function (angular, window) {\n    'use strict';\n\n    var regModules = ['ng', 'oc.lazyLoad'],\n        regInvokes = {},\n        regConfigs = [],\n        modulesToLoad = [],\n        // modules to load from angular.module or other sources\n    realModules = [],\n        // real modules called from angular.module\n    recordDeclarations = [],\n        broadcast = angular.noop,\n        runBlocks = {},\n        justLoaded = [];\n\n    var ocLazyLoad = angular.module('oc.lazyLoad', ['ng']);\n\n    ocLazyLoad.provider('$ocLazyLoad', [\"$controllerProvider\", \"$provide\", \"$compileProvider\", \"$filterProvider\", \"$injector\", \"$animateProvider\", function ($controllerProvider, $provide, $compileProvider, $filterProvider, $injector, $animateProvider) {\n        var modules = {},\n            providers = {\n            $controllerProvider: $controllerProvider,\n            $compileProvider: $compileProvider,\n            $filterProvider: $filterProvider,\n            $provide: $provide, // other things (constant, decorator, provider, factory, service)\n            $injector: $injector,\n            $animateProvider: $animateProvider\n        },\n            debug = false,\n            events = false,\n            moduleCache = [],\n            modulePromises = {};\n\n        moduleCache.push = function (value) {\n            if (this.indexOf(value) === -1) {\n                Array.prototype.push.apply(this, arguments);\n            }\n        };\n\n        this.config = function (config) {\n            // If we want to define modules configs\n            if (angular.isDefined(config.modules)) {\n                if (angular.isArray(config.modules)) {\n                    angular.forEach(config.modules, function (moduleConfig) {\n                        modules[moduleConfig.name] = moduleConfig;\n                    });\n                } else {\n                    modules[config.modules.name] = config.modules;\n                }\n            }\n\n            if (angular.isDefined(config.debug)) {\n                debug = config.debug;\n            }\n\n            if (angular.isDefined(config.events)) {\n                events = config.events;\n            }\n        };\n\n        /**\n         * Get the list of existing registered modules\n         * @param element\n         */\n        this._init = function _init(element) {\n            // this is probably useless now because we override angular.bootstrap\n            if (modulesToLoad.length === 0) {\n                var elements = [element],\n                    names = ['ng:app', 'ng-app', 'x-ng-app', 'data-ng-app'],\n                    NG_APP_CLASS_REGEXP = /\\sng[:\\-]app(:\\s*([\\w\\d_]+);?)?\\s/,\n                    append = function append(elm) {\n                    return elm && elements.push(elm);\n                };\n\n                angular.forEach(names, function (name) {\n                    names[name] = true;\n                    append(document.getElementById(name));\n                    name = name.replace(':', '\\\\:');\n                    if (typeof element[0] !== 'undefined' && element[0].querySelectorAll) {\n                        angular.forEach(element[0].querySelectorAll('.' + name), append);\n                        angular.forEach(element[0].querySelectorAll('.' + name + '\\\\:'), append);\n                        angular.forEach(element[0].querySelectorAll('[' + name + ']'), append);\n                    }\n                });\n\n                angular.forEach(elements, function (elm) {\n                    if (modulesToLoad.length === 0) {\n                        var className = ' ' + element.className + ' ';\n                        var match = NG_APP_CLASS_REGEXP.exec(className);\n                        if (match) {\n                            modulesToLoad.push((match[2] || '').replace(/\\s+/g, ','));\n                        } else {\n                            angular.forEach(elm.attributes, function (attr) {\n                                if (modulesToLoad.length === 0 && names[attr.name]) {\n                                    modulesToLoad.push(attr.value);\n                                }\n                            });\n                        }\n                    }\n                });\n            }\n\n            if (modulesToLoad.length === 0 && !((window.jasmine || window.mocha) && angular.isDefined(angular.mock))) {\n                console.error('No module found during bootstrap, unable to init ocLazyLoad. You should always use the ng-app directive or angular.boostrap when you use ocLazyLoad.');\n            }\n\n            var addReg = function addReg(moduleName) {\n                if (regModules.indexOf(moduleName) === -1) {\n                    // register existing modules\n                    regModules.push(moduleName);\n                    var mainModule = angular.module(moduleName);\n\n                    // register existing components (directives, services, ...)\n                    _invokeQueue(null, mainModule._invokeQueue, moduleName);\n                    _invokeQueue(null, mainModule._configBlocks, moduleName); // angular 1.3+\n\n                    angular.forEach(mainModule.requires, addReg);\n                }\n            };\n\n            angular.forEach(modulesToLoad, function (moduleName) {\n                addReg(moduleName);\n            });\n\n            modulesToLoad = []; // reset for next bootstrap\n            recordDeclarations.pop(); // wait for the next lazy load\n        };\n\n        /**\n         * Like JSON.stringify but that doesn't throw on circular references\n         * @param obj\n         */\n        var stringify = function stringify(obj) {\n            try {\n                return JSON.stringify(obj);\n            } catch (e) {\n                var cache = [];\n                return JSON.stringify(obj, function (key, value) {\n                    if (angular.isObject(value) && value !== null) {\n                        if (cache.indexOf(value) !== -1) {\n                            // Circular reference found, discard key\n                            return;\n                        }\n                        // Store value in our collection\n                        cache.push(value);\n                    }\n                    return value;\n                });\n            }\n        };\n\n        var hashCode = function hashCode(str) {\n            var hash = 0,\n                i,\n                chr,\n                len;\n            if (str.length == 0) {\n                return hash;\n            }\n            for (i = 0, len = str.length; i < len; i++) {\n                chr = str.charCodeAt(i);\n                hash = (hash << 5) - hash + chr;\n                hash |= 0; // Convert to 32bit integer\n            }\n            return hash;\n        };\n\n        function _register(providers, registerModules, params) {\n            if (registerModules) {\n                var k,\n                    moduleName,\n                    moduleFn,\n                    tempRunBlocks = [];\n                for (k = registerModules.length - 1; k >= 0; k--) {\n                    moduleName = registerModules[k];\n                    if (!angular.isString(moduleName)) {\n                        moduleName = getModuleName(moduleName);\n                    }\n                    if (!moduleName || justLoaded.indexOf(moduleName) !== -1 || modules[moduleName] && realModules.indexOf(moduleName) === -1) {\n                        continue;\n                    }\n                    // new if not registered\n                    var newModule = regModules.indexOf(moduleName) === -1;\n                    moduleFn = ngModuleFct(moduleName);\n                    if (newModule) {\n                        regModules.push(moduleName);\n                        _register(providers, moduleFn.requires, params);\n                    }\n                    if (moduleFn._runBlocks.length > 0) {\n                        // new run blocks detected! Replace the old ones (if existing)\n                        runBlocks[moduleName] = [];\n                        while (moduleFn._runBlocks.length > 0) {\n                            runBlocks[moduleName].push(moduleFn._runBlocks.shift());\n                        }\n                    }\n                    if (angular.isDefined(runBlocks[moduleName]) && (newModule || params.rerun)) {\n                        tempRunBlocks = tempRunBlocks.concat(runBlocks[moduleName]);\n                    }\n                    _invokeQueue(providers, moduleFn._invokeQueue, moduleName, params.reconfig);\n                    _invokeQueue(providers, moduleFn._configBlocks, moduleName, params.reconfig); // angular 1.3+\n                    broadcast(newModule ? 'ocLazyLoad.moduleLoaded' : 'ocLazyLoad.moduleReloaded', moduleName);\n                    registerModules.pop();\n                    justLoaded.push(moduleName);\n                }\n                // execute the run blocks at the end\n                var instanceInjector = providers.getInstanceInjector();\n                angular.forEach(tempRunBlocks, function (fn) {\n                    instanceInjector.invoke(fn);\n                });\n            }\n        }\n\n        function _registerInvokeList(args, moduleName) {\n            var invokeList = args[2][0],\n                type = args[1],\n                newInvoke = false;\n            if (angular.isUndefined(regInvokes[moduleName])) {\n                regInvokes[moduleName] = {};\n            }\n            if (angular.isUndefined(regInvokes[moduleName][type])) {\n                regInvokes[moduleName][type] = {};\n            }\n            var onInvoke = function onInvoke(invokeName, invoke) {\n                if (!regInvokes[moduleName][type].hasOwnProperty(invokeName)) {\n                    regInvokes[moduleName][type][invokeName] = [];\n                }\n                if (checkHashes(invoke, regInvokes[moduleName][type][invokeName])) {\n                    newInvoke = true;\n                    regInvokes[moduleName][type][invokeName].push(invoke);\n                    broadcast('ocLazyLoad.componentLoaded', [moduleName, type, invokeName]);\n                }\n            };\n\n            function checkHashes(potentialNew, invokes) {\n                var isNew = true,\n                    newHash;\n                if (invokes.length) {\n                    newHash = signature(potentialNew);\n                    angular.forEach(invokes, function (invoke) {\n                        isNew = isNew && signature(invoke) !== newHash;\n                    });\n                }\n                return isNew;\n            }\n\n            function signature(data) {\n                if (angular.isArray(data)) {\n                    // arrays are objects, we need to test for it first\n                    return hashCode(data.toString());\n                } else if (angular.isObject(data)) {\n                    // constants & values for example\n                    return hashCode(stringify(data));\n                } else {\n                    if (angular.isDefined(data) && data !== null) {\n                        return hashCode(data.toString());\n                    } else {\n                        // null & undefined constants\n                        return data;\n                    }\n                }\n            }\n\n            if (angular.isString(invokeList)) {\n                onInvoke(invokeList, args[2][1]);\n            } else if (angular.isObject(invokeList)) {\n                angular.forEach(invokeList, function (invoke, key) {\n                    if (angular.isString(invoke)) {\n                        // decorators for example\n                        onInvoke(invoke, invokeList[1]);\n                    } else {\n                        // components registered as object lists {\"componentName\": function() {}}\n                        onInvoke(key, invoke);\n                    }\n                });\n            } else {\n                return false;\n            }\n            return newInvoke;\n        }\n\n        function _invokeQueue(providers, queue, moduleName, reconfig) {\n            if (!queue) {\n                return;\n            }\n\n            var i, len, args, provider;\n            for (i = 0, len = queue.length; i < len; i++) {\n                args = queue[i];\n                if (angular.isArray(args)) {\n                    if (providers !== null) {\n                        if (providers.hasOwnProperty(args[0])) {\n                            provider = providers[args[0]];\n                        } else {\n                            throw new Error('unsupported provider ' + args[0]);\n                        }\n                    }\n                    var isNew = _registerInvokeList(args, moduleName);\n                    if (args[1] !== 'invoke') {\n                        if (isNew && angular.isDefined(provider)) {\n                            provider[args[1]].apply(provider, args[2]);\n                        }\n                    } else {\n                        // config block\n                        var callInvoke = function callInvoke(fct) {\n                            var invoked = regConfigs.indexOf(moduleName + '-' + fct);\n                            if (invoked === -1 || reconfig) {\n                                if (invoked === -1) {\n                                    regConfigs.push(moduleName + '-' + fct);\n                                }\n                                if (angular.isDefined(provider)) {\n                                    provider[args[1]].apply(provider, args[2]);\n                                }\n                            }\n                        };\n                        if (angular.isFunction(args[2][0])) {\n                            callInvoke(args[2][0]);\n                        } else if (angular.isArray(args[2][0])) {\n                            for (var j = 0, jlen = args[2][0].length; j < jlen; j++) {\n                                if (angular.isFunction(args[2][0][j])) {\n                                    callInvoke(args[2][0][j]);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        function getModuleName(module) {\n            var moduleName = null;\n            if (angular.isString(module)) {\n                moduleName = module;\n            } else if (angular.isObject(module) && module.hasOwnProperty('name') && angular.isString(module.name)) {\n                moduleName = module.name;\n            }\n            return moduleName;\n        }\n\n        function moduleExists(moduleName) {\n            if (!angular.isString(moduleName)) {\n                return false;\n            }\n            try {\n                return ngModuleFct(moduleName);\n            } catch (e) {\n                if (/No module/.test(e) || e.message.indexOf('$injector:nomod') > -1) {\n                    return false;\n                }\n            }\n        }\n\n        this.$get = [\"$log\", \"$rootElement\", \"$rootScope\", \"$cacheFactory\", \"$q\", function ($log, $rootElement, $rootScope, $cacheFactory, $q) {\n            var instanceInjector,\n                filesCache = $cacheFactory('ocLazyLoad');\n\n            if (!debug) {\n                $log = {};\n                $log['error'] = angular.noop;\n                $log['warn'] = angular.noop;\n                $log['info'] = angular.noop;\n            }\n\n            // Make this lazy because when $get() is called the instance injector hasn't been assigned to the rootElement yet\n            providers.getInstanceInjector = function () {\n                return instanceInjector ? instanceInjector : instanceInjector = $rootElement.data('$injector') || angular.injector();\n            };\n\n            broadcast = function broadcast(eventName, params) {\n                if (events) {\n                    $rootScope.$broadcast(eventName, params);\n                }\n                if (debug) {\n                    $log.info(eventName, params);\n                }\n            };\n\n            function reject(e) {\n                var deferred = $q.defer();\n                $log.error(e.message);\n                deferred.reject(e);\n                return deferred.promise;\n            }\n\n            return {\n                _broadcast: broadcast,\n\n                _$log: $log,\n\n                /**\n                 * Returns the files cache used by the loaders to store the files currently loading\n                 * @returns {*}\n                 */\n                _getFilesCache: function getFilesCache() {\n                    return filesCache;\n                },\n\n                /**\n                 * Let the service know that it should monitor angular.module because files are loading\n                 * @param watch boolean\n                 */\n                toggleWatch: function toggleWatch(watch) {\n                    if (watch) {\n                        recordDeclarations.push(true);\n                    } else {\n                        recordDeclarations.pop();\n                    }\n                },\n\n                /**\n                 * Let you get a module config object\n                 * @param moduleName String the name of the module\n                 * @returns {*}\n                 */\n                getModuleConfig: function getModuleConfig(moduleName) {\n                    if (!angular.isString(moduleName)) {\n                        throw new Error('You need to give the name of the module to get');\n                    }\n                    if (!modules[moduleName]) {\n                        return null;\n                    }\n                    return angular.copy(modules[moduleName]);\n                },\n\n                /**\n                 * Let you define a module config object\n                 * @param moduleConfig Object the module config object\n                 * @returns {*}\n                 */\n                setModuleConfig: function setModuleConfig(moduleConfig) {\n                    if (!angular.isObject(moduleConfig)) {\n                        throw new Error('You need to give the module config object to set');\n                    }\n                    modules[moduleConfig.name] = moduleConfig;\n                    return moduleConfig;\n                },\n\n                /**\n                 * Returns the list of loaded modules\n                 * @returns {string[]}\n                 */\n                getModules: function getModules() {\n                    return regModules;\n                },\n\n                /**\n                 * Let you check if a module has been loaded into Angular or not\n                 * @param modulesNames String/Object a module name, or a list of module names\n                 * @returns {boolean}\n                 */\n                isLoaded: function isLoaded(modulesNames) {\n                    var moduleLoaded = function moduleLoaded(module) {\n                        var isLoaded = regModules.indexOf(module) > -1;\n                        if (!isLoaded) {\n                            isLoaded = !!moduleExists(module);\n                        }\n                        return isLoaded;\n                    };\n                    if (angular.isString(modulesNames)) {\n                        modulesNames = [modulesNames];\n                    }\n                    if (angular.isArray(modulesNames)) {\n                        var i, len;\n                        for (i = 0, len = modulesNames.length; i < len; i++) {\n                            if (!moduleLoaded(modulesNames[i])) {\n                                return false;\n                            }\n                        }\n                        return true;\n                    } else {\n                        throw new Error('You need to define the module(s) name(s)');\n                    }\n                },\n\n                /**\n                 * Given a module, return its name\n                 * @param module\n                 * @returns {String}\n                 */\n                _getModuleName: getModuleName,\n\n                /**\n                 * Returns a module if it exists\n                 * @param moduleName\n                 * @returns {module}\n                 */\n                _getModule: function getModule(moduleName) {\n                    try {\n                        return ngModuleFct(moduleName);\n                    } catch (e) {\n                        // this error message really suxx\n                        if (/No module/.test(e) || e.message.indexOf('$injector:nomod') > -1) {\n                            e.message = 'The module \"' + stringify(moduleName) + '\" that you are trying to load does not exist. ' + e.message;\n                        }\n                        throw e;\n                    }\n                },\n\n                /**\n                 * Check if a module exists and returns it if it does\n                 * @param moduleName\n                 * @returns {boolean}\n                 */\n                moduleExists: moduleExists,\n\n                /**\n                 * Load the dependencies, and might try to load new files depending on the config\n                 * @param moduleName (String or Array of Strings)\n                 * @param localParams\n                 * @returns {*}\n                 * @private\n                 */\n                _loadDependencies: function _loadDependencies(moduleName, localParams) {\n                    var loadedModule,\n                        requires,\n                        diff,\n                        promisesList = [],\n                        self = this;\n\n                    moduleName = self._getModuleName(moduleName);\n\n                    if (moduleName === null) {\n                        return $q.when();\n                    } else {\n                        try {\n                            loadedModule = self._getModule(moduleName);\n                        } catch (e) {\n                            return reject(e);\n                        }\n                        // get unloaded requires\n                        requires = self.getRequires(loadedModule);\n                    }\n\n                    angular.forEach(requires, function (requireEntry) {\n                        // If no configuration is provided, try and find one from a previous load.\n                        // If there isn't one, bail and let the normal flow run\n                        if (angular.isString(requireEntry)) {\n                            var config = self.getModuleConfig(requireEntry);\n                            if (config === null) {\n                                moduleCache.push(requireEntry); // We don't know about this module, but something else might, so push it anyway.\n                                return;\n                            }\n                            requireEntry = config;\n                            // ignore the name because it's probably not a real module name\n                            config.name = undefined;\n                        }\n\n                        // Check if this dependency has been loaded previously\n                        if (self.moduleExists(requireEntry.name)) {\n                            // compare against the already loaded module to see if the new definition adds any new files\n                            diff = requireEntry.files.filter(function (n) {\n                                return self.getModuleConfig(requireEntry.name).files.indexOf(n) < 0;\n                            });\n\n                            // If the module was redefined, advise via the console\n                            if (diff.length !== 0) {\n                                self._$log.warn('Module \"', moduleName, '\" attempted to redefine configuration for dependency. \"', requireEntry.name, '\"\\n Additional Files Loaded:', diff);\n                            }\n\n                            // Push everything to the file loader, it will weed out the duplicates.\n                            if (angular.isDefined(self.filesLoader)) {\n                                // if a files loader is defined\n                                promisesList.push(self.filesLoader(requireEntry, localParams).then(function () {\n                                    return self._loadDependencies(requireEntry);\n                                }));\n                            } else {\n                                return reject(new Error('Error: New dependencies need to be loaded from external files (' + requireEntry.files + '), but no loader has been defined.'));\n                            }\n                            return;\n                        } else if (angular.isArray(requireEntry)) {\n                            var files = [];\n                            angular.forEach(requireEntry, function (entry) {\n                                // let's check if the entry is a file name or a config name\n                                var config = self.getModuleConfig(entry);\n                                if (config === null) {\n                                    files.push(entry);\n                                } else if (config.files) {\n                                    files = files.concat(config.files);\n                                }\n                            });\n                            if (files.length > 0) {\n                                requireEntry = {\n                                    files: files\n                                };\n                            }\n                        } else if (angular.isObject(requireEntry)) {\n                            if (requireEntry.hasOwnProperty('name') && requireEntry['name']) {\n                                // The dependency doesn't exist in the module cache and is a new configuration, so store and push it.\n                                self.setModuleConfig(requireEntry);\n                                moduleCache.push(requireEntry['name']);\n                            }\n                        }\n\n                        // Check if the dependency has any files that need to be loaded. If there are, push a new promise to the promise list.\n                        if (angular.isDefined(requireEntry.files) && requireEntry.files.length !== 0) {\n                            if (angular.isDefined(self.filesLoader)) {\n                                // if a files loader is defined\n                                promisesList.push(self.filesLoader(requireEntry, localParams).then(function () {\n                                    return self._loadDependencies(requireEntry);\n                                }));\n                            } else {\n                                return reject(new Error('Error: the module \"' + requireEntry.name + '\" is defined in external files (' + requireEntry.files + '), but no loader has been defined.'));\n                            }\n                        }\n                    });\n\n                    // Create a wrapper promise to watch the promise list and resolve it once everything is done.\n                    return $q.all(promisesList);\n                },\n\n                /**\n                 * Inject new modules into Angular\n                 * @param moduleName\n                 * @param localParams\n                 * @param real\n                 */\n                inject: function inject(moduleName) {\n                    var localParams = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n                    var real = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];\n\n                    var self = this,\n                        deferred = $q.defer();\n                    if (angular.isDefined(moduleName) && moduleName !== null) {\n                        if (angular.isArray(moduleName)) {\n                            var promisesList = [];\n                            angular.forEach(moduleName, function (module) {\n                                promisesList.push(self.inject(module, localParams, real));\n                            });\n                            return $q.all(promisesList);\n                        } else {\n                            self._addToLoadList(self._getModuleName(moduleName), true, real);\n                        }\n                    }\n                    if (modulesToLoad.length > 0) {\n                        var res = modulesToLoad.slice(); // clean copy\n                        var loadNext = function loadNext(moduleName) {\n                            moduleCache.push(moduleName);\n                            modulePromises[moduleName] = deferred.promise;\n                            self._loadDependencies(moduleName, localParams).then(function success() {\n                                try {\n                                    justLoaded = [];\n                                    _register(providers, moduleCache, localParams);\n                                } catch (e) {\n                                    self._$log.error(e.message);\n                                    deferred.reject(e);\n                                    return;\n                                }\n\n                                if (modulesToLoad.length > 0) {\n                                    loadNext(modulesToLoad.shift()); // load the next in list\n                                } else {\n                                        deferred.resolve(res); // everything has been loaded, resolve\n                                    }\n                            }, function error(err) {\n                                deferred.reject(err);\n                            });\n                        };\n\n                        // load the first in list\n                        loadNext(modulesToLoad.shift());\n                    } else if (localParams && localParams.name && modulePromises[localParams.name]) {\n                        return modulePromises[localParams.name];\n                    } else {\n                        deferred.resolve();\n                    }\n                    return deferred.promise;\n                },\n\n                /**\n                 * Get the list of required modules/services/... for this module\n                 * @param module\n                 * @returns {Array}\n                 */\n                getRequires: function getRequires(module) {\n                    var requires = [];\n                    angular.forEach(module.requires, function (requireModule) {\n                        if (regModules.indexOf(requireModule) === -1) {\n                            requires.push(requireModule);\n                        }\n                    });\n                    return requires;\n                },\n\n                /**\n                 * Invoke the new modules & component by their providers\n                 * @param providers\n                 * @param queue\n                 * @param moduleName\n                 * @param reconfig\n                 * @private\n                 */\n                _invokeQueue: _invokeQueue,\n\n                /**\n                 * Check if a module has been invoked and registers it if not\n                 * @param args\n                 * @param moduleName\n                 * @returns {boolean} is new\n                 */\n                _registerInvokeList: _registerInvokeList,\n\n                /**\n                 * Register a new module and loads it, executing the run/config blocks if needed\n                 * @param providers\n                 * @param registerModules\n                 * @param params\n                 * @private\n                 */\n                _register: _register,\n\n                /**\n                 * Add a module name to the list of modules that will be loaded in the next inject\n                 * @param name\n                 * @param force\n                 * @private\n                 */\n                _addToLoadList: _addToLoadList,\n\n                /**\n                 * Unregister modules (you shouldn't have to use this)\n                 * @param modules\n                 */\n                _unregister: function _unregister(modules) {\n                    if (angular.isDefined(modules)) {\n                        if (angular.isArray(modules)) {\n                            angular.forEach(modules, function (module) {\n                                regInvokes[module] = undefined;\n                            });\n                        }\n                    }\n                }\n            };\n        }];\n\n        // Let's get the list of loaded modules & components\n        this._init(angular.element(window.document));\n    }]);\n\n    var bootstrapFct = angular.bootstrap;\n    angular.bootstrap = function (element, modules, config) {\n        // we use slice to make a clean copy\n        angular.forEach(modules.slice(), function (module) {\n            _addToLoadList(module, true, true);\n        });\n        return bootstrapFct(element, modules, config);\n    };\n\n    var _addToLoadList = function _addToLoadList(name, force, real) {\n        if ((recordDeclarations.length > 0 || force) && angular.isString(name) && modulesToLoad.indexOf(name) === -1) {\n            modulesToLoad.push(name);\n            if (real) {\n                realModules.push(name);\n            }\n        }\n    };\n\n    var ngModuleFct = angular.module;\n    angular.module = function (name, requires, configFn) {\n        _addToLoadList(name, false, true);\n        return ngModuleFct(name, requires, configFn);\n    };\n\n    // CommonJS package manager support:\n    if (typeof module !== 'undefined' && typeof exports !== 'undefined' && module.exports === exports) {\n        module.exports = 'oc.lazyLoad';\n    }\n})(angular, window);\n(function (angular) {\n    'use strict';\n\n    angular.module('oc.lazyLoad').directive('ocLazyLoad', [\"$ocLazyLoad\", \"$compile\", \"$animate\", \"$parse\", \"$timeout\", function ($ocLazyLoad, $compile, $animate, $parse, $timeout) {\n        return {\n            restrict: 'A',\n            terminal: true,\n            priority: 1000,\n            compile: function compile(element, attrs) {\n                // we store the content and remove it before compilation\n                var content = element[0].innerHTML;\n                element.html('');\n\n                return function ($scope, $element, $attr) {\n                    var model = $parse($attr.ocLazyLoad);\n                    $scope.$watch(function () {\n                        return model($scope) || $attr.ocLazyLoad; // it can be a module name (string), an object, an array, or a scope reference to any of this\n                    }, function (moduleName) {\n                        if (angular.isDefined(moduleName)) {\n                            $ocLazyLoad.load(moduleName).then(function () {\n                                // Attach element contents to DOM and then compile them.\n                                // This prevents an issue where IE invalidates saved element objects (HTMLCollections)\n                                // of the compiled contents when attaching to the parent DOM.\n                                $animate.enter(content, $element);\n                                // get the new content & compile it\n                                $compile($element.contents())($scope);\n                            });\n                        }\n                    }, true);\n                };\n            }\n        };\n    }]);\n})(angular);\n(function (angular) {\n    'use strict';\n\n    angular.module('oc.lazyLoad').config([\"$provide\", function ($provide) {\n        $provide.decorator('$ocLazyLoad', [\"$delegate\", \"$q\", \"$window\", \"$interval\", function ($delegate, $q, $window, $interval) {\n            var uaCssChecked = false,\n                useCssLoadPatch = false,\n                anchor = $window.document.getElementsByTagName('head')[0] || $window.document.getElementsByTagName('body')[0];\n\n            /**\r\n             * Load a js/css file\r\n             * @param type\r\n             * @param path\r\n             * @param params\r\n             * @returns promise\r\n             */\n            $delegate.buildElement = function buildElement(type, path, params) {\n                var deferred = $q.defer(),\n                    el,\n                    loaded,\n                    filesCache = $delegate._getFilesCache(),\n                    cacheBuster = function cacheBuster(url) {\n                    var dc = new Date().getTime();\n                    if (url.indexOf('?') >= 0) {\n                        if (url.substring(0, url.length - 1) === '&') {\n                            return url + '_dc=' + dc;\n                        }\n                        return url + '&_dc=' + dc;\n                    } else {\n                        return url + '?_dc=' + dc;\n                    }\n                };\n\n                // Store the promise early so the file load can be detected by other parallel lazy loads\n                // (ie: multiple routes on one page) a 'true' value isn't sufficient\n                // as it causes false positive load results.\n                if (angular.isUndefined(filesCache.get(path))) {\n                    filesCache.put(path, deferred.promise);\n                }\n\n                // Switch in case more content types are added later\n                switch (type) {\n                    case 'css':\n                        el = $window.document.createElement('link');\n                        el.type = 'text/css';\n                        el.rel = 'stylesheet';\n                        el.href = params.cache === false ? cacheBuster(path) : path;\n                        break;\n                    case 'js':\n                        el = $window.document.createElement('script');\n                        el.src = params.cache === false ? cacheBuster(path) : path;\n                        break;\n                    default:\n                        filesCache.remove(path);\n                        deferred.reject(new Error('Requested type \"' + type + '\" is not known. Could not inject \"' + path + '\"'));\n                        break;\n                }\n                el.onload = el['onreadystatechange'] = function (e) {\n                    if (el['readyState'] && !/^c|loade/.test(el['readyState']) || loaded) return;\n                    el.onload = el['onreadystatechange'] = null;\n                    loaded = 1;\n                    $delegate._broadcast('ocLazyLoad.fileLoaded', path);\n                    deferred.resolve();\n                };\n                el.onerror = function () {\n                    filesCache.remove(path);\n                    deferred.reject(new Error('Unable to load ' + path));\n                };\n                el.async = params.serie ? 0 : 1;\n\n                var insertBeforeElem = anchor.lastChild;\n                if (params.insertBefore) {\n                    var element = angular.element(angular.isDefined(window.jQuery) ? params.insertBefore : document.querySelector(params.insertBefore));\n                    if (element && element.length > 0) {\n                        insertBeforeElem = element[0];\n                    }\n                }\n                insertBeforeElem.parentNode.insertBefore(el, insertBeforeElem);\n\n                /*\r\n                 The event load or readystatechange doesn't fire in:\r\n                 - iOS < 6       (default mobile browser)\r\n                 - Android < 4.4 (default mobile browser)\r\n                 - Safari < 6    (desktop browser)\r\n                 */\n                if (type == 'css') {\n                    if (!uaCssChecked) {\n                        var ua = $window.navigator.userAgent.toLowerCase();\n\n                        // iOS < 6\n                        if (/iP(hone|od|ad)/.test($window.navigator.platform)) {\n                            var v = $window.navigator.appVersion.match(/OS (\\d+)_(\\d+)_?(\\d+)?/);\n                            var iOSVersion = parseFloat([parseInt(v[1], 10), parseInt(v[2], 10), parseInt(v[3] || 0, 10)].join('.'));\n                            useCssLoadPatch = iOSVersion < 6;\n                        } else if (ua.indexOf(\"android\") > -1) {\n                            // Android < 4.4\n                            var androidVersion = parseFloat(ua.slice(ua.indexOf(\"android\") + 8));\n                            useCssLoadPatch = androidVersion < 4.4;\n                        } else if (ua.indexOf('safari') > -1) {\n                            var versionMatch = ua.match(/version\\/([\\.\\d]+)/i);\n                            useCssLoadPatch = versionMatch && versionMatch[1] && parseFloat(versionMatch[1]) < 6;\n                        }\n                    }\n\n                    if (useCssLoadPatch) {\n                        var tries = 1000; // * 20 = 20000 miliseconds\n                        var interval = $interval(function () {\n                            try {\n                                el.sheet.cssRules;\n                                $interval.cancel(interval);\n                                el.onload();\n                            } catch (e) {\n                                if (--tries <= 0) {\n                                    el.onerror();\n                                }\n                            }\n                        }, 20);\n                    }\n                }\n\n                return deferred.promise;\n            };\n\n            return $delegate;\n        }]);\n    }]);\n})(angular);\n(function (angular) {\n    'use strict';\n\n    angular.module('oc.lazyLoad').config([\"$provide\", function ($provide) {\n        $provide.decorator('$ocLazyLoad', [\"$delegate\", \"$q\", function ($delegate, $q) {\n            /**\r\n             * The function that loads new files\r\n             * @param config\r\n             * @param params\r\n             * @returns {*}\r\n             */\n            $delegate.filesLoader = function filesLoader(config) {\n                var params = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n                var cssFiles = [],\n                    templatesFiles = [],\n                    jsFiles = [],\n                    promises = [],\n                    cachePromise = null,\n                    filesCache = $delegate._getFilesCache();\n\n                $delegate.toggleWatch(true); // start watching angular.module calls\n\n                angular.extend(params, config);\n\n                var pushFile = function pushFile(path) {\n                    var file_type = null,\n                        m;\n                    if (angular.isObject(path)) {\n                        file_type = path.type;\n                        path = path.path;\n                    }\n                    cachePromise = filesCache.get(path);\n                    if (angular.isUndefined(cachePromise) || params.cache === false) {\n\n                        // always check for requirejs syntax just in case\n                        if ((m = /^(css|less|html|htm|js)?(?=!)/.exec(path)) !== null) {\n                            // Detect file type using preceding type declaration (ala requireJS)\n                            file_type = m[1];\n                            path = path.substr(m[1].length + 1, path.length); // Strip the type from the path\n                        }\n\n                        if (!file_type) {\n                            if ((m = /[.](css|less|html|htm|js)?((\\?|#).*)?$/.exec(path)) !== null) {\n                                // Detect file type via file extension\n                                file_type = m[1];\n                            } else if (!$delegate.jsLoader.hasOwnProperty('ocLazyLoadLoader') && $delegate.jsLoader.hasOwnProperty('requirejs')) {\n                                // requirejs\n                                file_type = 'js';\n                            } else {\n                                $delegate._$log.error('File type could not be determined. ' + path);\n                                return;\n                            }\n                        }\n\n                        if ((file_type === 'css' || file_type === 'less') && cssFiles.indexOf(path) === -1) {\n                            cssFiles.push(path);\n                        } else if ((file_type === 'html' || file_type === 'htm') && templatesFiles.indexOf(path) === -1) {\n                            templatesFiles.push(path);\n                        } else if (file_type === 'js' || jsFiles.indexOf(path) === -1) {\n                            jsFiles.push(path);\n                        } else {\n                            $delegate._$log.error('File type is not valid. ' + path);\n                        }\n                    } else if (cachePromise) {\n                        promises.push(cachePromise);\n                    }\n                };\n\n                if (params.serie) {\n                    pushFile(params.files.shift());\n                } else {\n                    angular.forEach(params.files, function (path) {\n                        pushFile(path);\n                    });\n                }\n\n                if (cssFiles.length > 0) {\n                    var cssDeferred = $q.defer();\n                    $delegate.cssLoader(cssFiles, function (err) {\n                        if (angular.isDefined(err) && $delegate.cssLoader.hasOwnProperty('ocLazyLoadLoader')) {\n                            $delegate._$log.error(err);\n                            cssDeferred.reject(err);\n                        } else {\n                            cssDeferred.resolve();\n                        }\n                    }, params);\n                    promises.push(cssDeferred.promise);\n                }\n\n                if (templatesFiles.length > 0) {\n                    var templatesDeferred = $q.defer();\n                    $delegate.templatesLoader(templatesFiles, function (err) {\n                        if (angular.isDefined(err) && $delegate.templatesLoader.hasOwnProperty('ocLazyLoadLoader')) {\n                            $delegate._$log.error(err);\n                            templatesDeferred.reject(err);\n                        } else {\n                            templatesDeferred.resolve();\n                        }\n                    }, params);\n                    promises.push(templatesDeferred.promise);\n                }\n\n                if (jsFiles.length > 0) {\n                    var jsDeferred = $q.defer();\n                    $delegate.jsLoader(jsFiles, function (err) {\n                        if (angular.isDefined(err) && ($delegate.jsLoader.hasOwnProperty(\"ocLazyLoadLoader\") || $delegate.jsLoader.hasOwnProperty(\"requirejs\"))) {\n                            $delegate._$log.error(err);\n                            jsDeferred.reject(err);\n                        } else {\n                            jsDeferred.resolve();\n                        }\n                    }, params);\n                    promises.push(jsDeferred.promise);\n                }\n\n                if (promises.length === 0) {\n                    var deferred = $q.defer(),\n                        err = \"Error: no file to load has been found, if you're trying to load an existing module you should use the 'inject' method instead of 'load'.\";\n                    $delegate._$log.error(err);\n                    deferred.reject(err);\n                    return deferred.promise;\n                } else if (params.serie && params.files.length > 0) {\n                    return $q.all(promises).then(function () {\n                        return $delegate.filesLoader(config, params);\n                    });\n                } else {\n                    return $q.all(promises)['finally'](function (res) {\n                        $delegate.toggleWatch(false); // stop watching angular.module calls\n                        return res;\n                    });\n                }\n            };\n\n            /**\r\n             * Load a module or a list of modules into Angular\r\n             * @param module Mixed the name of a predefined module config object, or a module config object, or an array of either\r\n             * @param params Object optional parameters\r\n             * @returns promise\r\n             */\n            $delegate.load = function (originalModule) {\n                var originalParams = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n                var self = this,\n                    config = null,\n                    deferredList = [],\n                    deferred = $q.defer(),\n                    errText;\n\n                // clean copy\n                var module = angular.copy(originalModule);\n                var params = angular.copy(originalParams);\n\n                // If module is an array, break it down\n                if (angular.isArray(module)) {\n                    // Resubmit each entry as a single module\n                    angular.forEach(module, function (m) {\n                        deferredList.push(self.load(m, params));\n                    });\n\n                    // Resolve the promise once everything has loaded\n                    $q.all(deferredList).then(function (res) {\n                        deferred.resolve(res);\n                    }, function (err) {\n                        deferred.reject(err);\n                    });\n\n                    return deferred.promise;\n                }\n\n                // Get or Set a configuration depending on what was passed in\n                if (angular.isString(module)) {\n                    config = self.getModuleConfig(module);\n                    if (!config) {\n                        config = {\n                            files: [module]\n                        };\n                    }\n                } else if (angular.isObject(module)) {\n                    // case {type: 'js', path: lazyLoadUrl + 'testModule.fakejs'}\n                    if (angular.isDefined(module.path) && angular.isDefined(module.type)) {\n                        config = {\n                            files: [module]\n                        };\n                    } else {\n                        config = self.setModuleConfig(module);\n                    }\n                }\n\n                if (config === null) {\n                    var moduleName = self._getModuleName(module);\n                    errText = 'Module \"' + (moduleName || 'unknown') + '\" is not configured, cannot load.';\n                    $delegate._$log.error(errText);\n                    deferred.reject(new Error(errText));\n                    return deferred.promise;\n                } else {\n                    // deprecated\n                    if (angular.isDefined(config.template)) {\n                        if (angular.isUndefined(config.files)) {\n                            config.files = [];\n                        }\n                        if (angular.isString(config.template)) {\n                            config.files.push(config.template);\n                        } else if (angular.isArray(config.template)) {\n                            config.files.concat(config.template);\n                        }\n                    }\n                }\n\n                var localParams = angular.extend({}, params, config);\n\n                // if someone used an external loader and called the load function with just the module name\n                if (angular.isUndefined(config.files) && angular.isDefined(config.name) && $delegate.moduleExists(config.name)) {\n                    return $delegate.inject(config.name, localParams, true);\n                }\n\n                $delegate.filesLoader(config, localParams).then(function () {\n                    $delegate.inject(null, localParams).then(function (res) {\n                        deferred.resolve(res);\n                    }, function (err) {\n                        deferred.reject(err);\n                    });\n                }, function (err) {\n                    deferred.reject(err);\n                });\n\n                return deferred.promise;\n            };\n\n            // return the patched service\n            return $delegate;\n        }]);\n    }]);\n})(angular);\n(function (angular) {\n    'use strict';\n\n    angular.module('oc.lazyLoad').config([\"$provide\", function ($provide) {\n        $provide.decorator('$ocLazyLoad', [\"$delegate\", \"$q\", function ($delegate, $q) {\n            /**\n             * cssLoader function\n             * @type Function\n             * @param paths array list of css files to load\n             * @param callback to call when everything is loaded. We use a callback and not a promise\n             * @param params object config parameters\n             * because the user can overwrite cssLoader and it will probably not use promises :(\n             */\n            $delegate.cssLoader = function (paths, callback, params) {\n                var promises = [];\n                angular.forEach(paths, function (path) {\n                    promises.push($delegate.buildElement('css', path, params));\n                });\n                $q.all(promises).then(function () {\n                    callback();\n                }, function (err) {\n                    callback(err);\n                });\n            };\n            $delegate.cssLoader.ocLazyLoadLoader = true;\n\n            return $delegate;\n        }]);\n    }]);\n})(angular);\n(function (angular) {\n    'use strict';\n\n    angular.module('oc.lazyLoad').config([\"$provide\", function ($provide) {\n        $provide.decorator('$ocLazyLoad', [\"$delegate\", \"$q\", function ($delegate, $q) {\n            /**\n             * jsLoader function\n             * @type Function\n             * @param paths array list of js files to load\n             * @param callback to call when everything is loaded. We use a callback and not a promise\n             * @param params object config parameters\n             * because the user can overwrite jsLoader and it will probably not use promises :(\n             */\n            $delegate.jsLoader = function (paths, callback, params) {\n                var promises = [];\n                angular.forEach(paths, function (path) {\n                    promises.push($delegate.buildElement('js', path, params));\n                });\n                $q.all(promises).then(function () {\n                    callback();\n                }, function (err) {\n                    callback(err);\n                });\n            };\n            $delegate.jsLoader.ocLazyLoadLoader = true;\n\n            return $delegate;\n        }]);\n    }]);\n})(angular);\n(function (angular) {\n    'use strict';\n\n    angular.module('oc.lazyLoad').config([\"$provide\", function ($provide) {\n        $provide.decorator('$ocLazyLoad', [\"$delegate\", \"$templateCache\", \"$q\", \"$http\", function ($delegate, $templateCache, $q, $http) {\n            /**\n             * templatesLoader function\n             * @type Function\n             * @param paths array list of css files to load\n             * @param callback to call when everything is loaded. We use a callback and not a promise\n             * @param params object config parameters for $http\n             * because the user can overwrite templatesLoader and it will probably not use promises :(\n             */\n            $delegate.templatesLoader = function (paths, callback, params) {\n                var promises = [],\n                    filesCache = $delegate._getFilesCache();\n\n                angular.forEach(paths, function (url) {\n                    var deferred = $q.defer();\n                    promises.push(deferred.promise);\n                    $http.get(url, params).success(function (data) {\n                        if (angular.isString(data) && data.length > 0) {\n                            angular.forEach(angular.element(data), function (node) {\n                                if (node.nodeName === 'SCRIPT' && node.type === 'text/ng-template') {\n                                    $templateCache.put(node.id, node.innerHTML);\n                                }\n                            });\n                        }\n                        if (angular.isUndefined(filesCache.get(url))) {\n                            filesCache.put(url, true);\n                        }\n                        deferred.resolve();\n                    }).error(function (err) {\n                        deferred.reject(new Error('Unable to load template file \"' + url + '\": ' + err));\n                    });\n                });\n                return $q.all(promises).then(function () {\n                    callback();\n                }, function (err) {\n                    callback(err);\n                });\n            };\n            $delegate.templatesLoader.ocLazyLoadLoader = true;\n\n            return $delegate;\n        }]);\n    }]);\n})(angular);\n// Array.indexOf polyfill for IE8\nif (!Array.prototype.indexOf) {\n    Array.prototype.indexOf = function (searchElement, fromIndex) {\n        var k;\n\n        // 1. Let O be the result of calling ToObject passing\n        //    the this value as the argument.\n        if (this == null) {\n            throw new TypeError('\"this\" is null or not defined');\n        }\n\n        var O = Object(this);\n\n        // 2. Let lenValue be the result of calling the Get\n        //    internal method of O with the argument \"length\".\n        // 3. Let len be ToUint32(lenValue).\n        var len = O.length >>> 0;\n\n        // 4. If len is 0, return -1.\n        if (len === 0) {\n            return -1;\n        }\n\n        // 5. If argument fromIndex was passed let n be\n        //    ToInteger(fromIndex); else let n be 0.\n        var n = +fromIndex || 0;\n\n        if (Math.abs(n) === Infinity) {\n            n = 0;\n        }\n\n        // 6. If n >= len, return -1.\n        if (n >= len) {\n            return -1;\n        }\n\n        // 7. If n >= 0, then Let k be n.\n        // 8. Else, n<0, Let k be len - abs(n).\n        //    If k is less than 0, then let k be 0.\n        k = Math.max(n >= 0 ? n : len - Math.abs(n), 0);\n\n        // 9. Repeat, while k < len\n        while (k < len) {\n            // a. Let Pk be ToString(k).\n            //   This is implicit for LHS operands of the in operator\n            // b. Let kPresent be the result of calling the\n            //    HasProperty internal method of O with argument Pk.\n            //   This step can be combined with c\n            // c. If kPresent is true, then\n            //    i.  Let elementK be the result of calling the Get\n            //        internal method of O with the argument ToString(k).\n            //   ii.  Let same be the result of applying the\n            //        Strict Equality Comparison Algorithm to\n            //        searchElement and elementK.\n            //  iii.  If same is true, return k.\n            if (k in O && O[k] === searchElement) {\n                return k;\n            }\n            k++;\n        }\n        return -1;\n    };\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/oclazyload/dist/ocLazyLoad.js\n// module id = 15\n// module chunks = 0","/**\r\n * @author Created by taoyong\r\n * @Date  on 2016/9/1.\r\n */\r\nimport insertTpl from './insert/insert.html';\r\nimport Configs from './config';\r\nimport tokenRefreshInterceptor, { setAuthFailedBehavior, setRefreshTokenUrl } from 'ccms-sdk/interceptors/token-refresh-interceptor';\r\nsetRefreshTokenUrl(Configs.passport + '/credentials/refresh');\r\nsetAuthFailedBehavior(() => {\r\n  if (__pro__) {\r\n    location.replace('/portal/timeout.html');\r\n  } else {\r\n    location.replace('/portal/login.html');\r\n  }\r\n});\r\n\r\nexport default function appRouter($projectProvider, $httpProvider) {\r\n  $httpProvider.defaults.withCredentials = true;\r\n  // interceptor\r\n  $httpProvider.interceptors.push(() => tokenRefreshInterceptor);\r\n\r\n  // 401\r\n  $httpProvider.interceptors.push(['$q', function($q) {\r\n    return {\r\n      responseError: function(response) {\r\n        if (response.status === 401) {\r\n          if (__pro__) {\r\n            location.replace('/portal/timeout.html');\r\n          } else {\r\n            location.replace('/portal/login.html');\r\n          }\r\n        };\r\n        return $q.reject(response);\r\n      }\r\n    };\r\n  }]);\r\n\r\n  Object.freeze($httpProvider);\r\n\r\n  $projectProvider\r\n    .state('ebm', {\r\n      url: '/ebm',\r\n      templateUrl: '/ebm/index.html?_=' + TimeTemp\r\n    })\r\n    .state('wxcrm', {\r\n      url: '/wxcrm',\r\n      templateUrl: '/wxcrm-web/index.html?_=' + TimeTemp\r\n    })\r\n    .state('branding', {\r\n      url: '/branding',\r\n      templateUrl: '/branding/index.html?_=' + TimeTemp\r\n    })\r\n    .state('customer', {\r\n      url: '/customer',\r\n      templateUrl: '/customer/index.html?_=' + TimeTemp\r\n    })\r\n    .state('insert', {\r\n      url: '/insert/{context}',\r\n      templateUrl: insertTpl\r\n    }).state('dashboard', {\r\n      url: '/dashboard',\r\n      templateUrl: '/ccms/modules/dashboard/index.html?_=' + TimeTemp\r\n    }).state('campagin', {\r\n      url: '/campagin',\r\n      templateUrl: '/ccms/modules/marketing/index.html?_=' + TimeTemp\r\n    }).state('systemManage', {\r\n      url: '/systemManage',\r\n      templateUrl: '/ccms/modules/systemManage/index.html?_=' + TimeTemp\r\n    }).state('dataManagement', {\r\n      url: '/dataManagement',\r\n      templateUrl: '/ccms/modules/dataManagement/index.html?_=' + TimeTemp\r\n    }).state('benefitManage', {\r\n      url: '/benefitManage',\r\n      templateUrl: '/ccms/modules/benefitManage/index.html?_=' + TimeTemp\r\n    }).state('portlet', {\r\n      url: '/portlet',\r\n      templateUrl: '/portlet/index.html?_=' + TimeTemp\r\n    });\r\n};\r\nappRouter.$inject = ['$projectProvider', '$httpProvider'];\r\n\n\n\n// WEBPACK FOOTER //\n// ./app/router.js","module.exports = __webpack_public_path__ + \"app/insert/insert-11b229793b65674a03b5.html\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/insert/insert.html\n// module id = 17\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.refreshTokenUrl = exports.execAuthFailure = undefined;\nexports.setAuthFailedBehavior = setAuthFailedBehavior;\nexports.setRefreshTokenUrl = setRefreshTokenUrl;\n\nvar _credentials = require('../credentials');\n\nvar _metadata = require('./metadata');\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; } /**\n                                                                                                                                                                                                                   * @author Kuitos\n                                                                                                                                                                                                                   * @homepage https://github.com/kuitos/\n                                                                                                                                                                                                                   * @since 2016-09-09\n                                                                                                                                                                                                                   */\n\n\nvar needToRefreshToken = false;\n\nvar execAuthFailure = exports.execAuthFailure = function execAuthFailure() {};\nfunction setAuthFailedBehavior() {\n\tvar fn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : execAuthFailure;\n\n\n\texports.execAuthFailure = execAuthFailure = function execAuthFailure(rejection) {\n\n\t\ttry {\n\t\t\tfn();\n\t\t} finally {\n\t\t\t(0, _credentials.removeRequestCredential)();\n\t\t}\n\n\t\tvar ex = new TypeError('Unauthorized! Credential was expired or had been removed, pls set it before the get action!');\n\t\tconsole.error(ex);\n\n\t\tif (typeof rejection.abort === 'function') {\n\t\t\trejection.abort(ex);\n\t\t} else {\n\t\t\trejection.status = rejection.status || 401;\n\t\t\trejection.statusText = rejection.statusText || 'Unauthorized!';\n\t\t\tvar injector = require('angular-es-utils/injector').default;\n\t\t\treturn injector.get('$q').reject(rejection);\n\t\t}\n\t};\n}\n\nvar refreshTokenUrl = exports.refreshTokenUrl = '';\nfunction setRefreshTokenUrl(url) {\n\texports.refreshTokenUrl = refreshTokenUrl = url;\n\t_metadata.REQUEST_WHITE_LIST.push(url);\n}\n\nexports.default = {\n\trequest: function request(config) {\n\n\t\tvar credential = (0, _credentials.getRequestCredential)();\n\t\t// storage 里的状态有可能已经失效\n\t\tif (!credential) {\n\t\t\treturn execAuthFailure({ config: config });\n\t\t}\n\n\t\tconfig.headers[_metadata.REQUEST_TOKEN_HEADER] = credential.id;\n\n\t\t// 白名单之外的url做校验\n\t\t// TODO 兼容处理,如果拿不到refreshToken说明系统还未升级,则不做刷新token逻辑\n\t\tif (credential.refreshToken && _metadata.REQUEST_WHITE_LIST.indexOf(config.url) === -1) {\n\n\t\t\tvar expireTime = _metadata.Date.parse(credential.expireTime);\n\t\t\tvar now = _metadata.Date.now();\n\n\t\t\t// token失效则直接跳转登录页面\n\t\t\t// token未失效但是可用时长已低于用户会话最短保留时间,则需要刷新token\n\t\t\tif (_metadata.USER_SESSION_AVAILABLE_TIME >= expireTime - now && expireTime - now >= 0) {\n\t\t\t\tneedToRefreshToken = true;\n\t\t\t} else if (expireTime - now < 0) {\n\t\t\t\t// token失效\n\t\t\t\treturn execAuthFailure({ config: config });\n\t\t\t}\n\t\t}\n\n\t\treturn config;\n\t},\n\tresponse: function response(_response) {\n\n\t\t// 如果请求能正常响应,说明 storage 里的状态是存在的,所以这里不做判断\n\t\tvar credential = (0, _credentials.getRequestCredential)();\n\n\t\tvar injector = require('angular-es-utils/injector').default;\n\t\tvar $http = injector.get('$http');\n\t\t// 所有请求结束了才做refreshToken的操作,避免后端因为token被刷新而导致前一请求失败\n\t\tif (needToRefreshToken && $http.pendingRequests.length === 0) {\n\n\t\t\tneedToRefreshToken = false;\n\t\t\t// refresh token\n\t\t\t$http.put(refreshTokenUrl, credential.refreshToken, { headers: _defineProperty({}, _metadata.REQUEST_TOKEN_HEADER, credential.id) }).then(function (response) {\n\t\t\t\t// 更新localStorage中token信息\n\t\t\t\t(0, _credentials.setRequestCredential)(response.data);\n\t\t\t}, execAuthFailure);\n\t\t}\n\n\t\treturn _response;\n\t}\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/ccms-sdk/interceptors/token-refresh-interceptor.js\n// module id = 19\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.getRequestCredential = getRequestCredential;\nexports.setRequestCredential = setRequestCredential;\nexports.removeRequestCredential = removeRequestCredential;\n\nvar _jsCookie = require('js-cookie');\n\nvar _jsCookie2 = _interopRequireDefault(_jsCookie);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar localStorage = window.localStorage; /**\n                                         * @author Kuitos\n                                         * @homepage https://github.com/kuitos/\n                                         * @since 2016-09-29\n                                         */\n\nvar JSON = window.JSON;\n\nvar REQUEST_TOKEN_STORAGE_KEY = 'ccmsRequestCredential';\n\nfunction getRequestCredential() {\n\n\tvar credential = null;\n\t// get credential from cookie when inside an iframe\n\tif (window.self !== window.top) {\n\t\tcredential = _jsCookie2.default.get(REQUEST_TOKEN_STORAGE_KEY) || null;\n\t} else {\n\t\tcredential = localStorage.getItem(REQUEST_TOKEN_STORAGE_KEY) || null;\n\t}\n\n\treturn JSON.parse(credential);\n}\n\nfunction setRequestCredential(credential) {\n\tlocalStorage.setItem(REQUEST_TOKEN_STORAGE_KEY, JSON.stringify(credential));\n}\n\nfunction removeRequestCredential() {\n\tlocalStorage.removeItem(REQUEST_TOKEN_STORAGE_KEY);\n\t_jsCookie2.default.remove(REQUEST_TOKEN_STORAGE_KEY);\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/ccms-sdk/credentials/index.js\n// module id = 20\n// module chunks = 0","/*!\n * JavaScript Cookie v2.1.3\n * https://github.com/js-cookie/js-cookie\n *\n * Copyright 2006, 2015 Klaus Hartl & Fagner Brack\n * Released under the MIT license\n */\n;(function (factory) {\n\tvar registeredInModuleLoader = false;\n\tif (typeof define === 'function' && define.amd) {\n\t\tdefine(factory);\n\t\tregisteredInModuleLoader = true;\n\t}\n\tif (typeof exports === 'object') {\n\t\tmodule.exports = factory();\n\t\tregisteredInModuleLoader = true;\n\t}\n\tif (!registeredInModuleLoader) {\n\t\tvar OldCookies = window.Cookies;\n\t\tvar api = window.Cookies = factory();\n\t\tapi.noConflict = function () {\n\t\t\twindow.Cookies = OldCookies;\n\t\t\treturn api;\n\t\t};\n\t}\n}(function () {\n\tfunction extend () {\n\t\tvar i = 0;\n\t\tvar result = {};\n\t\tfor (; i < arguments.length; i++) {\n\t\t\tvar attributes = arguments[ i ];\n\t\t\tfor (var key in attributes) {\n\t\t\t\tresult[key] = attributes[key];\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tfunction init (converter) {\n\t\tfunction api (key, value, attributes) {\n\t\t\tvar result;\n\t\t\tif (typeof document === 'undefined') {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Write\n\n\t\t\tif (arguments.length > 1) {\n\t\t\t\tattributes = extend({\n\t\t\t\t\tpath: '/'\n\t\t\t\t}, api.defaults, attributes);\n\n\t\t\t\tif (typeof attributes.expires === 'number') {\n\t\t\t\t\tvar expires = new Date();\n\t\t\t\t\texpires.setMilliseconds(expires.getMilliseconds() + attributes.expires * 864e+5);\n\t\t\t\t\tattributes.expires = expires;\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\tresult = JSON.stringify(value);\n\t\t\t\t\tif (/^[\\{\\[]/.test(result)) {\n\t\t\t\t\t\tvalue = result;\n\t\t\t\t\t}\n\t\t\t\t} catch (e) {}\n\n\t\t\t\tif (!converter.write) {\n\t\t\t\t\tvalue = encodeURIComponent(String(value))\n\t\t\t\t\t\t.replace(/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g, decodeURIComponent);\n\t\t\t\t} else {\n\t\t\t\t\tvalue = converter.write(value, key);\n\t\t\t\t}\n\n\t\t\t\tkey = encodeURIComponent(String(key));\n\t\t\t\tkey = key.replace(/%(23|24|26|2B|5E|60|7C)/g, decodeURIComponent);\n\t\t\t\tkey = key.replace(/[\\(\\)]/g, escape);\n\n\t\t\t\treturn (document.cookie = [\n\t\t\t\t\tkey, '=', value,\n\t\t\t\t\tattributes.expires ? '; expires=' + attributes.expires.toUTCString() : '', // use expires attribute, max-age is not supported by IE\n\t\t\t\t\tattributes.path ? '; path=' + attributes.path : '',\n\t\t\t\t\tattributes.domain ? '; domain=' + attributes.domain : '',\n\t\t\t\t\tattributes.secure ? '; secure' : ''\n\t\t\t\t].join(''));\n\t\t\t}\n\n\t\t\t// Read\n\n\t\t\tif (!key) {\n\t\t\t\tresult = {};\n\t\t\t}\n\n\t\t\t// To prevent the for loop in the first place assign an empty array\n\t\t\t// in case there are no cookies at all. Also prevents odd result when\n\t\t\t// calling \"get()\"\n\t\t\tvar cookies = document.cookie ? document.cookie.split('; ') : [];\n\t\t\tvar rdecode = /(%[0-9A-Z]{2})+/g;\n\t\t\tvar i = 0;\n\n\t\t\tfor (; i < cookies.length; i++) {\n\t\t\t\tvar parts = cookies[i].split('=');\n\t\t\t\tvar cookie = parts.slice(1).join('=');\n\n\t\t\t\tif (cookie.charAt(0) === '\"') {\n\t\t\t\t\tcookie = cookie.slice(1, -1);\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\tvar name = parts[0].replace(rdecode, decodeURIComponent);\n\t\t\t\t\tcookie = converter.read ?\n\t\t\t\t\t\tconverter.read(cookie, name) : converter(cookie, name) ||\n\t\t\t\t\t\tcookie.replace(rdecode, decodeURIComponent);\n\n\t\t\t\t\tif (this.json) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tcookie = JSON.parse(cookie);\n\t\t\t\t\t\t} catch (e) {}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (key === name) {\n\t\t\t\t\t\tresult = cookie;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!key) {\n\t\t\t\t\t\tresult[name] = cookie;\n\t\t\t\t\t}\n\t\t\t\t} catch (e) {}\n\t\t\t}\n\n\t\t\treturn result;\n\t\t}\n\n\t\tapi.set = api;\n\t\tapi.get = function (key) {\n\t\t\treturn api.call(api, key);\n\t\t};\n\t\tapi.getJSON = function () {\n\t\t\treturn api.apply({\n\t\t\t\tjson: true\n\t\t\t}, [].slice.call(arguments));\n\t\t};\n\t\tapi.defaults = {};\n\n\t\tapi.remove = function (key, attributes) {\n\t\t\tapi(key, '', extend(attributes, {\n\t\t\t\texpires: -1\n\t\t\t}));\n\t\t};\n\n\t\tapi.withConverter = init;\n\n\t\treturn api;\n\t}\n\n\treturn init(function () {});\n}));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/js-cookie/src/js.cookie.js\n// module id = 21\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * @author qix\n * @homepage https://github.com/qixman/\n * @since 2016-10-21\n */\n\nvar Date = exports.Date = window.Date;\nvar REQUEST_TOKEN_HEADER = exports.REQUEST_TOKEN_HEADER = 'X-TOKEN';\nvar USER_SESSION_AVAILABLE_TIME = exports.USER_SESSION_AVAILABLE_TIME = 30 * 60 * 1000;\nvar REQUEST_WHITE_LIST = exports.REQUEST_WHITE_LIST = [];\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/ccms-sdk/interceptors/metadata.js\n// module id = 22\n// module chunks = 0","/*\r\n * @author Created by taoyong\r\n * @time Created on 16/5/24.\r\n */\r\nimport angular from 'angular';\r\nimport menu from './menu';\r\n\r\nexport default angular.module('common.directive', [menu]).name;\r\n\n\n\n// WEBPACK FOOTER //\n// ./components/index.js","/*\r\n * @author Created by taoyong\r\n * @time Created on 16/5/24.\r\n */\r\nimport './menu.scss';\r\nimport angular from 'angular';\r\nimport menuComponent from './directive';\r\n\r\nexport default angular.module('common.directive.menu', [])\r\n  .run(['$rootScope', function($rootScope) {\r\n    var execValue = /([^-.]+)\\.(ccms|s1|minicrm)\\./.exec(location.hostname);\r\n    var hostName = (execValue && execValue[1]) || 'yangyangyang3';\r\n    $rootScope.tenantId = window.sessionStorage.getItem('tenantId');\r\n    $rootScope.hostName = hostName;\r\n  }])\r\n  .config(['$httpProvider', function($httpProvider) {\r\n    $httpProvider.defaults.useXDomain = true;\r\n    delete $httpProvider.defaults.headers.common['X-Requested-with'];\r\n  }])\r\n  .component('menus', menuComponent).name;\r\n\r\n\r\n\n\n\n// WEBPACK FOOTER //\n// ./components/menu/index.js","/*\r\n * @author Created by taoyong\r\n * @time Created on 16/5/24.\r\n */\r\nimport templateUrl from './menu.html';\r\nimport controller from './controller';\r\n\r\nexport default {\r\n  templateUrl,\r\n  controller,\r\n  controllerAs: '$menuCtrl'\r\n};\r\n\n\n\n// WEBPACK FOOTER //\n// ./components/menu/directive.js","module.exports = __webpack_public_path__ + \"components/menu/menu-f3f8c360beb898da4c02.html\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./components/menu/menu.html\n// module id = 29\n// module chunks = 0","/*\r\n * @author Created by taoyong\r\n * @time Created on 16/5/24.\r\n */\r\nimport angular from 'angular';\r\nimport Service from './service';\r\nimport collectTpl from './template/collectPerInfo.html';\r\nimport collectCtrl from './template/collectPerCtrl';\r\nimport passpwordTpl from './template/password.html';\r\nimport passwordCtrl from './template/passwordCtrl';\r\nimport messageTpl from './template/message.html';\r\nimport messageCtrl from './template/messageCtrl';\r\nimport utils from './../../common/utils.js';\r\nimport Configs from '../../app/config.js';\r\n\r\nexport default class MenuCtrl {\r\n  constructor($http, $location, $rootScope, $timeout, $q, $interval, $ccModal, $ccValidator, $ccTips) {\r\n    const _this = this;\r\n    $rootScope.shuyunLoginUrl = '';\r\n    _this.shopInfoDefer = $q.defer();\r\n    $rootScope.user = _this.user = {\r\n      'name': _this.userName,\r\n      'noticeCount': 58,\r\n      'id': _this.useID\r\n    };\r\n    // 发送_ati给予淘宝日志\r\n    Service.getAti({}, function() {\r\n      // doing\r\n    });\r\n\r\n    // 检查是否到期\r\n    Service.getShopInfo({}, function(data) {\r\n      $rootScope.ccmsVersion = data.version_code;\r\n      _this.shopInfoDefer.resolve();\r\n      if (data.overdue) {\r\n        _this.isExpire = true;\r\n      }\r\n      /* 得到个性化营销的number tip */\r\n      Service.getNumber({}, function(data) {\r\n        _this.unionMarketingNumberShow = ((data.count) * 1) || false;\r\n        _this.unionMarketingNumber = ((data.count) * 1) > 100 ? 99 : data.count;\r\n      }, function(err) {\r\n        _this.unionMarketingNumberShow = false;\r\n        return err;\r\n      });\r\n    }, angular.noop);\r\n\r\n    // 检验登入\r\n    function checkLogin() {\r\n      Service.checkLogin({}, function(data) {\r\n        // 借用此接口获取下用户\r\n        if (data.expired) { // true 需要登录\r\n          var loginUrl;\r\n          if (__pro__) {\r\n            loginUrl = '/portal/timeout.html';\r\n          } else {\r\n            loginUrl = '/portal/login.html';\r\n          }\r\n          location.replace(loginUrl);\r\n        } else {\r\n          _this.userName = data.username;\r\n          _this.useID = data.userId;\r\n          _this.campUserName = data.username;\r\n          _this.user.name = _this.userName;\r\n          _this.user.id = _this.useID;\r\n          $rootScope.tenantId = data.tenantId;\r\n          window.sessionStorage.setItem('tenantId', data.tenantId);\r\n          fetchMenu();\r\n          getContactAjaxMethod();\r\n          _this.getAccountLink();\r\n        }\r\n      }, function(data) {\r\n        var loginUrl;\r\n        if (__pro__) {\r\n          loginUrl = '/portal/timeout.html';\r\n        } else {\r\n          loginUrl = '/portal/login.html';\r\n        }\r\n        location.replace(loginUrl);\r\n      });\r\n    }\r\n\r\n    checkLogin();\r\n\r\n    // 退出账户\r\n    var clearStorage = function() {\r\n      window.sessionStorage.removeItem('shuyunSessionMenu');\r\n      window.sessionStorage.removeItem('shuYunMenuHelp');\r\n      window.sessionStorage.removeItem('shuYunSSOlink');\r\n      window.sessionStorage.removeItem('shuyunAccountLink');\r\n      window.sessionStorage.removeItem('shuyunContact');\r\n    };\r\n    _this.logout = function() {\r\n      var modalInstance = $ccModal.confirm('确认退出该用户？');\r\n      modalInstance.open().result.then(() => {\r\n        Service.logOut({}, function() {\r\n          clearStorage();\r\n          if (__pro__) {\r\n            location.replace('/portal/loginout.html');\r\n          } else {\r\n            location.replace('/portal/login.html');\r\n          }\r\n        }, angular.noop);\r\n      });\r\n    };\r\n    // 修改密码\r\n    _this.changePassword = function() {\r\n      $ccModal\r\n        .modal({\r\n          title: '修改密码',\r\n          locals: {\r\n            data: [1, 2, 3]\r\n          },\r\n          style: {\r\n            'min-height': '140px',\r\n            'min-width': '630px'\r\n          },\r\n          body: passpwordTpl,\r\n          controller: passwordCtrl,\r\n          controllerAs: 'passWordModal',\r\n          bindings: true\r\n        })\r\n        .open();\r\n    };\r\n\r\n    function fetchMenu() {\r\n      var navAry = [];\r\n      var appSeeionMenu = angular.fromJson(sessionStorage.getItem('shuyunSessionMenu')); //  '获取菜单缓存'\r\n      if (appSeeionMenu) {\r\n        getSessionMenu(appSeeionMenu);\r\n      } else {\r\n        Service.checkVisit({\r\n          hostName: $rootScope.hostName,\r\n          tenantId: $rootScope.tenantId\r\n        }, function(data) {\r\n          angular.forEach(data.children, function(n) {\r\n            n.url = root + n.url;\r\n            navAry.push(n);\r\n          });\r\n          _this.user.nav = navAry;\r\n          var stringData = JSON.stringify({\r\n            menuData: _this.user.nav.slice()\r\n          });\r\n          setTimeout(function() {\r\n            utils.setNavFunction();\r\n          }, 0);\r\n          sessionStorage.setItem('shuyunSessionMenu', stringData);\r\n        }, function() {\r\n\r\n        });\r\n      }\r\n    }\r\n\r\n    function getSessionMenu(data) {\r\n      var appSeeionMenu = data;\r\n      _this.user.nav = appSeeionMenu.menuData.slice();\r\n      setTimeout(function() {\r\n        utils.setNavFunction();\r\n      }, 0);\r\n    }\r\n\r\n    /* start 是否已经有联系方式 */\r\n    var getContactAjaxMethod = function() {\r\n      var shuyunContact = window.sessionStorage.getItem('shuyunContact');\r\n      if (shuyunContact) {\r\n        var response = JSON.parse(shuyunContact);\r\n        if (response.exists) {\r\n          _this.addPerInfoFlag = false;\r\n          _this.contactLiFlag = true;\r\n          _this.contactName = response.contact.fullName;\r\n          _this.contactQQ = response.contact.qq;\r\n          _this.contactPhone = response.contact.mobile;\r\n          _this.contactWW = response.contact.wangwang;\r\n          _this.contactEmail = response.contact.email;\r\n          _this.contactWeibo = response.contact.weibo;\r\n        } else {\r\n          _this.addPerInfoFlag = true;\r\n          _this.contactLiFlag = false;\r\n          _this.contactName = '';\r\n          _this.contactQQ = '';\r\n          _this.contactPhone = '';\r\n          _this.contactWW = '';\r\n          _this.contactEmail = '';\r\n          _this.contactWeibo = '';\r\n        }\r\n      } else {\r\n        $http.get(Configs.webDashboard + '/dashboard/assemble/contact/exists/?tenantId=' + $rootScope.tenantId).success(function(response) {\r\n          var Stringres = JSON.stringify(response);\r\n          window.sessionStorage.setItem('shuyunContact', Stringres);\r\n          if (response.exists) {\r\n            _this.addPerInfoFlag = false;\r\n            _this.contactLiFlag = true;\r\n            _this.contactName = response.contact.fullName;\r\n            _this.contactQQ = response.contact.qq;\r\n            _this.contactPhone = response.contact.mobile;\r\n            _this.contactWW = response.contact.wangwang;\r\n            _this.contactEmail = response.contact.email;\r\n            _this.contactWeibo = response.contact.weibo;\r\n          } else {\r\n            _this.addPerInfoFlag = true;\r\n            _this.contactLiFlag = false;\r\n            _this.contactName = '';\r\n            _this.contactQQ = '';\r\n            _this.contactPhone = '';\r\n            _this.contactWW = '';\r\n            _this.contactEmail = '';\r\n            _this.contactWeibo = '';\r\n          }\r\n        });\r\n      }\r\n    };\r\n    /* end 是否已经有联系方式 */\r\n\r\n    _this.getContactInfo = function() { // 查看联系人信息\r\n      getContactAjaxMethod();\r\n    };\r\n\r\n    _this.cancelAddInfo = function() { // 关闭提示\r\n      _this.addPerInfoFlag = false;\r\n    };\r\n\r\n    _this.viewAddPerPop = function() { // 弹出信息框\r\n      var modalInstance = $ccModal\r\n        .modal({\r\n          title: '填写联系人信息',\r\n          style: {\r\n            'min-height': '240px'\r\n          },\r\n          body: collectTpl,\r\n          controller: collectCtrl,\r\n          controllerAs: 'collectModal',\r\n          bindings: true\r\n        })\r\n        .open();\r\n\r\n      modalInstance.result.then(function(v) {\r\n        _this.addPerInfoFlag = false;\r\n        _this.contactLiFlag = true;\r\n      }, function(v) {\r\n\r\n      });\r\n    };\r\n\r\n    // 获取帮助更多链接\r\n    _this.getHelpLink = function() {\r\n      $http.get(Configs.webDashboard + '/dashboard/assemble/helplink/').success(function(response) {\r\n        _this.helplink = response.url;\r\n        window.open(_this.helplink);\r\n      }).error(function(data, status, headers, config) {\r\n        if (data.message) {\r\n          $ccTips.error(data.message, document.querySelector('.content'));\r\n        }\r\n      });\r\n    };\r\n    // 单点登录\r\n    _this.SSOlinkyes = false;\r\n    _this.get5xLink = function() {\r\n      var shuYunSSOlink = window.sessionStorage.getItem('shuYunSSOlink');\r\n      if (shuYunSSOlink) {\r\n        _this.SSOlink = shuYunSSOlink;\r\n        _this.SSOlinkyes = true;\r\n      } else {\r\n        $http.get(Configs.webDashboard + '/dashboard/sso/directive/').success(function(resoponse) {\r\n          if (resoponse) {\r\n            _this.SSOlink = resoponse.url;\r\n            _this.SSOlinkyes = true;\r\n            window.sessionStorage.setItem('shuYunSSOlink', resoponse.url);\r\n          }\r\n        }).error(function(data, status, headers, config) {\r\n          if (data.message) {\r\n            $ccTips.error(data.message, document.querySelector('.content'));\r\n          }\r\n        });\r\n      }\r\n    };\r\n    _this.get5xLink();\r\n\r\n    // 获取账户信息链接\r\n    _this.getAccountLink = function() {\r\n      var accountlink = window.sessionStorage.getItem('shuyunAccountLink');\r\n      if (accountlink) {\r\n        _this.accountLink = accountlink;\r\n      } else {\r\n        $http.get(Configs.webDashboard + '/dashboard/channel/accountlink/?tenantId=' + $rootScope.tenantId).success(function(response) {\r\n          _this.accountLink = response.url;\r\n          window.sessionStorage.setItem('shuyunAccountLink', response.url);\r\n        }).error(function(data, status, headers, config) {\r\n          if (data.message) {\r\n            $ccTips.error(data.message, document.querySelector('.content'));\r\n          }\r\n        });\r\n      };\r\n    };\r\n\r\n    // 嵌入模板之间相互切换 操作\r\n    $rootScope.resertTemplateClickFlag = true;\r\n    _this.disponseTitleALink = function(data) { //  菜单$watch 和嵌入模板click();\r\n      if (data.indexOf('callcenter') !== -1) {\r\n        return 'javascript:void(0)';\r\n      };\r\n\r\n      if (data.indexOf('insert') === -1) {\r\n        return data;\r\n      } else {\r\n        return 'javascript:void(0)';\r\n      }\r\n    };\r\n\r\n    _this.appOrigin = location.protocol + '// ' + location.host; //  获取绝对路径http\r\n    _this.appRoot = root;\r\n\r\n    _this.insertCompileLocation = function(url) {\r\n      $rootScope.resertTemplateClickFlag = false;\r\n      if (url.indexOf('callcenter') !== -1) { //  电话模块在新页面操作\r\n        var newUrl = url.substring(8);\r\n        window.open(newUrl);\r\n        return false;\r\n      }\r\n\r\n      if (url.indexOf('insert') !== -1) {\r\n        window.location.href = _this.appOrigin + url;\r\n        if (window.location.href.indexOf('insert') !== -1) {\r\n          window.location.reload();\r\n        }\r\n      }\r\n    };\r\n\r\n    // 弹出更多的弹出框\r\n    _this.showMoreMessageDialog = function() {\r\n      $ccModal\r\n        .modal({\r\n          title: '系统消息',\r\n          hasFooter: false,\r\n          body: messageTpl,\r\n          style: {\r\n            'min-height': 'auto',\r\n            'max-height': '580px'\r\n          },\r\n          controller: messageCtrl,\r\n          controllerAs: 'messageModal',\r\n          bindings: {\r\n            campUserName: _this.campUserName\r\n          }\r\n        })\r\n        .open();\r\n    };\r\n\r\n    // 获取收件箱信息\r\n    var interProm = null;\r\n    var getMessageStatus = function() {\r\n      var param = {\r\n        'userName': $rootScope.tenantId,\r\n        'ccmsVersion': $rootScope.ccmsVersion\r\n      };\r\n      Service.getStatus(param, function(res) {\r\n        if (res.status) {\r\n          _this.newsTrue = true;\r\n        } else {\r\n          _this.newsTrue = false;\r\n        }\r\n      }, function() {\r\n        interProm && $interval.cancel(interProm);\r\n      });\r\n    };\r\n\r\n    interProm = $interval(function() {\r\n      getMessageStatus();\r\n    }, 60000);\r\n\r\n    _this.shopInfoDefer.promise.then(function() {\r\n      getMessageStatus();\r\n    });\r\n  }\r\n};\r\nMenuCtrl.$inject = ['$http', '$location', '$rootScope', '$timeout', '$q', '$interval', '$ccModal', '$ccValidator', '$ccTips'];\r\n\n\n\n// WEBPACK FOOTER //\n// ./components/menu/controller.js","/*\r\n * @author Created by taoyong\r\n * @time Created on 16/5/24.\r\n */\r\nimport genResource from 'angular-es-utils/rs-generator';\r\nimport Configs from '../../app/config.js';\r\n\r\nexport default {\r\n  checkVisit(param, success, error) {\r\n    const VisitResource = genResource(Configs.webPortal + '/visits', false);\r\n    VisitResource.save(param, success, error);\r\n  },\r\n  checkLogin(param, success, error) {\r\n    const CheckResource = genResource(Configs.webPortal + '/credentials', false);\r\n    CheckResource.get(param, success, error);\r\n  },\r\n  logOut(param, success, error) {\r\n    const LoginResource = genResource(Configs.webPortal + '/loginOut', false);\r\n    LoginResource.delete(param, success, error);\r\n  },\r\n  getShopInfo(param, success, error) {\r\n    const ShopResource = genResource(Configs.webDashboard + '/dashboard/assemble/shopinfo/', false);\r\n    ShopResource.get(param, success, error);\r\n  },\r\n  getNumber(param, success, error) {\r\n    const EbmResource = genResource(Configs.webNode + '/node/edm/cb-service/messages/count/?_=' + new Date().getTime(), false);\r\n    EbmResource.get(param, success, error);\r\n  },\r\n  getNoticesList(param, success, error) {\r\n    const userName = param.userName;\r\n    const ccmsVersion = param.ccmsVersion;\r\n    const pageNo = param.pageNo;\r\n    const timestamp = new Date().getTime();\r\n    const pageSize = param.pageSize || 10;\r\n    const NoticesResource = genResource(Configs.webPortal + '/notification/notice' + '?timestamp=' + timestamp + '&pageSize=' + pageSize + '&pageNo=' + pageNo + '&setId=' + ccmsVersion + '&userName=' + userName, false);\r\n    NoticesResource.get({}, success, error);\r\n  },\r\n  getStatus(param, success, error) {\r\n    const userName = param.userName;\r\n    const ccmsVersion = param.ccmsVersion;\r\n    const StatusResource = genResource(Configs.webPortal + '/notification/status?setId=' + ccmsVersion + '&userName=' + userName, false);\r\n    StatusResource.get({}, success, error);\r\n  },\r\n  postNotice(param, success, error) {\r\n    const userName = param.userName;\r\n    const ccmsVersion = param.ccmsVersion;\r\n    const campUserName = param.campUserName;\r\n    const id = param.id;\r\n    const data = {\r\n      'setId': ccmsVersion,\r\n      'userName': userName,\r\n      'noticeId': id,\r\n      'optName': campUserName\r\n    };\r\n    const NoticeResource = genResource(Configs.webPortal + '/notification/notice/' + id, false);\r\n    NoticeResource.save(data, success, error);\r\n  },\r\n  deleteNotices(param, success, error) {\r\n    const userName = param.userName;\r\n    const ccmsVersion = param.setId;\r\n    const ids = param.ids;\r\n    const NoticeResource = genResource(Configs.webPortal + '/notification/notice?setId=' + ccmsVersion + '&userName=' + userName + '&noticeId=' + ids, false);\r\n    NoticeResource.delete({}, success, error);\r\n  },\r\n  getAti(param, success, error) {\r\n    var ati = '';\r\n    var cookiesAry = document.cookie.split(';');\r\n    cookiesAry.forEach(function(v, i) {\r\n      if (v.indexOf('_ati') !== -1) {\r\n        ati = v.replace(/\\s/g, '').substr(5);\r\n      }\r\n    });\r\n    const ShopResource = genResource(Configs.webDashboard + '/dashboard/assemble/setLoginLog?ati=' + ati, false);\r\n    ShopResource.get(param, success, error);\r\n  }\r\n};\r\n\n\n\n// WEBPACK FOOTER //\n// ./components/menu/service.js","module.exports = __webpack_public_path__ + \"components/menu/template/collectPerInfo-c2a7c48a6d14045179ea.html\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./components/menu/template/collectPerInfo.html\n// module id = 35\n// module chunks = 0","import Configs from '../../../app/config.js';\r\n\r\nexport default ['$element', '$scope', '$http', 'modalInstance', '$ccValidator', '$ccTips', function($element, $scope, $http, modalInstance, $ccValidator, $ccTips) {\r\n  const that = this;\r\n  this.ok = function() {\r\n    that.perInfoSave(modalInstance.ok);\r\n  };\r\n\r\n  this.ccValidators = {\r\n    phone: {\r\n      msg: '请输入正确的手机号码',\r\n      fn: (modelValue, viewValue) => {\r\n        const value = modelValue || viewValue;\r\n        return value ? /^[1][3-9]{1}\\d{9}$/.test(value) : !value;\r\n      }\r\n    }\r\n  };\r\n\r\n  this.perInfoSave = function(callback) { // 保存联系人方式\r\n    $ccValidator.validate($scope.collerinfo).then(() => {\r\n      var contactPerInfo = {};\r\n      contactPerInfo.fullName = that.contactName;\r\n      contactPerInfo.email = that.contactEmail;\r\n      contactPerInfo.mobile = that.contactPhone;\r\n      contactPerInfo.qq = that.contactQQ;\r\n      contactPerInfo.wangwang = that.contactWW;\r\n      contactPerInfo.weibo = that.contactWeibo;\r\n      contactPerInfo.tenantId = $scope.tenantId;\r\n      $http.post(Configs.webDashboard + '/dashboard/assemble/contact/', contactPerInfo).success(function(response) {\r\n        if (response.code === 200) {\r\n          var sessionData = window.sessionStorage.getItem('shuyunContact');\r\n          if (!sessionData) {\r\n            sessionData = '{}';\r\n          }\r\n          sessionData = JSON.parse(sessionData);\r\n          sessionData.exists = true;\r\n\r\n          for (var i in contactPerInfo) {\r\n            if (!sessionData.contact) {\r\n              sessionData.contact = {};\r\n            }\r\n            sessionData.contact[i] = contactPerInfo[i];\r\n          }\r\n          sessionData = JSON.stringify(sessionData);\r\n          window.sessionStorage.setItem('shuyunContact', sessionData);\r\n          callback();\r\n          $ccTips.success('保存成功');\r\n        } else {\r\n          $ccTips.error(response.message, document.querySelector('.content'));\r\n        }\r\n      });\r\n    }, () => {\r\n      console.log('校验失败!');\r\n    });\r\n  };\r\n  /* end 填写信息 */\r\n}];\r\n\n\n\n// WEBPACK FOOTER //\n// ./components/menu/template/collectPerCtrl.js","module.exports = __webpack_public_path__ + \"components/menu/template/password-2c0c1a3c510aacb8215e.html\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./components/menu/template/password.html\n// module id = 37\n// module chunks = 0","import Configs from '../../../app/config.js';\r\nexport default ['$element', '$scope', 'modalInstance', '$ccValidator', '$http', '$ccTips', function($element, $scope, modalInstance, $ccValidator, $http, $ccTips) {\r\n  const that = this;\r\n  this.ok = function() {\r\n    that.savePassword(modalInstance.ok);\r\n  };\r\n  this.ccValidators = {\r\n    checkpasswd: {\r\n      msg: '密码至少8位，并包括大小写字母及数字',\r\n      regex: /^.*(?=.{8,})(?=.*[a-z])(?=.*[A-Z])(?=.*[0-9]).*$/\r\n    },\r\n    equalTo: {\r\n      msg: '两次输入的密码不一致',\r\n      fn: (modelValue, viewValue) => {\r\n        const value = modelValue || viewValue;\r\n        return value ? (value === that.password) : !value;\r\n      }\r\n    }\r\n  };\r\n  let tips = null;\r\n  var saveFn = function(callback) {\r\n    var PasswordInfo = {\r\n      id: $scope.user.id,\r\n      password: that.password,\r\n      newPassword: that.newPassword,\r\n      oldPassword: that.oldPassword\r\n    };\r\n\r\n    $http.put(Configs.webSystem + 'sys/user/' + PasswordInfo.id + '/password/?_=' + new Date().getTime(), PasswordInfo).success(function() {\r\n      callback();\r\n      $ccTips.success('密码修改成功');\r\n    }).error(function(data, status, headers, config) {\r\n      if (!tips || !tips.element) {\r\n        tips = $ccTips.error(data.description, document.querySelector('.ccms-modal'));\r\n      }\r\n    });\r\n  };\r\n  this.savePassword = callback => {\r\n    $ccValidator.validate($scope.changepassword).then(() => {\r\n      saveFn(callback);\r\n    }, () => {\r\n      console.log('校验失败!');\r\n    });\r\n  };\r\n}];\r\n\n\n\n// WEBPACK FOOTER //\n// ./components/menu/template/passwordCtrl.js","module.exports = __webpack_public_path__ + \"components/menu/template/message-0b9d765fae00c9877d6e.html\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./components/menu/template/message.html\n// module id = 39\n// module chunks = 0","import Service from './../service';\r\n\r\nexport default ['$element', '$scope', '$rootScope', 'modalInstance', '$ccValidator', '$http', '$ccTips', '$interval', '$sce', function($element, $scope, $rootScope, modalInstance, $ccValidator, $http, $ccTips, $interval, $sce) {\r\n  const that = this;\r\n  const ccmsVersion = $rootScope.ccmsVersion;\r\n  // 影藏消息详情内容弹出框\r\n  that.hideContentDialog = function() {\r\n    that.noticeObj.hideMessContent();\r\n  };\r\n\r\n  this.noticeObj = {\r\n    'deleIdList': {},\r\n    'hideContentDialog': function() {\r\n      that.isShowMessContent = false;\r\n    },\r\n    'setSelectAll': function(checked) {\r\n      var _this = this;\r\n      that.popMesses.forEach(function(item) {\r\n        _this.deleIdList[item.id] = checked;\r\n        item.select = checked;\r\n      });\r\n      that.deleteButton = checked;\r\n    },\r\n    'selectNoticeId': function(id, checked) {\r\n      var _this = this;\r\n      _this.deleIdList[id] = checked;\r\n      var checkedList = that.popMesses.filter(function(item) {\r\n        return item.select === true;\r\n      });\r\n      that.deleteButton = checkedList.length > 0;\r\n      that.selectAll = checkedList.length === that.popMesses.length;\r\n      if (that.popMesses.length === 0) {\r\n        that.selectAll = false;\r\n      }\r\n    },\r\n    'getNoticeCb': function(res) {\r\n      that.selectAll = false;\r\n      // 总共多少页\r\n      var pages = Math.ceil(res.total / 10);\r\n      if (pages === 0) {\r\n        pages = 1;\r\n      }\r\n      res.data.forEach(function(item) {\r\n        item.isRead = item.status === 1;\r\n        // item.select = that.noticeObj.deleIdList[item.noticeId];\r\n      });\r\n      that.deleteButton = false;\r\n\r\n      that.popMesses = res.data;\r\n     // that.page = res.page;\r\n      that.total = pages;\r\n      // 是否是第一页，是否是最后一页\r\n      that.isLastPage = !!(pages - res.page);\r\n      that.isFirstPage = res.page !== 1;\r\n    },\r\n    'getNoticeEB': function(res) {\r\n      that.popMesses = [];\r\n      that.page = 0;\r\n      that.total = 0;\r\n    },\r\n    onPageChange: function(pageNum) {\r\n      var _this = this;\r\n      var param = {\r\n        'userName': $rootScope.tenantId,\r\n        'ccmsVersion': ccmsVersion,\r\n        'pageNo': pageNum\r\n      };\r\n      that.page = pageNum;\r\n      Service.getNoticesList(param, _this.getNoticeCb, _this.getNoticeEB);\r\n    },\r\n    'getNotices': function() {\r\n      var _this = this;\r\n      var param = {\r\n        'userName': $rootScope.tenantId,\r\n        'ccmsVersion': ccmsVersion,\r\n        'pageNo': 1\r\n      };\r\n      that.page = 1;\r\n      Service.getNoticesList(param, _this.getNoticeCb, _this.getNoticeEB);\r\n    },\r\n    'readClick': function(index) {\r\n      var notice = that.popMesses[index];\r\n      var param = {\r\n        'campUserName': that.campUserName,\r\n        'userName': $rootScope.tenantId,\r\n        'ccmsVersion': ccmsVersion,\r\n        'id': notice.noticeId * 1\r\n      };\r\n      // $('#isShowMessContent').css('display', 'block')\r\n      that.isShowMessContent = true;\r\n      notice.isRead || Service.postNotice(param);\r\n      notice.isRead = true;\r\n\r\n      that.content = $sce.trustAsHtml(notice.content);\r\n      that.contitle = notice.title;\r\n      that.condate = notice.created;\r\n    },\r\n    'deleteNotice': function() {\r\n      if (!that.deleteButton) return;\r\n      var _this = this;\r\n      var ids = [];\r\n      for (var i in _this.deleIdList) {\r\n        if (_this.deleIdList[i]) {\r\n          ids.push(i);\r\n        }\r\n      }\r\n      var param = {\r\n        'userName': $rootScope.tenantId,\r\n        'setId': ccmsVersion,\r\n        'ccmsVersion': ccmsVersion,\r\n        'ids': ids.join(',')\r\n      };\r\n\r\n      var cb = function(res) {\r\n        _this.ids = [];\r\n        var text = '删除失败';\r\n        if (res.success) {\r\n          text = '删除成功';\r\n        }\r\n        _this.getNotices();\r\n        $ccTips.success(text, document.querySelector('.ccms-modal'));\r\n      };\r\n      var eb = function() {\r\n      };\r\n\r\n      Service.deleteNotices(param, cb, eb);\r\n    },\r\n    'clearNotice': function() {\r\n      var _this = this;\r\n      var ids = [];\r\n      that.popMesses.forEach(function(item) {\r\n        if (item.isRead) {\r\n          ids.push(item.noticeId);\r\n        }\r\n      });\r\n      if (ids.length === 0) return;\r\n      var param = {\r\n        'userName': $rootScope.tenantId,\r\n        'setId': ccmsVersion,\r\n        'ccmsVersion': ccmsVersion,\r\n        'ids': ids.join(',')\r\n      };\r\n\r\n      var cb = function(res) {\r\n        _this.ids = [];\r\n        _this.getNotices();\r\n        $ccTips.success('删除成功', document.querySelector('.ccms-modal'));\r\n      };\r\n      var eb = function() {\r\n      };\r\n\r\n      Service.deleteNotices(param, cb, eb);\r\n    }\r\n  };\r\n\r\n  // 获取服务器数据\r\n  this.noticeObj.getNotices();\r\n}];\r\n\n\n\n// WEBPACK FOOTER //\n// ./components/menu/template/messageCtrl.js","/*\r\n * @author Created by taoyong\r\n * @time Created on 16/5/24.\r\n */\r\n// 顶部导航栏\r\nconst setNavFunction = function() {\r\n  const navElement = document.querySelectorAll('.nav>li');\r\n  const moreElement = document.querySelectorAll('.more');\r\n  const moreLiElement = document.querySelectorAll('.more ul li');\r\n  const listnum = navElement.length; // 导航总共的个数\r\n  const navwidth = document.body.offsetWidth - document.querySelectorAll('h1')[0].offsetWidth - document.querySelectorAll('.headerAside')[0].offsetWidth - 80;\r\n  const showlistnum = parseInt((navwidth / navElement[0].offsetWidth) * 1, 10);\r\n  const hidelistnum = listnum - showlistnum;\r\n  if (hidelistnum > 0) {\r\n    var showLength = navElement.length - hidelistnum - 1;\r\n    for (var i = 0, len = navElement.length; i < len; i++) {\r\n      if (i > showLength) {\r\n        navElement[i].style.display = 'none';\r\n        moreLiElement[i].style.display = 'block';\r\n      } else {\r\n        navElement[i].style.display = 'block';\r\n        moreLiElement[i].style.display = 'none';\r\n      }\r\n    };\r\n    moreElement[0].style.display = 'block';\r\n  } else if (hidelistnum <= 0) {\r\n    for (var j = 0, length = navElement.length; j < length; j++) {\r\n      navElement[j].style.display = 'block';\r\n    };\r\n    moreElement[0].style.display = 'none';\r\n  };\r\n};\r\n\r\ndocument.addEventListener('DOMContentLoaded', () => {\r\n  window.onresize = () => {\r\n    setNavFunction();\r\n  };\r\n});\r\n\r\nexport default {\r\n  setNavFunction\r\n};\r\n\n\n\n// WEBPACK FOOTER //\n// ./common/utils.js","/**\r\n * @author Created by taoyong\r\n * @Date  on 2016/9/2.\r\n */\r\nimport angular from 'angular';\r\nimport InsertCtrl from './insertCtrl';\r\n\r\nexport default angular.module('insert', []).controller('InsertCtrl', InsertCtrl).name;\r\n\n\n\n// WEBPACK FOOTER //\n// ./app/insert/index.js","/**\r\n * @author Created by taoyong\r\n * @Date  on 2016/5/18.\r\n */\r\nimport './insert.scss';\r\nimport angular from 'angular';\r\nimport {Inject} from 'angular-es-utils';\r\n\r\n@Inject('$rootScope', '$stateParams', '$sce', '$state')\r\nexport default class IframeCtrl {\r\n  constructor($rootScope, $stateParams, $sce, $state) {\r\n    const _this = this;\r\n    const context = $stateParams.context || '';\r\n    angular.forEach($rootScope.user.nav, function(v, k) {\r\n      if (v.url.indexOf('insert') !== -1 && v.id.indexOf('_' + context) !== -1) {\r\n        var seesionItem = sessionStorage.getItem('marketingParams');\r\n        var dataUrl = v.dataUrl;\r\n        if (seesionItem) {\r\n          dataUrl += ('&' + seesionItem);\r\n        }\r\n        console.log(dataUrl);\r\n        _this.contextUrl = $sce.trustAsResourceUrl(dataUrl);\r\n        return false;\r\n      }\r\n    });\r\n    window.addEventListener('message', function(e) {\r\n      // dashboard ==> marketing\r\n      if (e.data) {\r\n        if (e.data === 'authReject') {\r\n          if (__pro__) {\r\n            location.pathname = '/portal/timeout.html';\r\n          } else {\r\n            location.pathname = '/portal/login.html';\r\n          }\r\n        } else if (e.data === 'contentManage') {\r\n          // 内容管理\r\n          $state.go('insert', {context: 'contentManage'});\r\n        }\r\n      };\r\n      window.removeEventListener('message', function() {}, false);\r\n    }, false);\r\n  }\r\n};\r\n\n\n\n// WEBPACK FOOTER //\n// ./app/insert/insertCtrl.js","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.EventBus = exports.genResource = exports.dynamicExport = exports.getInjector = exports.Animation = exports.Deferred = exports.ModuleHelper = exports.FactoryCreator = undefined;\n\nvar _decorators = require('./decorators');\n\nObject.keys(_decorators).forEach(function (key) {\n\tif (key === \"default\" || key === \"__esModule\") return;\n\tObject.defineProperty(exports, key, {\n\t\tenumerable: true,\n\t\tget: function get() {\n\t\t\treturn _decorators[key];\n\t\t}\n\t});\n});\n\nvar _factoryCreator = require('./factory-creator');\n\nvar _factoryCreator2 = _interopRequireDefault(_factoryCreator);\n\nvar _moduleHelper = require('./module-helper');\n\nvar _moduleHelper2 = _interopRequireDefault(_moduleHelper);\n\nvar _deferred = require('./deferred');\n\nvar _deferred2 = _interopRequireDefault(_deferred);\n\nvar _animation = require('./animation');\n\nvar _animation2 = _interopRequireDefault(_animation);\n\nvar _injector = require('./injector');\n\nvar _rsGenerator = require('./rs-generator');\n\nvar _rsGenerator2 = _interopRequireDefault(_rsGenerator);\n\nvar _eventBus = require('./event-bus');\n\nvar _eventBus2 = _interopRequireDefault(_eventBus);\n\nvar _dynamicExport = require('./dynamic-export');\n\nvar _dynamicExport2 = _interopRequireDefault(_dynamicExport);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.FactoryCreator = _factoryCreator2.default;\nexports.ModuleHelper = _moduleHelper2.default;\nexports.Deferred = _deferred2.default;\nexports.Animation = _animation2.default;\nexports.getInjector = _injector.getInjector;\nexports.dynamicExport = _dynamicExport2.default;\nexports.genResource = _rsGenerator2.default;\nexports.EventBus = _eventBus2.default; /**\n                                        * @author Kuitos\n                                        * @homepage https://github.com/kuitos/\n                                        * @since 2016-02-02\n                                        */\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/angular-es-utils/index.js\n// module id = 45\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.Delay = exports.Debounce = exports.Throttle = exports.Bind = exports.Inject = undefined;\n\nvar _Inject = require('./Inject');\n\nvar _Inject2 = _interopRequireDefault(_Inject);\n\nvar _Bind = require('./Bind');\n\nvar _Bind2 = _interopRequireDefault(_Bind);\n\nvar _Throttle = require('./Throttle');\n\nvar _Throttle2 = _interopRequireDefault(_Throttle);\n\nvar _Debounce = require('./Debounce');\n\nvar _Debounce2 = _interopRequireDefault(_Debounce);\n\nvar _Delay = require('./Delay');\n\nvar _Delay2 = _interopRequireDefault(_Delay);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.Inject = _Inject2.default;\nexports.Bind = _Bind2.default;\nexports.Throttle = _Throttle2.default;\nexports.Debounce = _Debounce2.default;\nexports.Delay = _Delay2.default; /**\n                                  * @author Kuitos\n                                  * @homepage https://github.com/kuitos/\n                                  * @since 2016-01-17\n                                  */\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/angular-es-utils/decorators/index.js\n// module id = 46\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * @author Kuitos\n * @homepage https://github.com/kuitos/\n * @since 2016-01-11\n */\n\n// safari里调用getOwnPropertyNames会拿到 arguments 跟 caller\nvar stupidSafariProps = ['arguments', 'caller'];\n// 需要过滤的构造函数的属性\nvar propBlacklist = ['name', 'prototype', 'length'].concat(stupidSafariProps);\n/**\n * angular依赖注入器\n */\n\nexports.default = function () {\n\tfor (var _len = arguments.length, dependencies = Array(_len), _key = 0; _key < _len; _key++) {\n\t\tdependencies[_key] = arguments[_key];\n\t}\n\n\treturn function (target, name, descriptor) {\n\n\t\tif (descriptor) {\n\t\t\tthrow new Error('can not use Inject decorator with a non-constructor!');\n\t\t}\n\n\t\tvar OriginalConstructor = target;\n\n\t\tvar Constructor = function Constructor() {\n\t\t\tvar _this = this;\n\n\t\t\tfor (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n\t\t\t\targs[_key2] = arguments[_key2];\n\t\t\t}\n\n\t\t\t_classCallCheck(this, Constructor);\n\n\t\t\t/* ----------------- 以下这一段恶心的代码都是为了兼容function跟class定义controller这两种情况 ------------------------ */\n\t\t\t/* ----------------- 因为class定义的Constructor有时候需要直接访问this中已绑定的数据(fn.apply(instance, locals)) ---- */\n\n\t\t\t// 存在通过 fn.apply(instance, locals) 的方式调用的情况,所以这里直接将依赖的服务拷贝到this里(服务以下划线作为前缀)\n\t\t\tdependencies.forEach(function (dependency, i) {\n\t\t\t\treturn _this['_' + dependency] = args[i];\n\t\t\t});\n\t\t\t// 将构造器初始化时就需要访问的数据挂载到prototype上,这样即使通过new方式实例化,constructor里的this也具备完整信息\n\t\t\tObject.assign(OriginalConstructor.prototype, this);\n\n\t\t\tvar instance = new (Function.prototype.bind.apply(OriginalConstructor, [null].concat(args)))();\n\n\t\t\t// 初始化完毕需要从prototype上删除挂载的属性,因为有一些注入的局部服务对于每一个实例而言是隔离的,如果改变prototype会出现混乱\n\t\t\tObject.keys(this).forEach(function (prop) {\n\t\t\t\t// prototype上不可枚举的属性不能删除(比如方法/accessor等)\n\t\t\t\tif (OriginalConstructor.prototype.propertyIsEnumerable(prop)) {\n\t\t\t\t\tdelete OriginalConstructor.prototype[prop];\n\t\t\t\t}\n\n\t\t\t\t// 属性可能会被重新定义,比如 this.name = this.name + 'xx';\n\t\t\t\t// 所以这里不能直接Object.assign(instance, this)\n\t\t\t\t// 只有this上存在但是instance上不存在的属性才复制过去\n\t\t\t\tif (!instance.hasOwnProperty(prop)) {\n\t\t\t\t\tinstance[prop] = _this[prop];\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn instance;\n\t\t};\n\n\t\t// 将原始构造函数的属性复制到新的Constructor中,包括prototype\n\t\t// 因为通过static class property语法定义的静态方法是不可枚举的,所以这里不能用Object.keys API来筛选.\n\n\n\t\tObject.getOwnPropertyNames(target).forEach(function (prop) {\n\t\t\tif (propBlacklist.indexOf(prop) === -1) {\n\t\t\t\tConstructor[prop] = target[prop];\n\t\t\t}\n\t\t});\n\t\tConstructor.$inject = dependencies;\n\n\t\treturn Constructor;\n\t};\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/angular-es-utils/decorators/Inject.js\n// module id = 47\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\n/**\n * @author Kuitos\n * @homepage https://github.com/kuitos/\n * @since 2016-04-06\n */\n\n/**\n * bind装饰器,用于处理function bind不适用的场景\n */\nexports.default = function (target, name, descriptor) {\n\n\tif (!descriptor) {\n\t\tthrow new Error('can not use Bind decorator with a constructor!');\n\t}\n\n\tvar fn = descriptor.value || target[name];\n\t// use function string as identifier which can ensure every function uniquely after wrapped\n\t// we can not use Function.name as identifier because its name may be empty(anonymous function) or defined by other ways(such as Object.defineProperty)\n\tvar fnName = '__' + fn + 'Fn__';\n\n\t// 定义访问器属性的同时不能定义value跟writable\n\t// @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty\n\tdelete descriptor.value;\n\tdelete descriptor.writable;\n\n\tdescriptor.set = function (value) {\n\t\tthis[fnName] = value;\n\t};\n\n\tdescriptor.get = function () {\n\t\treturn this[fnName] || (this[fnName] = fn.bind(this));\n\t};\n\n\treturn descriptor;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/angular-es-utils/decorators/Bind.js\n// module id = 48\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\n/**\n * @author Kuitos\n * @homepage https://github.com/kuitos/\n * @since 2016-04-12\n */\n\nexports.default = function () {\n\tvar delay = arguments.length <= 0 || arguments[0] === undefined ? 10 : arguments[0];\n\tvar context = arguments[1];\n\treturn function (target, name, descriptor) {\n\n\t\tif (!descriptor) {\n\t\t\tthrow new Error('can not use Throttle decorator with a constructor!');\n\t\t}\n\n\t\tvar fn = descriptor.value || target[name];\n\n\t\tvar recent = void 0;\n\n\t\tdescriptor.value = function () {\n\n\t\t\tvar now = Date.now();\n\n\t\t\tif (!recent || now - recent > delay) {\n\t\t\t\tfor (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t\t\t\t\targs[_key] = arguments[_key];\n\t\t\t\t}\n\n\t\t\t\tfn.apply(context || this, args);\n\t\t\t\trecent = now;\n\t\t\t}\n\t\t};\n\n\t\treturn descriptor;\n\t};\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/angular-es-utils/decorators/Throttle.js\n// module id = 49\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _injector = require('../injector');\n\nvar _injector2 = _interopRequireDefault(_injector);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = function () {\n\tvar delay = arguments.length <= 0 || arguments[0] === undefined ? 300 : arguments[0];\n\tvar context = arguments[1];\n\tvar invokeApply = arguments[2];\n\treturn function (target, name, descriptor) {\n\n\t\tif (!descriptor) {\n\t\t\tthrow new Error('can not use Debounce decorator with a constructor!');\n\t\t}\n\n\t\tvar fn = descriptor.value || target[name];\n\t\tvar $timeout = null;\n\t\tvar pendingDebounce = null;\n\n\t\tdescriptor.value = function () {\n\t\t\tvar _this = this;\n\n\t\t\tfor (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t\t\t\targs[_key] = arguments[_key];\n\t\t\t}\n\n\t\t\t// lazy init\n\t\t\t$timeout = $timeout || _injector2.default.get('$timeout');\n\n\t\t\t$timeout.cancel(pendingDebounce);\n\n\t\t\tpendingDebounce = $timeout(function () {\n\t\t\t\tpendingDebounce = null;\n\t\t\t\tfn.apply(context || _this, args);\n\t\t\t}, delay, invokeApply);\n\t\t};\n\n\t\treturn descriptor;\n\t};\n}; /**\n    * @author Kuitos\n    * @homepage https://github.com/kuitos/\n    * @since 2016-04-12\n    */\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/angular-es-utils/decorators/Debounce.js\n// module id = 50\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _injector = require('../injector');\n\nvar _injector2 = _interopRequireDefault(_injector);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = function () {\n\tvar delay = arguments.length <= 0 || arguments[0] === undefined ? 0 : arguments[0];\n\tvar invokeApply = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];\n\treturn function (target, name, descriptor) {\n\n\t\tif (!descriptor) {\n\t\t\tthrow new Error('can not use Delay decorator with a constructor!');\n\t\t}\n\n\t\tvar fn = descriptor.value || target[name];\n\t\tvar $timeout = null;\n\n\t\tdescriptor.value = function () {\n\t\t\tvar _this = this;\n\n\t\t\tfor (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t\t\t\targs[_key] = arguments[_key];\n\t\t\t}\n\n\t\t\t// lazy init\n\t\t\t$timeout = $timeout || _injector2.default.get('$timeout');\n\t\t\t$timeout(function () {\n\t\t\t\tfn.apply(_this, args);\n\t\t\t}, delay, invokeApply);\n\t\t};\n\n\t\treturn descriptor;\n\t};\n}; /**\n    * @author Kuitos\n    * @homepage https://github.com/kuitos/\n    * @since 2016-07-06\n    */\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/angular-es-utils/decorators/Delay.js\n// module id = 51\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n/**\n * @author Kuitos\n * @homepage https://github.com/kuitos/\n * @since 2015-12-29\n */\n\nvar FUNCTION_PRIVATE_PROPS = ['apply', 'arguments', 'bind', 'call', 'caller', 'constructor', 'Symbol'];\n\nexports.default = {\n\tcreate: function create(Constructor) {\n\n\t\tconsole.warn('FactoryCreator.create 方法将在下一版本废弃,请尽快使用别的替代解决方案!(迁移指南:https://github.com/kuitos/angular-es-utils/blob/master/src/factory-creator/README.md)');\n\n\t\tfunction factory() {\n\t\t\tfor (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t\t\t\targs[_key] = arguments[_key];\n\t\t\t}\n\n\t\t\tvar instance = new (Function.prototype.bind.apply(Constructor, [null].concat(args)))();\n\n\t\t\tvar prototype = Object.getPrototypeOf(instance);\n\n\t\t\tObject.getOwnPropertyNames(prototype).forEach(function (prop) {\n\n\t\t\t\t// 只处理非私有方法\n\t\t\t\tif (FUNCTION_PRIVATE_PROPS.indexOf(prop) === -1) {\n\t\t\t\t\t// 绑定实例到构造函数的每个方法下\n\t\t\t\t\tvar fn = prototype[prop];\n\t\t\t\t\tif (typeof fn === 'function') {\n\t\t\t\t\t\tprototype[prop] = fn.bind(instance);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn instance;\n\t\t}\n\n\t\tfactory.$inject = Constructor.$inject || [];\n\n\t\treturn factory;\n\t}\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/angular-es-utils/factory-creator/index.js\n// module id = 52\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _angular = require('angular');\n\nvar _angular2 = _interopRequireDefault(_angular);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = {\n\tget: function get(moduleName, deps) {\n\n\t\ttry {\n\t\t\treturn _angular2.default.module(moduleName);\n\t\t} catch (e) {\n\t\t\treturn _angular2.default.module(moduleName, deps);\n\t\t}\n\t}\n}; /**\n    * @author Kuitos\n    * @homepage https://github.com/kuitos/\n    * @since 2016-01-17\n    */\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/angular-es-utils/module-helper/index.js\n// module id = 53\n// module chunks = 0","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * @author Kuitos\n * @homepage https://github.com/kuitos/\n * @since 2016-03-02\n */\n\nvar Deferred = function () {\n\tfunction Deferred() {\n\t\tvar _this = this;\n\n\t\t_classCallCheck(this, Deferred);\n\n\t\tthis.promise = new Promise(function (resolve, reject) {\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._reject = reject;\n\t\t});\n\t}\n\n\t_createClass(Deferred, [{\n\t\tkey: \"resolve\",\n\t\tvalue: function resolve(value) {\n\t\t\tthis._resolve.call(this.promise, value);\n\t\t}\n\t}, {\n\t\tkey: \"reject\",\n\t\tvalue: function reject(value) {\n\t\t\tthis._reject.call(this.promise, value);\n\t\t}\n\t}]);\n\n\treturn Deferred;\n}();\n\nexports.default = Deferred;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/angular-es-utils/deferred/index.js\n// module id = 54\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n/**\n * @author Kuitos\n * @homepage https://github.com/kuitos/\n * @since 2016-03-24\n */\n\nvar ANIMATIONEND_EVENT = void 0,\n    TRANSITIONEND_EVENT = void 0;\n\nif (window.onanimationend === undefined && window.onwebkitanimationend !== undefined) {\n\tANIMATIONEND_EVENT = 'webkitAnimationEnd animationend';\n} else {\n\tANIMATIONEND_EVENT = 'animationend';\n}\n\nif (window.ontransitionend === undefined && window.onwebkittransitionend !== undefined) {\n\tTRANSITIONEND_EVENT = 'webkitTransitionEnd transitionend';\n} else {\n\tTRANSITIONEND_EVENT = 'transitionend';\n}\n\nvar EVENTS = [ANIMATIONEND_EVENT, TRANSITIONEND_EVENT].join(' ').split(' ');\nvar noop = function noop() {};\n\nexports.default = {\n\n\taddClass: function addClass(element, className) {\n\t\tvar doneHook = arguments.length <= 2 || arguments[2] === undefined ? noop : arguments[2];\n\t\tvar autoRemove = arguments.length <= 3 || arguments[3] === undefined ? false : arguments[3];\n\n\t\tEVENTS.forEach(function (event) {\n\t\t\telement.addEventListener(event, function () {\n\n\t\t\t\tif (autoRemove) {\n\t\t\t\t\telement.classList.remove(className);\n\t\t\t\t}\n\n\t\t\t\tdoneHook();\n\t\t\t}, false);\n\t\t});\n\n\t\telement.classList.add(className);\n\t},\n\n\tremoveClass: function removeClass(element, className, doneHook) {\n\t\tEVENTS.forEach(function (event) {\n\t\t\telement.addEventListener(event, doneHook, false);\n\t\t});\n\n\t\telement.classList.remove(className);\n\t}\n\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/angular-es-utils/animation/index.js\n// module id = 55\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _typeAuth = require('../type-auth');\n\nvar topics = {};\n\n/**\n * 事件总线。用于解决各模块间无法通过 $scope.$emit $scope.$on 等方式实现通信的问题(例如兄弟模块间通信)\n */\n/**\n * @author Kuitos\n * @homepage https://github.com/kuitos/\n * @since 2016-05-04\n */\n\nexports.default = {\n\n\t/**\n  * 订阅消息\n  * @param topic 订阅消息名\n  * @param listener 消息发布时触发的回调\n  * @returns {Function} 取消订阅的反注册函数\n  */\n\ton: function on(topic, listener) {\n\n\t\tvar topicListeners = topics[topic] = topics[topic] || [];\n\t\ttopicListeners.push(listener);\n\n\t\treturn this.off.bind(this, topic, listener);\n\t},\n\n\tonce: function once(topic, listener) {\n\t\tvar _this = this;\n\n\t\tvar onceListener = function onceListener() {\n\t\t\tfor (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t\t\t\targs[_key] = arguments[_key];\n\t\t\t}\n\n\t\t\t_this.off(topic, onceListener);\n\t\t\tlistener.apply(null, args);\n\t\t};\n\n\t\treturn this.on(topic, onceListener);\n\t},\n\n\t/**\n  * 移除注册信息\n  * @param topic 消息名\n  * @param listener  移除的注册函数,不传则移除全部注册\n  */\n\toff: function off(topic, listener) {\n\n\t\tvar topicListeners = topics[topic];\n\n\t\tif (listener) {\n\n\t\t\tvar listenerIndex = topicListeners.indexOf(listener);\n\t\t\tif (~listenerIndex) {\n\t\t\t\ttopicListeners[listenerIndex] = null;\n\t\t\t}\n\t\t} else {\n\t\t\t// 清空\n\t\t\ttopicListeners.length = 0;\n\t\t}\n\n\t\treturn this;\n\t},\n\n\t/**\n  * 发布消息，支持链式调用\n  */\n\tdispatch: function dispatch() {\n\t\tfor (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n\t\t\targs[_key2] = arguments[_key2];\n\t\t}\n\n\t\tvar topic = args[0];\n\t\tvar listeners = topics[topic] || [];\n\n\t\tfor (var i = 0; i < listeners.length; i++) {\n\n\t\t\tif (listeners[i] === null) {\n\t\t\t\tlisteners.splice(i, 1);\n\t\t\t} else {\n\n\t\t\t\tif ((0, _typeAuth.isFunction)(listeners[i])) {\n\t\t\t\t\tlisteners[i].apply(null, args.slice(1));\n\t\t\t\t} else {\n\t\t\t\t\tconsole.error('事件总线分发 %s 消息失败，注册的listener不是函数类型！', topic);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tgetListeners: function getListeners(topic) {\n\t\treturn topics[topic] || [];\n\t}\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/angular-es-utils/event-bus/index.js\n// module id = 56\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\nexports.isClass = isClass;\nexports.isNumber = isNumber;\nexports.isRegExp = isRegExp;\nexports.isObject = isObject;\nexports.isString = isString;\nexports.isFunction = isFunction;\nexports.isPromiseLike = isPromiseLike;\nexports.isElement = isElement;\nexports.isDefined = isDefined;\n/**\n * @author Kuitos\n * @homepage https://github.com/kuitos/\n * @since 2016-06-07\n */\n\nvar msie = window.document.documentMode;\nfunction isClass(func) {\n\t// IE 9-11 do not support classes and IE9 leaks with the code below.\n\tif (msie <= 11) {\n\t\treturn false;\n\t}\n\t// Workaround for MS Edge.\n\t// Check https://connect.microsoft.com/IE/Feedback/Details/2211653\n\treturn typeof func === 'function' && /^(?:class\\s|constructor\\()/.test(Function.prototype.toString.call(func));\n}\n\nfunction isNumber() {\n\treturn typeof value === 'number';\n}\n\nfunction isRegExp(value) {\n\treturn Object.prototype.toString.call(value) === '[object RegExp]';\n}\n\nfunction isObject(value) {\n\treturn value !== null && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object';\n}\n\nfunction isString(value) {\n\treturn typeof value === 'string';\n}\n\nfunction isFunction(value) {\n\treturn typeof value === 'function';\n}\n\nfunction isPromiseLike(obj) {\n\treturn !!obj && typeof obj.then === 'function';\n}\n\nfunction isElement(node) {\n\treturn !!(node && (node.nodeName || node.prop && node.attr && node.find)); // We have an on and find method part of jQuery API.\n}\n\nfunction isDefined(value) {\n\treturn typeof value !== 'undefined';\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/angular-es-utils/type-auth/index.js\n// module id = 57\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _credentials = require('../credentials');\n\nvar _metadata = require('./metadata');\n\nvar _tokenRefreshInterceptor = require('./token-refresh-interceptor');\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; } /**\n                                                                                                                                                                                                                   * @author qix\n                                                                                                                                                                                                                   * @homepage https://github.com/qixman/\n                                                                                                                                                                                                                   * @since 2016-10-11\n                                                                                                                                                                                                                   */\n\n\nvar needToRefreshToken = false;\n\nexports.default = {\n\n\tbeforeSend: function beforeSend(xhr, config) {\n\n\t\tvar credential = (0, _credentials.getRequestCredential)();\n\t\tif (!credential) {\n\t\t\t(0, _tokenRefreshInterceptor.execAuthFailure)(xhr);\n\t\t\treturn;\n\t\t}\n\n\t\txhr.setRequestHeader(_metadata.REQUEST_TOKEN_HEADER, credential.id);\n\t\txhr[_metadata.REQUEST_TOKEN_HEADER] = credential.id;\n\t\tif (credential.refreshToken && _metadata.REQUEST_WHITE_LIST.indexOf(config.url) === -1) {\n\n\t\t\tvar expireTime = _metadata.Date.parse(credential.expireTime);\n\t\t\tvar now = _metadata.Date.now();\n\n\t\t\t// token失效则直接跳转登录页面\n\t\t\t// token未失效但是可用时长已低于用户会话最短保留时间,则需要刷新token\n\t\t\tif (_metadata.USER_SESSION_AVAILABLE_TIME >= expireTime - now && expireTime - now >= 0) {\n\t\t\t\tneedToRefreshToken = true;\n\t\t\t} else if (expireTime - now < 0) {\n\t\t\t\t// token失效\n\t\t\t\t(0, _tokenRefreshInterceptor.execAuthFailure)(xhr);\n\t\t\t}\n\t\t}\n\t},\n\tcomplete: function complete(xhr) {\n\n\t\t// 如果请求能正常响应,说明 storage 里的状态是存在的,所以这里不做判断\n\t\tvar credential = (0, _credentials.getRequestCredential)();\n\t\tvar $ = window.$;\n\n\t\t// 所有请求结束了才做refreshToken的操作,避免后端因为token被刷新而导致前一请求失败\n\t\tif (needToRefreshToken && $.active <= 1) {\n\t\t\tneedToRefreshToken = false;\n\t\t\txhr[_metadata.REQUEST_TOKEN_HEADER] = credential.id;\n\t\t\t// refresh token\n\t\t\t$.ajax({\n\t\t\t\turl: _tokenRefreshInterceptor.refreshTokenUrl,\n\t\t\t\tmethod: 'PUT',\n\t\t\t\tdata: credential.refreshToken,\n\t\t\t\theaders: _defineProperty({}, _metadata.REQUEST_TOKEN_HEADER, credential.id)\n\t\t\t}).done(function (response) {\n\t\t\t\t// 更新localStorage中token信息\n\t\t\t\t(0, _credentials.setRequestCredential)(JSON.parse(response));\n\t\t\t}).fail(function () {\n\t\t\t\treturn (0, _tokenRefreshInterceptor.execAuthFailure)(xhr);\n\t\t\t});\n\t\t}\n\t}\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/ccms-sdk/interceptors/token-refresh-interceptor-jq.js\n// module id = 58\n// module chunks = 0"],"sourceRoot":""}